{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"phased-array-systems","text":"<p>phased-array-systems is a Python package for phased array antenna system design, optimization, and performance visualization. It supports both wireless communications and radar applications.</p> <pre><code>from phased_array_systems.architecture import Architecture, ArrayConfig, RFChainConfig\nfrom phased_array_systems.scenarios import CommsLinkScenario\nfrom phased_array_systems.evaluate import evaluate_case\n\n# Define your array architecture\narch = Architecture(\n    array=ArrayConfig(nx=8, ny=8, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(tx_power_w_per_elem=1.0, pa_efficiency=0.3),\n)\n\n# Define the operating scenario\nscenario = CommsLinkScenario(\n    freq_hz=10e9,\n    bandwidth_hz=10e6,\n    range_m=100e3,\n    required_snr_db=10.0,\n)\n\n# Evaluate performance\nmetrics = evaluate_case(arch, scenario)\nprint(f\"EIRP: {metrics['eirp_dbw']:.1f} dBW\")\nprint(f\"Link Margin: {metrics['link_margin_db']:.1f} dB\")\n</code></pre>"},{"location":"#requirements-first-design","title":"Requirements-First Design","text":"<p>Every evaluation produces pass/fail results with margins and full traceability to requirements.</p>"},{"location":"#trade-space-exploration","title":"Trade-Space Exploration","text":"<p>DOE generation and Pareto analysis enable systematic exploration of design alternatives.</p>"},{"location":"#model-based-workflow","title":"Model-Based Workflow","text":"<p>MBSE/MDAO workflow from requirements through architecture to optimized designs.</p>"},{"location":"#python-native","title":"Python-Native","text":"<p>Clean Python API with Pydantic validation, type hints, and comprehensive documentation.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#communications-link-budget-analysis","title":"Communications Link Budget Analysis","text":"<p>Calculate EIRP, received power, SNR, and link margin for point-to-point and satellite links:</p> <ul> <li>Free space path loss propagation</li> <li>Atmospheric and rain loss modeling</li> <li>Configurable receiver parameters</li> <li>Automatic scan loss compensation</li> </ul>"},{"location":"#radar-detection-analysis","title":"Radar Detection Analysis","text":"<p>Evaluate radar detection performance with:</p> <ul> <li>Radar range equation calculations</li> <li>Swerling target models (0-4)</li> <li>Pulse integration (coherent and non-coherent)</li> <li>Detection probability and false alarm rate</li> </ul>"},{"location":"#design-of-experiments-doe","title":"Design of Experiments (DOE)","text":"<p>Systematic design space exploration:</p> <ul> <li>Latin Hypercube Sampling (LHS)</li> <li>Full factorial grid generation</li> <li>Random sampling with seed control</li> <li>Augmented DOE for adaptive studies</li> </ul>"},{"location":"#pareto-analysis","title":"Pareto Analysis","text":"<p>Multi-objective optimization support:</p> <ul> <li>Pareto frontier extraction</li> <li>Weighted sum and TOPSIS ranking</li> <li>Hypervolume quality indicator</li> <li>Interactive Pareto plots</li> </ul>"},{"location":"#requirements-verification","title":"Requirements Verification","text":"<p>Track requirements compliance:</p> <ul> <li>Define requirements with operators (<code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>)</li> <li>Severity levels: must, should, nice-to-have</li> <li>Automatic margin calculation</li> <li>Pass/fail verification reports</li> </ul>"},{"location":"#workflow","title":"Workflow","text":"<pre><code>graph LR\n    A[Config YAML/JSON] --&gt; B[Pydantic Validation]\n    B --&gt; C[Architecture + Scenario]\n    C --&gt; D[DOE Generation]\n    D --&gt; E[Batch Evaluation]\n    E --&gt; F[Requirements Verification]\n    F --&gt; G[Pareto Extraction]\n    G --&gt; H[Visualization &amp; Reports]</code></pre> <p>The package implements a model-based systems engineering (MBSE) workflow:</p> <ol> <li>Configuration: Define architecture and scenario in YAML/JSON or Python</li> <li>DOE Generation: Create design space with variable bounds, generate samples</li> <li>Batch Evaluation: Evaluate all cases with parallel processing</li> <li>Verification: Check requirements, compute margins</li> <li>Pareto Analysis: Extract optimal designs, rank alternatives</li> <li>Reporting: Generate plots and HTML/Markdown reports</li> </ol>"},{"location":"#quick-links","title":"Quick Links","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Install the package and run your first analysis.</p>"},{"location":"#user-guide","title":"User Guide","text":"<p>Learn how to configure architectures, run trade studies, and analyze results.</p>"},{"location":"#tutorials","title":"Tutorials","text":"<p>Step-by-step guides for common workflows.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>Complete API documentation for all modules.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install phased-array-systems\n</code></pre> <p>For development:</p> <pre><code>pip install phased-array-systems[dev,plotting,docs]\n</code></pre>"},{"location":"#license","title":"License","text":"<p>phased-array-systems is released under the MIT License.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use phased-array-systems in academic work, please cite:</p> <pre><code>@software{phased_array_systems,\n  title = {phased-array-systems: Phased Array Antenna System Design and Optimization},\n  author = {{phased-array-systems contributors}},\n  year = {2024},\n  url = {https://github.com/jman4162/phased-array-systems}\n}\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>For the full changelog, see:</p> <p>CHANGELOG.md on GitHub</p>"},{"location":"changelog/#recent-changes","title":"Recent Changes","text":""},{"location":"changelog/#040-2026-02-01","title":"[0.4.0] - 2026-02-01","text":"<p>Added: - Digital array model for digital beamforming calculations - RF cascade model for noise figure and gain cascade analysis - Comprehensive MkDocs documentation site with API reference, user guides, and tutorials</p> <p>Fixed: - Ruff linting errors in models module - MathJax rendering in documentation</p>"},{"location":"changelog/#030-2024-01-15","title":"[0.3.0] - 2024-01-15","text":"<p>Added: - Radar detection model with pulse integration - CLI commands: <code>pasys run</code>, <code>pasys doe</code>, <code>pasys report</code>, <code>pasys pareto</code> - HTML and Markdown report generation</p>"},{"location":"changelog/#020-2024-01-01","title":"[0.2.0] - 2024-01-01","text":"<p>Added: - Design of Experiments (DOE) with LHS, random, and grid - Pareto frontier extraction and TOPSIS ranking - Requirements verification system</p>"},{"location":"changelog/#010-2023-12-15","title":"[0.1.0] - 2023-12-15","text":"<p>Added: - Initial release - Architecture configuration - Communications link budget model - Basic visualization</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to phased-array-systems!</p> <p>For detailed contribution guidelines, please see:</p> <p>CONTRIBUTING.md on GitHub</p>"},{"location":"contributing/#quick-start","title":"Quick Start","text":"<pre><code># Clone and install\ngit clone https://github.com/jman4162/phased-array-systems.git\ncd phased-array-systems\npip install -e \".[dev,docs,plotting]\"\n\n# Run tests\npytest tests/ -v\n\n# Run linting\nruff check .\nruff format .\n</code></pre>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>Bug Reports: Open an issue with reproducible example</li> <li>Documentation: Fix typos, improve explanations</li> <li>Code: New features, bug fixes, tests</li> <li>Examples: New tutorials, use cases</li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make changes with tests</li> <li>Run linting and tests</li> <li>Submit PR with clear description</li> </ol>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful and constructive. We welcome contributors of all experience levels.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>Common questions about phased-array-systems.</p>"},{"location":"faq/#installation","title":"Installation","text":""},{"location":"faq/#q-how-do-i-install-phased-array-systems","title":"Q: How do I install phased-array-systems?","text":"<pre><code>pip install phased-array-systems\n</code></pre> <p>For all features:</p> <pre><code>pip install phased-array-systems[dev,plotting,docs]\n</code></pre>"},{"location":"faq/#q-what-python-versions-are-supported","title":"Q: What Python versions are supported?","text":"<p>Python 3.10 and later.</p>"},{"location":"faq/#q-i-get-an-error-about-phased-array-modeling-not-found","title":"Q: I get an error about phased-array-modeling not found","text":"<p>Install it explicitly:</p> <pre><code>pip install phased-array-modeling&gt;=1.2.0\n</code></pre>"},{"location":"faq/#configuration","title":"Configuration","text":""},{"location":"faq/#q-why-do-array-dimensions-need-to-be-powers-of-2","title":"Q: Why do array dimensions need to be powers of 2?","text":"<p>This is the sub-array constraint for practical RF component design. Arrays are typically built from sub-arrays (e.g., 8\u00d78 tiles), and dimensions must be compatible with this tiling.</p> <p>To disable:</p> <pre><code>ArrayConfig(nx=10, ny=10, enforce_subarray_constraint=False)\n</code></pre>"},{"location":"faq/#q-whats-the-difference-between-must-should-and-nice-requirements","title":"Q: What's the difference between <code>must</code>, <code>should</code>, and <code>nice</code> requirements?","text":"Severity Meaning Effect <code>must</code> Mandatory Fails verification if not met <code>should</code> Desired Tracked but doesn't fail <code>nice</code> Optional Tracked but doesn't fail"},{"location":"faq/#q-how-do-i-fix-metric-not-found-errors-in-requirements","title":"Q: How do I fix \"metric not found\" errors in requirements?","text":"<p>Ensure the <code>metric_key</code> matches exactly the key returned by <code>evaluate_case()</code>. Common keys:</p> <ul> <li><code>eirp_dbw</code> (not <code>eirp</code> or <code>EIRP</code>)</li> <li><code>link_margin_db</code> (not <code>margin</code>)</li> <li><code>cost_usd</code> (not <code>cost</code>)</li> </ul>"},{"location":"faq/#trade-studies","title":"Trade Studies","text":""},{"location":"faq/#q-how-many-doe-samples-should-i-use","title":"Q: How many DOE samples should I use?","text":"Design Space Size Recommended Samples &lt; 5 variables 50-100 5-10 variables 100-200 &gt; 10 variables 200+ <p>Use Latin Hypercube Sampling (LHS) for best coverage.</p>"},{"location":"faq/#q-why-are-all-my-designs-infeasible","title":"Q: Why are all my designs infeasible?","text":"<p>Common causes:</p> <ol> <li>Requirements too strict: Relax thresholds</li> <li>Design space too narrow: Expand bounds</li> <li>Conflicting requirements: Check if requirements are achievable together</li> </ol> <p>Debug:</p> <pre><code># Check what's failing\nreport = requirements.verify(metrics)\nfor result in report.results:\n    print(f\"{result.requirement.id}: {result.passes}, margin={result.margin}\")\n</code></pre>"},{"location":"faq/#q-can-i-run-evaluations-in-parallel","title":"Q: Can I run evaluations in parallel?","text":"<p>Yes, use <code>n_workers</code>:</p> <pre><code>runner = BatchRunner(scenario, requirements)\nresults = runner.run(doe, n_workers=4)\n</code></pre>"},{"location":"faq/#q-how-do-i-add-more-samples-to-an-existing-study","title":"Q: How do I add more samples to an existing study?","text":"<pre><code>from phased_array_systems.trades import augment_doe\n\nexpanded = augment_doe(existing_doe, design_space, n_additional=50, seed=43)\nnew_cases = expanded[~expanded[\"case_id\"].isin(existing_doe[\"case_id\"])]\nnew_results = runner.run(new_cases)\n</code></pre>"},{"location":"faq/#pareto-analysis","title":"Pareto Analysis","text":""},{"location":"faq/#q-what-does-pareto-optimal-mean","title":"Q: What does \"Pareto optimal\" mean?","text":"<p>A design is Pareto optimal if no other design is better in ALL objectives. Improving one objective requires sacrificing another.</p>"},{"location":"faq/#q-how-do-i-choose-weights-for-ranking","title":"Q: How do I choose weights for ranking?","text":"<p>Weights reflect stakeholder priorities:</p> <ul> <li>Cost-conscious: <code>weights=[0.8, 0.2]</code></li> <li>Balanced: <code>weights=[0.5, 0.5]</code></li> <li>Performance-focused: <code>weights=[0.2, 0.8]</code></li> </ul> <p>Present rankings under multiple scenarios.</p>"},{"location":"faq/#q-why-is-my-pareto-front-empty","title":"Q: Why is my Pareto front empty?","text":"<p>Check that you're using feasible designs:</p> <pre><code>feasible = filter_feasible(results, requirements)\npareto = extract_pareto(feasible, objectives)  # Not results!\n</code></pre>"},{"location":"faq/#performance","title":"Performance","text":""},{"location":"faq/#q-evaluation-is-slow-how-can-i-speed-it-up","title":"Q: Evaluation is slow. How can I speed it up?","text":"<ol> <li>Use parallel workers: <code>n_workers=4</code></li> <li>Reduce DOE size for initial exploration</li> <li>Simplify antenna model if full pattern not needed</li> </ol>"},{"location":"faq/#q-memory-usage-is-high-with-large-doe","title":"Q: Memory usage is high with large DOE","text":"<p>Results are stored as pandas DataFrame. For very large studies:</p> <pre><code># Export incrementally\nfor batch in batches:\n    results = runner.run(batch)\n    export_results(results, f\"batch_{i}.parquet\")\n</code></pre>"},{"location":"faq/#models","title":"Models","text":""},{"location":"faq/#q-how-is-antenna-gain-calculated","title":"Q: How is antenna gain calculated?","text":"<p>If pre-computed antenna metrics aren't provided, gain is approximated:</p> \\[G \\approx \\eta \\cdot 4\\pi \\cdot n_x d_x \\cdot n_y d_y\\] <p>For accurate patterns, use the full antenna adapter with <code>phased-array-modeling</code>.</p>"},{"location":"faq/#q-what-propagation-models-are-supported","title":"Q: What propagation models are supported?","text":"<p>Currently: Free Space Path Loss (FSPL).</p> <p>Additional losses (atmospheric, rain, polarization) are added separately in the scenario.</p>"},{"location":"faq/#q-how-do-swerling-models-affect-radar-detection","title":"Q: How do Swerling models affect radar detection?","text":"<p>Higher Swerling models represent target fluctuation and require more SNR:</p> Model Typical SNR Penalty 0 (steady) 0 dB 1 (slow) 3-8 dB 2 (fast) 2-5 dB"},{"location":"faq/#cli","title":"CLI","text":""},{"location":"faq/#q-how-do-i-use-the-cli","title":"Q: How do I use the CLI?","text":"<pre><code># Single evaluation\npasys run config.yaml\n\n# DOE study\npasys doe config.yaml -n 100\n\n# Report\npasys report results.parquet\n\n# Pareto\npasys pareto results.parquet -x cost_usd -y eirp_dbw\n</code></pre>"},{"location":"faq/#q-where-are-results-saved","title":"Q: Where are results saved?","text":"<p>Default: <code>./results/results.parquet</code></p> <p>Specify with <code>-o</code>:</p> <pre><code>pasys doe config.yaml -n 100 -o ./my_study\n</code></pre>"},{"location":"faq/#visualization","title":"Visualization","text":""},{"location":"faq/#q-plots-dont-display-in-my-environment","title":"Q: Plots don't display in my environment","text":"<p>Use non-interactive backend:</p> <pre><code>import matplotlib\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\n\n# Save instead of show\nfig.savefig(\"plot.png\", dpi=150)\n</code></pre>"},{"location":"faq/#q-how-do-i-customize-plot-styling","title":"Q: How do I customize plot styling?","text":"<p>Access matplotlib axes:</p> <pre><code>fig = pareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\")\nax = fig.axes[0]\nax.set_xlim([0, 100000])\nax.axhline(y=40, color='r', linestyle='--')\n</code></pre>"},{"location":"faq/#contributing","title":"Contributing","text":""},{"location":"faq/#q-how-do-i-report-a-bug","title":"Q: How do I report a bug?","text":"<p>Open an issue at: https://github.com/jman4162/phased-array-systems/issues</p> <p>Include: - Python version - Package version - Minimal reproducible example - Error message</p>"},{"location":"faq/#q-how-do-i-contribute-code","title":"Q: How do I contribute code?","text":"<p>See CONTRIBUTING.md</p>"},{"location":"faq/#more-help","title":"More Help","text":"<ul> <li>Documentation: https://jman4162.github.io/phased-array-systems</li> <li>Issues: https://github.com/jman4162/phased-array-systems/issues</li> <li>Source: https://github.com/jman4162/phased-array-systems</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for phased-array-systems, auto-generated from source docstrings.</p>"},{"location":"api/#package-structure","title":"Package Structure","text":"<pre><code>phased_array_systems/\n\u251c\u2500\u2500 architecture/     # System configuration\n\u251c\u2500\u2500 scenarios/        # Operating conditions\n\u251c\u2500\u2500 requirements/     # Requirements management\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 antenna/      # Antenna metrics\n\u2502   \u251c\u2500\u2500 comms/        # Link budget\n\u2502   \u251c\u2500\u2500 radar/        # Radar detection\n\u2502   \u251c\u2500\u2500 digital/      # Digital array (ADC/DAC, bandwidth, scheduling)\n\u2502   \u251c\u2500\u2500 rf/           # RF cascade (noise figure, gain, dynamic range)\n\u2502   \u2514\u2500\u2500 swapc/        # SWaP-C models\n\u251c\u2500\u2500 trades/           # DOE and Pareto\n\u251c\u2500\u2500 viz/              # Visualization\n\u251c\u2500\u2500 io/               # File I/O\n\u2514\u2500\u2500 reports/          # Report generation\n</code></pre>"},{"location":"api/#quick-links","title":"Quick Links","text":""},{"location":"api/#core-configuration","title":"Core Configuration","text":"<ul> <li>Architecture - <code>ArrayConfig</code>, <code>RFChainConfig</code>, <code>CostConfig</code>, <code>Architecture</code></li> <li>Scenarios - <code>CommsLinkScenario</code>, <code>RadarDetectionScenario</code></li> <li>Requirements - <code>Requirement</code>, <code>RequirementSet</code>, <code>VerificationReport</code></li> </ul>"},{"location":"api/#models","title":"Models","text":"<ul> <li>Antenna - Antenna adapter and metrics</li> <li>Communications - Link budget model</li> <li>Radar - Radar equation and detection</li> <li>Digital - ADC/DAC, bandwidth, timeline scheduling</li> <li>RF - Noise figure, gain cascade, dynamic range</li> <li>SWaP-C - Power and cost models</li> </ul>"},{"location":"api/#trade-studies","title":"Trade Studies","text":"<ul> <li>Trades - <code>DesignSpace</code>, <code>generate_doe</code>, <code>BatchRunner</code>, <code>extract_pareto</code></li> </ul>"},{"location":"api/#output","title":"Output","text":"<ul> <li>Visualization - <code>pareto_plot</code>, <code>scatter_matrix</code>, <code>trade_space_plot</code></li> <li>I/O - <code>load_config</code>, <code>export_results</code></li> <li>Reports - <code>HTMLReport</code>, <code>MarkdownReport</code></li> </ul>"},{"location":"api/#common-patterns","title":"Common Patterns","text":""},{"location":"api/#single-case-evaluation","title":"Single Case Evaluation","text":"<pre><code>from phased_array_systems.architecture import Architecture, ArrayConfig, RFChainConfig\nfrom phased_array_systems.scenarios import CommsLinkScenario\nfrom phased_array_systems.evaluate import evaluate_case\n\narch = Architecture(\n    array=ArrayConfig(nx=8, ny=8),\n    rf=RFChainConfig(tx_power_w_per_elem=1.0),\n)\n\nscenario = CommsLinkScenario(\n    freq_hz=10e9, bandwidth_hz=10e6, range_m=100e3, required_snr_db=10.0\n)\n\nmetrics = evaluate_case(arch, scenario)\n</code></pre>"},{"location":"api/#trade-study","title":"Trade Study","text":"<pre><code>from phased_array_systems.trades import (\n    DesignSpace, generate_doe, BatchRunner, filter_feasible, extract_pareto\n)\n\nspace = DesignSpace().add_variable(\"array.nx\", \"int\", low=4, high=16)\ndoe = generate_doe(space, method=\"lhs\", n_samples=100, seed=42)\nrunner = BatchRunner(scenario)\nresults = runner.run(doe)\npareto = extract_pareto(filter_feasible(results), [(\"cost_usd\", \"minimize\"), (\"eirp_dbw\", \"maximize\")])\n</code></pre>"},{"location":"api/#requirements-verification","title":"Requirements Verification","text":"<pre><code>from phased_array_systems.requirements import Requirement, RequirementSet\n\nrequirements = RequirementSet(requirements=[\n    Requirement(\"REQ-001\", \"Min EIRP\", \"eirp_dbw\", \"&gt;=\", 40.0),\n])\nreport = requirements.verify(metrics)\n</code></pre>"},{"location":"api/#type-annotations","title":"Type Annotations","text":"<p>The package uses type hints throughout. Key types:</p> <pre><code>from phased_array_systems.types import (\n    MetricsDict,        # dict[str, float | int | str | None]\n    OptimizeDirection,  # Literal[\"minimize\", \"maximize\"]\n    ComparisonOp,       # Literal[\"&gt;=\", \"&lt;=\", \"&gt;\", \"&lt;\", \"==\"]\n    Severity,           # Literal[\"must\", \"should\", \"nice\"]\n)\n</code></pre>"},{"location":"api/#version","title":"Version","text":"<pre><code>from phased_array_systems import __version__\nprint(__version__)\n</code></pre>"},{"location":"api/architecture/","title":"Architecture API","text":"<p>System configuration classes for defining phased array architectures.</p>"},{"location":"api/architecture/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.architecture import (\n    Architecture,\n    ArrayConfig,\n    RFChainConfig,\n    CostConfig,\n)\n</code></pre>"},{"location":"api/architecture/#classes","title":"Classes","text":""},{"location":"api/architecture/#phased_array_systems.architecture.config.ArrayConfig","title":"ArrayConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the antenna array geometry.</p> ATTRIBUTE DESCRIPTION <code>geometry</code> <p>Array geometry type</p> <p> TYPE: <code>Literal['rectangular', 'circular', 'triangular']</code> </p> <code>nx</code> <p>Number of elements in x-direction</p> <p> TYPE: <code>int</code> </p> <code>ny</code> <p>Number of elements in y-direction</p> <p> TYPE: <code>int</code> </p> <code>dx_lambda</code> <p>Element spacing in x-direction (wavelengths)</p> <p> TYPE: <code>float</code> </p> <code>dy_lambda</code> <p>Element spacing in y-direction (wavelengths)</p> <p> TYPE: <code>float</code> </p> <code>scan_limit_deg</code> <p>Maximum scan angle from boresight (degrees)</p> <p> TYPE: <code>float</code> </p> <code>max_subarray_nx</code> <p>Maximum elements per sub-array in x (must be power of 2)</p> <p> TYPE: <code>int</code> </p> <code>max_subarray_ny</code> <p>Maximum elements per sub-array in y (must be power of 2)</p> <p> TYPE: <code>int</code> </p> <code>enforce_subarray_constraint</code> <p>Whether to enforce power-of-two sub-array constraint</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.ArrayConfig.n_elements","title":"n_elements  <code>property</code>","text":"<pre><code>n_elements: int\n</code></pre> <p>Total number of elements in the array.</p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.ArrayConfig.subarray_nx","title":"subarray_nx  <code>property</code>","text":"<pre><code>subarray_nx: int\n</code></pre> <p>Actual elements per sub-array in x-direction.</p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.ArrayConfig.subarray_ny","title":"subarray_ny  <code>property</code>","text":"<pre><code>subarray_ny: int\n</code></pre> <p>Actual elements per sub-array in y-direction.</p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.ArrayConfig.n_subarrays_x","title":"n_subarrays_x  <code>property</code>","text":"<pre><code>n_subarrays_x: int\n</code></pre> <p>Number of sub-arrays in x-direction.</p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.ArrayConfig.n_subarrays_y","title":"n_subarrays_y  <code>property</code>","text":"<pre><code>n_subarrays_y: int\n</code></pre> <p>Number of sub-arrays in y-direction.</p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.ArrayConfig.n_subarrays","title":"n_subarrays  <code>property</code>","text":"<pre><code>n_subarrays: int\n</code></pre> <p>Total number of sub-arrays.</p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.ArrayConfig.elements_per_subarray","title":"elements_per_subarray  <code>property</code>","text":"<pre><code>elements_per_subarray: int\n</code></pre> <p>Number of elements per sub-array.</p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.ArrayConfig.validate_power_of_two","title":"validate_power_of_two  <code>classmethod</code>","text":"<pre><code>validate_power_of_two(v: int) -&gt; int\n</code></pre> <p>Validate that max sub-array dimensions are powers of two.</p> Source code in <code>src/phased_array_systems/architecture/config.py</code> <pre><code>@field_validator(\"max_subarray_nx\", \"max_subarray_ny\")\n@classmethod\ndef validate_power_of_two(cls, v: int) -&gt; int:\n    \"\"\"Validate that max sub-array dimensions are powers of two.\"\"\"\n    if not is_power_of_two(v):\n        raise ValueError(\n            f\"max_subarray value {v} must be a power of 2 \"\n            f\"(valid values: {VALID_POWERS_OF_TWO})\"\n        )\n    return v\n</code></pre>"},{"location":"api/architecture/#phased_array_systems.architecture.config.ArrayConfig.validate_subarray_constraints","title":"validate_subarray_constraints","text":"<pre><code>validate_subarray_constraints() -&gt; ArrayConfig\n</code></pre> <p>Validate that array dimensions result in power-of-two sub-arrays.</p> Source code in <code>src/phased_array_systems/architecture/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_subarray_constraints(self) -&gt; \"ArrayConfig\":\n    \"\"\"Validate that array dimensions result in power-of-two sub-arrays.\"\"\"\n    if not self.enforce_subarray_constraint:\n        return self\n\n    if self.geometry != \"rectangular\":\n        # Sub-array constraints only apply to rectangular arrays for now\n        return self\n\n    # Check x-direction\n    if self.nx &gt; self.max_subarray_nx:\n        # Must be divisible by max_subarray_nx\n        if self.nx % self.max_subarray_nx != 0:\n            raise ValueError(\n                f\"nx={self.nx} must be divisible by max_subarray_nx={self.max_subarray_nx} \"\n                f\"for arrays larger than max sub-array size. \"\n                f\"Set enforce_subarray_constraint=False to disable.\"\n            )\n    else:\n        # Small array: nx itself must be power of two\n        if not is_power_of_two(self.nx):\n            raise ValueError(\n                f\"nx={self.nx} must be a power of 2 (2, 4, 8, 16, ...) when \"\n                f\"enforce_subarray_constraint=True. Valid values: {VALID_POWERS_OF_TWO}\"\n            )\n\n    # Check y-direction\n    if self.ny &gt; self.max_subarray_ny:\n        # Must be divisible by max_subarray_ny\n        if self.ny % self.max_subarray_ny != 0:\n            raise ValueError(\n                f\"ny={self.ny} must be divisible by max_subarray_ny={self.max_subarray_ny} \"\n                f\"for arrays larger than max sub-array size. \"\n                f\"Set enforce_subarray_constraint=False to disable.\"\n            )\n    else:\n        # Small array: ny itself must be power of two\n        if not is_power_of_two(self.ny):\n            raise ValueError(\n                f\"ny={self.ny} must be a power of 2 (2, 4, 8, 16, ...) when \"\n                f\"enforce_subarray_constraint=True. Valid values: {VALID_POWERS_OF_TWO}\"\n            )\n\n    return self\n</code></pre>"},{"location":"api/architecture/#phased_array_systems.architecture.config.RFChainConfig","title":"RFChainConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the RF chain.</p> ATTRIBUTE DESCRIPTION <code>tx_power_w_per_elem</code> <p>Transmit power per element (Watts)</p> <p> TYPE: <code>float</code> </p> <code>pa_efficiency</code> <p>Power amplifier efficiency (0-1)</p> <p> TYPE: <code>float</code> </p> <code>noise_figure_db</code> <p>Receiver noise figure (dB)</p> <p> TYPE: <code>float</code> </p> <code>n_tx_beams</code> <p>Number of simultaneous transmit beams</p> <p> TYPE: <code>int</code> </p> <code>feed_loss_db</code> <p>Feed network loss (dB)</p> <p> TYPE: <code>float</code> </p> <code>system_loss_db</code> <p>Additional system losses (dB)</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.CostConfig","title":"CostConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for cost modeling.</p> ATTRIBUTE DESCRIPTION <code>cost_per_elem_usd</code> <p>Recurring cost per element (USD)</p> <p> TYPE: <code>float</code> </p> <code>nre_usd</code> <p>Non-recurring engineering cost (USD)</p> <p> TYPE: <code>float</code> </p> <code>integration_cost_usd</code> <p>System integration cost (USD)</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.Architecture","title":"Architecture","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete system architecture configuration.</p> <p>This is the top-level configuration object that contains all subsystem configurations.</p> ATTRIBUTE DESCRIPTION <code>array</code> <p>Antenna array configuration</p> <p> TYPE: <code>ArrayConfig</code> </p> <code>rf</code> <p>RF chain configuration</p> <p> TYPE: <code>RFChainConfig</code> </p> <code>cost</code> <p>Cost model configuration</p> <p> TYPE: <code>CostConfig</code> </p> <code>name</code> <p>Optional name for this architecture</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.Architecture.n_elements","title":"n_elements  <code>property</code>","text":"<pre><code>n_elements: int\n</code></pre> <p>Total number of elements (convenience property).</p>"},{"location":"api/architecture/#phased_array_systems.architecture.config.Architecture.model_dump_flat","title":"model_dump_flat","text":"<pre><code>model_dump_flat() -&gt; dict\n</code></pre> <p>Return a flattened dictionary of all configuration values.</p> <p>Useful for DOE case generation where we need flat parameter names.</p> Source code in <code>src/phased_array_systems/architecture/config.py</code> <pre><code>def model_dump_flat(self) -&gt; dict:\n    \"\"\"Return a flattened dictionary of all configuration values.\n\n    Useful for DOE case generation where we need flat parameter names.\n    \"\"\"\n    flat = {}\n    for prefix, config in [\n        (\"array\", self.array),\n        (\"rf\", self.rf),\n        (\"cost\", self.cost),\n    ]:\n        for key, value in config.model_dump().items():\n            flat[f\"{prefix}.{key}\"] = value\n    if self.name:\n        flat[\"name\"] = self.name\n    return flat\n</code></pre>"},{"location":"api/architecture/#phased_array_systems.architecture.config.Architecture.from_flat","title":"from_flat  <code>classmethod</code>","text":"<pre><code>from_flat(flat_dict: dict) -&gt; Architecture\n</code></pre> <p>Create an Architecture from a flattened dictionary.</p> PARAMETER DESCRIPTION <code>flat_dict</code> <p>Dictionary with keys like \"array.nx\", \"rf.tx_power_w_per_elem\"</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>Architecture</code> <p>Architecture instance</p> Source code in <code>src/phased_array_systems/architecture/config.py</code> <pre><code>@classmethod\ndef from_flat(cls, flat_dict: dict) -&gt; \"Architecture\":\n    \"\"\"Create an Architecture from a flattened dictionary.\n\n    Args:\n        flat_dict: Dictionary with keys like \"array.nx\", \"rf.tx_power_w_per_elem\"\n\n    Returns:\n        Architecture instance\n    \"\"\"\n    array_dict = {}\n    rf_dict = {}\n    cost_dict = {}\n    name = None\n\n    for key, value in flat_dict.items():\n        if key == \"name\":\n            name = value\n        elif key.startswith(\"array.\"):\n            array_dict[key.replace(\"array.\", \"\")] = value\n        elif key.startswith(\"rf.\"):\n            rf_dict[key.replace(\"rf.\", \"\")] = value\n        elif key.startswith(\"cost.\"):\n            cost_dict[key.replace(\"cost.\", \"\")] = value\n\n    return cls(\n        array=ArrayConfig(**array_dict),\n        rf=RFChainConfig(**rf_dict),\n        cost=CostConfig(**cost_dict) if cost_dict else CostConfig(),\n        name=name,\n    )\n</code></pre>"},{"location":"api/architecture/#helper-functions","title":"Helper Functions","text":""},{"location":"api/architecture/#phased_array_systems.architecture.config.is_power_of_two","title":"is_power_of_two","text":"<pre><code>is_power_of_two(n: int) -&gt; bool\n</code></pre> <p>Check if n is a power of two (and &gt;= 2).</p> Source code in <code>src/phased_array_systems/architecture/config.py</code> <pre><code>def is_power_of_two(n: int) -&gt; bool:\n    \"\"\"Check if n is a power of two (and &gt;= 2).\"\"\"\n    return n &gt;= 2 and (n &amp; (n - 1)) == 0\n</code></pre>"},{"location":"api/architecture/#constants","title":"Constants","text":"<pre><code># Valid sub-array dimensions (powers of 2)\nVALID_POWERS_OF_TWO = [2, 4, 8, 16, 32, 64, 128, 256, 512]\n</code></pre>"},{"location":"api/architecture/#usage-examples","title":"Usage Examples","text":""},{"location":"api/architecture/#basic-architecture","title":"Basic Architecture","text":"<pre><code>from phased_array_systems.architecture import (\n    Architecture, ArrayConfig, RFChainConfig, CostConfig\n)\n\narch = Architecture(\n    array=ArrayConfig(nx=8, ny=8, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(tx_power_w_per_elem=1.0, pa_efficiency=0.3),\n    cost=CostConfig(cost_per_elem_usd=100.0),\n    name=\"Baseline Design\",\n)\n\nprint(f\"Elements: {arch.n_elements}\")\nprint(f\"Sub-arrays: {arch.array.n_subarrays}\")\n</code></pre>"},{"location":"api/architecture/#flattening-for-doe","title":"Flattening for DOE","text":"<pre><code># Convert to flat dictionary\nflat = arch.model_dump_flat()\n# {'array.nx': 8, 'array.ny': 8, 'array.dx_lambda': 0.5, ...}\n\n# Reconstruct from flat dictionary\narch2 = Architecture.from_flat(flat)\n</code></pre>"},{"location":"api/architecture/#validation-examples","title":"Validation Examples","text":"<pre><code># This raises ValidationError - nx must be &gt;= 1\nArrayConfig(nx=0, ny=8)\n\n# This raises ValidationError - efficiency must be 0-1\nRFChainConfig(tx_power_w_per_elem=1.0, pa_efficiency=1.5)\n\n# This raises ValidationError - not power of 2\nArrayConfig(nx=6, ny=6, enforce_subarray_constraint=True)\n\n# This works - constraint disabled\nArrayConfig(nx=6, ny=6, enforce_subarray_constraint=False)\n</code></pre>"},{"location":"api/architecture/#see-also","title":"See Also","text":"<ul> <li>User Guide: Architecture</li> <li>Scenarios API</li> <li>Requirements API</li> </ul>"},{"location":"api/io/","title":"I/O API","text":"<p>Configuration loading and results export.</p>"},{"location":"api/io/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.io import (\n    load_config,\n    export_results,\n)\n</code></pre>"},{"location":"api/io/#functions","title":"Functions","text":""},{"location":"api/io/#phased_array_systems.io.config_loader.load_config","title":"load_config","text":"<pre><code>load_config(path: str | Path) -&gt; StudyConfig\n</code></pre> <p>Load a study configuration from a YAML or JSON file.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to configuration file (.yaml, .yml, or .json)</p> <p> TYPE: <code>str | Path</code> </p> RETURNS DESCRIPTION <code>StudyConfig</code> <p>Validated StudyConfig object</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If config file doesn't exist</p> <code>ValueError</code> <p>If file format is not supported</p> <code>ValidationError</code> <p>If config validation fails</p> Source code in <code>src/phased_array_systems/io/config_loader.py</code> <pre><code>def load_config(path: str | Path) -&gt; StudyConfig:\n    \"\"\"Load a study configuration from a YAML or JSON file.\n\n    Args:\n        path: Path to configuration file (.yaml, .yml, or .json)\n\n    Returns:\n        Validated StudyConfig object\n\n    Raises:\n        FileNotFoundError: If config file doesn't exist\n        ValueError: If file format is not supported\n        ValidationError: If config validation fails\n    \"\"\"\n    path = Path(path)\n\n    if not path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {path}\")\n\n    suffix = path.suffix.lower()\n\n    if suffix in (\".yaml\", \".yml\"):\n        with open(path, encoding=\"utf-8\") as f:\n            data = yaml.safe_load(f)\n    elif suffix == \".json\":\n        with open(path, encoding=\"utf-8\") as f:\n            data = json.load(f)\n    else:\n        raise ValueError(f\"Unsupported config format: {suffix}. Use .yaml, .yml, or .json\")\n\n    return StudyConfig.model_validate(data)\n</code></pre>"},{"location":"api/io/#phased_array_systems.io.exporters.export_results","title":"export_results","text":"<pre><code>export_results(results: DataFrame, path: str | Path, format: Literal['parquet', 'csv', 'json'] | None = None, include_metadata: bool = True) -&gt; Path\n</code></pre> <p>Export evaluation results to file.</p> PARAMETER DESCRIPTION <code>results</code> <p>DataFrame with evaluation results</p> <p> TYPE: <code>DataFrame</code> </p> <code>path</code> <p>Output file path</p> <p> TYPE: <code>str | Path</code> </p> <code>format</code> <p>Output format (auto-detected from extension if None)</p> <p> TYPE: <code>Literal['parquet', 'csv', 'json'] | None</code> DEFAULT: <code>None</code> </p> <code>include_metadata</code> <p>Include export metadata (timestamp, version)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to exported file</p> Source code in <code>src/phased_array_systems/io/exporters.py</code> <pre><code>def export_results(\n    results: pd.DataFrame,\n    path: str | Path,\n    format: Literal[\"parquet\", \"csv\", \"json\"] | None = None,\n    include_metadata: bool = True,\n) -&gt; Path:\n    \"\"\"Export evaluation results to file.\n\n    Args:\n        results: DataFrame with evaluation results\n        path: Output file path\n        format: Output format (auto-detected from extension if None)\n        include_metadata: Include export metadata (timestamp, version)\n\n    Returns:\n        Path to exported file\n    \"\"\"\n    path = Path(path)\n\n    if format is None:\n        suffix = path.suffix.lower()\n        if suffix == \".parquet\":\n            format = \"parquet\"\n        elif suffix == \".csv\":\n            format = \"csv\"\n        elif suffix == \".json\":\n            format = \"json\"\n        else:\n            format = \"parquet\"  # Default\n\n    # Ensure parent directory exists\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    if format == \"parquet\":\n        _export_parquet(results, path, include_metadata)\n    elif format == \"csv\":\n        _export_csv(results, path)\n    elif format == \"json\":\n        _export_json(results, path, include_metadata)\n    else:\n        raise ValueError(f\"Unknown format: {format}\")\n\n    return path\n</code></pre>"},{"location":"api/io/#usage-examples","title":"Usage Examples","text":""},{"location":"api/io/#loading-configuration","title":"Loading Configuration","text":"<pre><code>from phased_array_systems.io import load_config\n\n# Load from YAML\nconfig = load_config(\"config.yaml\")\n\n# Load from JSON\nconfig = load_config(\"config.json\")\n\n# Access components\narch = config.get_architecture()\nscenario = config.get_scenario()\nrequirements = config.get_requirement_set()\n</code></pre>"},{"location":"api/io/#configuration-schema","title":"Configuration Schema","text":"<pre><code># config.yaml\nname: \"My Trade Study\"\n\narchitecture:\n  array:\n    geometry: rectangular\n    nx: 8\n    ny: 8\n    dx_lambda: 0.5\n    dy_lambda: 0.5\n    scan_limit_deg: 60.0\n  rf:\n    tx_power_w_per_elem: 1.0\n    pa_efficiency: 0.3\n    noise_figure_db: 3.0\n  cost:\n    cost_per_elem_usd: 100.0\n    nre_usd: 10000.0\n\nscenario:\n  type: comms\n  freq_hz: 10.0e9\n  bandwidth_hz: 10.0e6\n  range_m: 100.0e3\n  required_snr_db: 10.0\n\nrequirements:\n  - id: REQ-001\n    name: Minimum EIRP\n    metric_key: eirp_dbw\n    op: \"&gt;=\"\n    value: 40.0\n    severity: must\n\ndesign_space:\n  variables:\n    - name: array.nx\n      type: categorical\n      values: [4, 8, 16]\n    - name: rf.tx_power_w_per_elem\n      type: float\n      low: 0.5\n      high: 3.0\n</code></pre>"},{"location":"api/io/#exporting-results","title":"Exporting Results","text":"<pre><code>from phased_array_systems.io import export_results\nimport pandas as pd\n\n# Export to Parquet (recommended for large datasets)\nexport_results(results, \"results.parquet\")\n\n# Export to CSV\nexport_results(results, \"results.csv\", format=\"csv\")\n\n# Loading back\nresults_loaded = pd.read_parquet(\"results.parquet\")\n</code></pre>"},{"location":"api/io/#format-options","title":"Format Options","text":"Format Extension Best For Parquet <code>.parquet</code> Large datasets, fast I/O CSV <code>.csv</code> Human-readable, Excel"},{"location":"api/io/#parquet-benefits","title":"Parquet Benefits","text":"<ul> <li>Compressed storage</li> <li>Faster read/write</li> <li>Preserves data types</li> <li>Column-oriented (efficient for analysis)</li> </ul> <pre><code># Parquet is ~5x smaller and ~10x faster for typical results\nexport_results(results, \"results.parquet\")  # Recommended\n\n# CSV for compatibility\nexport_results(results, \"results.csv\", format=\"csv\")\n</code></pre>"},{"location":"api/io/#config-object","title":"Config Object","text":""},{"location":"api/io/#phased_array_systems.io.schema.StudyConfig","title":"StudyConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Top-level configuration for a study.</p> <p>Supports both single-case evaluation and DOE trade studies.</p> Example YAML <pre><code>name: \"Comms Array Study\"\narchitecture:\n  array:\n    nx: 8\n    ny: 8\n    dx_lambda: 0.5\n  rf:\n    tx_power_w_per_elem: 1.0\nscenario:\n  type: comms\n  freq_hz: 10e9\n  bandwidth_hz: 10e6\n  range_m: 100e3\n  required_snr_db: 10.0\nrequirements:\n  - id: REQ-001\n    name: Minimum EIRP\n    metric_key: eirp_dbw\n    op: \"&gt;=\"\n    value: 40.0\n</code></pre>"},{"location":"api/io/#phased_array_systems.io.schema.StudyConfig.get_architecture","title":"get_architecture","text":"<pre><code>get_architecture() -&gt; Architecture\n</code></pre> <p>Get the Architecture object, building from shorthand if needed.</p> Source code in <code>src/phased_array_systems/io/schema.py</code> <pre><code>def get_architecture(self) -&gt; Architecture:\n    \"\"\"Get the Architecture object, building from shorthand if needed.\"\"\"\n    if self.architecture is not None:\n        return self.architecture\n\n    # Build from shorthand configs\n    array = self.array or ArrayConfig(nx=8, ny=8)\n    rf = self.rf or RFChainConfig(tx_power_w_per_elem=1.0)\n    cost = self.cost or CostConfig()\n\n    return Architecture(array=array, rf=rf, cost=cost, name=self.name)\n</code></pre>"},{"location":"api/io/#phased_array_systems.io.schema.StudyConfig.get_scenario","title":"get_scenario","text":"<pre><code>get_scenario() -&gt; CommsLinkScenario | RadarDetectionScenario | None\n</code></pre> <p>Get the Scenario object from config.</p> Source code in <code>src/phased_array_systems/io/schema.py</code> <pre><code>def get_scenario(self) -&gt; CommsLinkScenario | RadarDetectionScenario | None:\n    \"\"\"Get the Scenario object from config.\"\"\"\n    if self.scenario is None:\n        return None\n\n    scenario_dict = self.scenario.copy()\n    scenario_type = scenario_dict.pop(\"type\", \"comms\")\n\n    if scenario_type == \"comms\":\n        return CommsLinkScenario(**scenario_dict)\n    elif scenario_type == \"radar\":\n        return RadarDetectionScenario(**scenario_dict)\n    else:\n        raise ValueError(f\"Unknown scenario type: {scenario_type}\")\n</code></pre>"},{"location":"api/io/#phased_array_systems.io.schema.StudyConfig.get_requirement_set","title":"get_requirement_set","text":"<pre><code>get_requirement_set() -&gt; RequirementSet\n</code></pre> <p>Get RequirementSet from config.</p> Source code in <code>src/phased_array_systems/io/schema.py</code> <pre><code>def get_requirement_set(self) -&gt; RequirementSet:\n    \"\"\"Get RequirementSet from config.\"\"\"\n    req_set = RequirementSet(name=f\"{self.name} Requirements\")\n    for req_config in self.requirements:\n        req_set.add(req_config.to_requirement())\n    return req_set\n</code></pre>"},{"location":"api/io/#yaml-schema-reference","title":"YAML Schema Reference","text":""},{"location":"api/io/#architecture-section","title":"Architecture Section","text":"<pre><code>architecture:\n  array:\n    geometry: rectangular  # rectangular, circular, triangular\n    nx: 8                  # Required\n    ny: 8                  # Required\n    dx_lambda: 0.5         # Default: 0.5\n    dy_lambda: 0.5         # Default: 0.5\n    scan_limit_deg: 60.0   # Default: 60.0\n    max_subarray_nx: 8     # Default: 8\n    max_subarray_ny: 8     # Default: 8\n    enforce_subarray_constraint: true  # Default: true\n\n  rf:\n    tx_power_w_per_elem: 1.0  # Required\n    pa_efficiency: 0.3        # Default: 0.3\n    noise_figure_db: 3.0      # Default: 3.0\n    n_tx_beams: 1             # Default: 1\n    feed_loss_db: 1.0         # Default: 1.0\n    system_loss_db: 0.0       # Default: 0.0\n\n  cost:\n    cost_per_elem_usd: 100.0     # Default: 100.0\n    nre_usd: 0.0                 # Default: 0.0\n    integration_cost_usd: 0.0    # Default: 0.0\n</code></pre>"},{"location":"api/io/#scenario-section","title":"Scenario Section","text":"<pre><code># Communications scenario\nscenario:\n  type: comms\n  freq_hz: 10.0e9          # Required\n  bandwidth_hz: 10.0e6     # Required\n  range_m: 100.0e3         # Required\n  required_snr_db: 10.0    # Required\n  scan_angle_deg: 0.0      # Default: 0.0\n  rx_antenna_gain_db: 0.0  # Default: None (isotropic)\n  rx_noise_temp_k: 290.0   # Default: 290.0\n  atmospheric_loss_db: 0.0 # Default: 0.0\n  rain_loss_db: 0.0        # Default: 0.0\n\n# Radar scenario\nscenario:\n  type: radar\n  freq_hz: 10.0e9          # Required\n  target_rcs_m2: 1.0       # Required\n  range_m: 100.0e3         # Required\n  required_pd: 0.9         # Default: 0.9\n  pfa: 1.0e-6              # Default: 1e-6\n  pulse_width_s: 10.0e-6   # Required\n  prf_hz: 1000             # Required\n  n_pulses: 1              # Default: 1\n  integration_type: coherent  # Default: coherent\n  swerling_model: 1        # Default: 1\n</code></pre>"},{"location":"api/io/#requirements-section","title":"Requirements Section","text":"<pre><code>requirements:\n  - id: REQ-001\n    name: Minimum EIRP\n    metric_key: eirp_dbw\n    op: \"&gt;=\"\n    value: 40.0\n    units: dBW             # Optional\n    severity: must         # must, should, nice\n\n  - id: REQ-002\n    name: Maximum Cost\n    metric_key: cost_usd\n    op: \"&lt;=\"\n    value: 50000.0\n    severity: must\n</code></pre>"},{"location":"api/io/#design-space-section","title":"Design Space Section","text":"<pre><code>design_space:\n  variables:\n    # Categorical\n    - name: array.nx\n      type: categorical\n      values: [4, 8, 16]\n\n    # Integer range\n    - name: array.ny\n      type: int\n      low: 4\n      high: 16\n\n    # Float range\n    - name: rf.tx_power_w_per_elem\n      type: float\n      low: 0.5\n      high: 3.0\n\n    # Fixed value (low == high)\n    - name: array.dx_lambda\n      type: float\n      low: 0.5\n      high: 0.5\n</code></pre>"},{"location":"api/io/#see-also","title":"See Also","text":"<ul> <li>User Guide: Trade Studies</li> <li>CLI Reference</li> </ul>"},{"location":"api/reports/","title":"Reports API","text":"<p>HTML and Markdown report generation.</p>"},{"location":"api/reports/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.reports import (\n    ReportConfig,\n    HTMLReport,\n    MarkdownReport,\n)\n</code></pre>"},{"location":"api/reports/#classes","title":"Classes","text":""},{"location":"api/reports/#phased_array_systems.reports.generator.ReportConfig","title":"ReportConfig  <code>dataclass</code>","text":"<pre><code>ReportConfig(title: str = 'Trade Study Report', description: str | None = None, author: str | None = None, include_summary: bool = True, include_pareto: bool = True, include_plots: bool = True, max_rows: int = 50, objectives: list[tuple[str, str]] = list(), key_metrics: list[str] = list())\n</code></pre> <p>Configuration for report generation.</p> ATTRIBUTE DESCRIPTION <code>title</code> <p>Report title</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Optional report description</p> <p> TYPE: <code>str | None</code> </p> <code>author</code> <p>Optional author name</p> <p> TYPE: <code>str | None</code> </p> <code>include_summary</code> <p>Include summary statistics section</p> <p> TYPE: <code>bool</code> </p> <code>include_pareto</code> <p>Include Pareto frontier analysis</p> <p> TYPE: <code>bool</code> </p> <code>include_plots</code> <p>Include visualization plots</p> <p> TYPE: <code>bool</code> </p> <code>max_rows</code> <p>Maximum rows to show in tables (0 = all)</p> <p> TYPE: <code>int</code> </p> <code>objectives</code> <p>List of (metric, direction) for Pareto analysis</p> <p> TYPE: <code>list[tuple[str, str]]</code> </p> <code>key_metrics</code> <p>Metrics to highlight in summary</p> <p> TYPE: <code>list[str]</code> </p>"},{"location":"api/reports/#phased_array_systems.reports.html.HTMLReport","title":"HTMLReport","text":"<pre><code>HTMLReport(config: ReportConfig | None = None)\n</code></pre> <p>               Bases: <code>ReportGenerator</code></p> <p>Generate HTML reports from trade study results.</p> <p>Initialize the HTML report generator.</p> PARAMETER DESCRIPTION <code>config</code> <p>Report configuration</p> <p> TYPE: <code>ReportConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/phased_array_systems/reports/html.py</code> <pre><code>def __init__(self, config: ReportConfig | None = None):\n    \"\"\"Initialize the HTML report generator.\n\n    Args:\n        config: Report configuration\n    \"\"\"\n    super().__init__(config)\n</code></pre>"},{"location":"api/reports/#phased_array_systems.reports.html.HTMLReport.generate","title":"generate","text":"<pre><code>generate(results: DataFrame) -&gt; str\n</code></pre> <p>Generate HTML report content.</p> PARAMETER DESCRIPTION <code>results</code> <p>DataFrame with trade study results</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Complete HTML document as string</p> Source code in <code>src/phased_array_systems/reports/html.py</code> <pre><code>def generate(self, results: pd.DataFrame) -&gt; str:\n    \"\"\"Generate HTML report content.\n\n    Args:\n        results: DataFrame with trade study results\n\n    Returns:\n        Complete HTML document as string\n    \"\"\"\n    metadata = self._get_metadata()\n    stats = self._compute_summary_stats(results)\n    columns = self._identify_columns(results)\n\n    sections = []\n\n    # Summary section\n    if self.config.include_summary:\n        sections.append(self._generate_summary_section(stats, columns))\n\n    # Results table section\n    sections.append(self._generate_table_section(results, columns))\n\n    # Statistics section\n    sections.append(self._generate_statistics_section(results, columns))\n\n    return self._wrap_html(sections, metadata)\n</code></pre>"},{"location":"api/reports/#phased_array_systems.reports.markdown.MarkdownReport","title":"MarkdownReport","text":"<pre><code>MarkdownReport(config: ReportConfig | None = None)\n</code></pre> <p>               Bases: <code>ReportGenerator</code></p> <p>Generate Markdown reports from trade study results.</p> <p>Initialize the Markdown report generator.</p> PARAMETER DESCRIPTION <code>config</code> <p>Report configuration</p> <p> TYPE: <code>ReportConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/phased_array_systems/reports/markdown.py</code> <pre><code>def __init__(self, config: ReportConfig | None = None):\n    \"\"\"Initialize the Markdown report generator.\n\n    Args:\n        config: Report configuration\n    \"\"\"\n    super().__init__(config)\n</code></pre>"},{"location":"api/reports/#phased_array_systems.reports.markdown.MarkdownReport.generate","title":"generate","text":"<pre><code>generate(results: DataFrame) -&gt; str\n</code></pre> <p>Generate Markdown report content.</p> PARAMETER DESCRIPTION <code>results</code> <p>DataFrame with trade study results</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Markdown document as string</p> Source code in <code>src/phased_array_systems/reports/markdown.py</code> <pre><code>def generate(self, results: pd.DataFrame) -&gt; str:\n    \"\"\"Generate Markdown report content.\n\n    Args:\n        results: DataFrame with trade study results\n\n    Returns:\n        Markdown document as string\n    \"\"\"\n    metadata = self._get_metadata()\n    stats = self._compute_summary_stats(results)\n    columns = self._identify_columns(results)\n\n    sections = []\n\n    # Title and metadata\n    sections.append(self._generate_header(metadata))\n\n    # Summary section\n    if self.config.include_summary:\n        sections.append(self._generate_summary_section(stats, columns))\n\n    # Results table section\n    sections.append(self._generate_table_section(results, columns))\n\n    # Statistics section\n    sections.append(self._generate_statistics_section(results, columns))\n\n    # Footer\n    sections.append(self._generate_footer(metadata))\n\n    return \"\\n\\n\".join(sections)\n</code></pre>"},{"location":"api/reports/#usage-examples","title":"Usage Examples","text":""},{"location":"api/reports/#html-report","title":"HTML Report","text":"<pre><code>from phased_array_systems.reports import HTMLReport, ReportConfig\nimport pandas as pd\n\n# Load results\nresults = pd.read_parquet(\"results.parquet\")\n\n# Configure report\nconfig = ReportConfig(\n    title=\"Communications Array Trade Study\",\n    description=\"Analysis of array configurations for X-band link\",\n    author=\"Engineering Team\",\n    version=\"1.0\",\n)\n\n# Generate and save\nreport = HTMLReport(config)\ncontent = report.generate(results)\nreport.save(content, \"report.html\")\n</code></pre>"},{"location":"api/reports/#markdown-report","title":"Markdown Report","text":"<pre><code>from phased_array_systems.reports import MarkdownReport, ReportConfig\n\nconfig = ReportConfig(title=\"Trade Study Summary\")\nreport = MarkdownReport(config)\ncontent = report.generate(results)\nreport.save(content, \"report.md\")\n</code></pre>"},{"location":"api/reports/#report-configuration","title":"Report Configuration","text":"<pre><code>config = ReportConfig(\n    title=\"Q4 Array Trade Study\",\n    description=\"\"\"\n    Systematic exploration of phased array configurations\n    for 100 km X-band communications link.\n    \"\"\",\n    author=\"RF Engineering\",\n    version=\"2.1\",\n)\n</code></pre>"},{"location":"api/reports/#report-contents","title":"Report Contents","text":"<p>Reports automatically include:</p>"},{"location":"api/reports/#executive-summary","title":"Executive Summary","text":"<ul> <li>Total cases evaluated</li> <li>Feasible design count and percentage</li> <li>Pareto-optimal design count</li> <li>Key metric statistics</li> </ul>"},{"location":"api/reports/#requirements-verification","title":"Requirements Verification","text":"<ul> <li>Pass/fail summary by requirement</li> <li>Overall compliance rate</li> <li>Margin statistics</li> </ul>"},{"location":"api/reports/#top-designs","title":"Top Designs","text":"<ul> <li>Ranked Pareto-optimal designs</li> <li>Key metrics for each design</li> <li>Configuration parameters</li> </ul>"},{"location":"api/reports/#statistics","title":"Statistics","text":"<ul> <li>Metric distributions (min, max, mean, std)</li> <li>Variable ranges</li> <li>Correlation highlights</li> </ul>"},{"location":"api/reports/#customization","title":"Customization","text":""},{"location":"api/reports/#extending-reports","title":"Extending Reports","text":"<pre><code>class CustomHTMLReport(HTMLReport):\n    def generate(self, results):\n        html = super().generate(results)\n\n        # Add custom section\n        custom = \"&lt;section&gt;&lt;h2&gt;Custom Analysis&lt;/h2&gt;...&lt;/section&gt;\"\n        html = html.replace(\"&lt;/body&gt;\", f\"{custom}&lt;/body&gt;\")\n\n        return html\n</code></pre>"},{"location":"api/reports/#adding-figures","title":"Adding Figures","text":"<pre><code>import base64\nfrom io import BytesIO\n\n# Generate figure\nfig = pareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\")\n\n# Convert to base64\nbuffer = BytesIO()\nfig.savefig(buffer, format='png', dpi=150)\nbuffer.seek(0)\nimg_data = base64.b64encode(buffer.getvalue()).decode()\n\n# Embed in HTML\nimg_html = f'&lt;img src=\"data:image/png;base64,{img_data}\" alt=\"Pareto\"&gt;'\n</code></pre>"},{"location":"api/reports/#cli-usage","title":"CLI Usage","text":"<pre><code># HTML report (default)\npasys report results.parquet -o report.html\n\n# Markdown report\npasys report results.parquet --format markdown -o report.md\n\n# With title\npasys report results.parquet --title \"Q4 Analysis\"\n</code></pre>"},{"location":"api/reports/#see-also","title":"See Also","text":"<ul> <li>User Guide: Reports</li> <li>CLI: report</li> <li>Visualization API</li> </ul>"},{"location":"api/requirements/","title":"Requirements API","text":"<p>Requirements definition and verification classes.</p>"},{"location":"api/requirements/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.requirements import (\n    Requirement,\n    RequirementResult,\n    RequirementSet,\n    VerificationReport,\n)\n</code></pre>"},{"location":"api/requirements/#classes","title":"Classes","text":""},{"location":"api/requirements/#phased_array_systems.requirements.core.Requirement","title":"Requirement  <code>dataclass</code>","text":"<pre><code>Requirement(id: str, name: str, metric_key: str, op: ComparisonOp, value: float, units: str | None = None, severity: Severity = 'must')\n</code></pre> <p>A single requirement specification.</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>Unique identifier for the requirement (e.g., \"REQ-001\")</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Human-readable name</p> <p> TYPE: <code>str</code> </p> <code>metric_key</code> <p>The key in the metrics dictionary to check</p> <p> TYPE: <code>str</code> </p> <code>op</code> <p>Comparison operator</p> <p> TYPE: <code>ComparisonOp</code> </p> <code>value</code> <p>Threshold value to compare against</p> <p> TYPE: <code>float</code> </p> <code>units</code> <p>Optional units string for documentation</p> <p> TYPE: <code>str | None</code> </p> <code>severity</code> <p>Importance level (\"must\", \"should\", \"nice\")</p> <p> TYPE: <code>Severity</code> </p>"},{"location":"api/requirements/#phased_array_systems.requirements.core.Requirement.check","title":"check","text":"<pre><code>check(actual_value: float) -&gt; bool\n</code></pre> <p>Check if the actual value satisfies this requirement.</p> PARAMETER DESCRIPTION <code>actual_value</code> <p>The measured/computed value to check</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if requirement is satisfied, False otherwise</p> Source code in <code>src/phased_array_systems/requirements/core.py</code> <pre><code>def check(self, actual_value: float) -&gt; bool:\n    \"\"\"Check if the actual value satisfies this requirement.\n\n    Args:\n        actual_value: The measured/computed value to check\n\n    Returns:\n        True if requirement is satisfied, False otherwise\n    \"\"\"\n    if self.op == \"&gt;=\":\n        return actual_value &gt;= self.value\n    elif self.op == \"&lt;=\":\n        return actual_value &lt;= self.value\n    elif self.op == \"==\":\n        return actual_value == self.value\n    elif self.op == \"&gt;\":\n        return actual_value &gt; self.value\n    elif self.op == \"&lt;\":\n        return actual_value &lt; self.value\n    else:\n        raise ValueError(f\"Unknown operator: {self.op}\")\n</code></pre>"},{"location":"api/requirements/#phased_array_systems.requirements.core.Requirement.compute_margin","title":"compute_margin","text":"<pre><code>compute_margin(actual_value: float) -&gt; float\n</code></pre> <p>Compute the margin to the requirement threshold.</p> <p>Positive margin means the requirement is satisfied with room to spare. Negative margin means the requirement is not met.</p> PARAMETER DESCRIPTION <code>actual_value</code> <p>The measured/computed value</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Margin value (interpretation depends on operator)</p> Source code in <code>src/phased_array_systems/requirements/core.py</code> <pre><code>def compute_margin(self, actual_value: float) -&gt; float:\n    \"\"\"Compute the margin to the requirement threshold.\n\n    Positive margin means the requirement is satisfied with room to spare.\n    Negative margin means the requirement is not met.\n\n    Args:\n        actual_value: The measured/computed value\n\n    Returns:\n        Margin value (interpretation depends on operator)\n    \"\"\"\n    if self.op in (\"&gt;=\", \"&gt;\"):\n        return actual_value - self.value\n    elif self.op in (\"&lt;=\", \"&lt;\"):\n        return self.value - actual_value\n    else:  # ==\n        return -abs(actual_value - self.value)\n</code></pre>"},{"location":"api/requirements/#phased_array_systems.requirements.core.RequirementResult","title":"RequirementResult  <code>dataclass</code>","text":"<pre><code>RequirementResult(requirement: Requirement, actual_value: float | None, passes: bool, margin: float | None, error: str | None = None)\n</code></pre> <p>Result of checking a single requirement.</p> ATTRIBUTE DESCRIPTION <code>requirement</code> <p>The requirement that was checked</p> <p> TYPE: <code>Requirement</code> </p> <code>actual_value</code> <p>The actual value from metrics (None if metric missing)</p> <p> TYPE: <code>float | None</code> </p> <code>passes</code> <p>Whether the requirement passed</p> <p> TYPE: <code>bool</code> </p> <code>margin</code> <p>Margin to the threshold</p> <p> TYPE: <code>float | None</code> </p> <code>error</code> <p>Error message if metric was missing or check failed</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"api/requirements/#phased_array_systems.requirements.core.RequirementSet","title":"RequirementSet  <code>dataclass</code>","text":"<pre><code>RequirementSet(requirements: list[Requirement] = list(), name: str | None = None)\n</code></pre> <p>A collection of requirements with verification capabilities.</p> ATTRIBUTE DESCRIPTION <code>requirements</code> <p>List of requirements</p> <p> TYPE: <code>list[Requirement]</code> </p> <code>name</code> <p>Optional name for the requirement set</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"api/requirements/#phased_array_systems.requirements.core.RequirementSet.add","title":"add","text":"<pre><code>add(requirement: Requirement) -&gt; None\n</code></pre> <p>Add a requirement to the set.</p> Source code in <code>src/phased_array_systems/requirements/core.py</code> <pre><code>def add(self, requirement: Requirement) -&gt; None:\n    \"\"\"Add a requirement to the set.\"\"\"\n    self.requirements.append(requirement)\n</code></pre>"},{"location":"api/requirements/#phased_array_systems.requirements.core.RequirementSet.verify","title":"verify","text":"<pre><code>verify(metrics: MetricsDict) -&gt; VerificationReport\n</code></pre> <p>Verify all requirements against provided metrics.</p> PARAMETER DESCRIPTION <code>metrics</code> <p>Dictionary of metric_name -&gt; value</p> <p> TYPE: <code>MetricsDict</code> </p> RETURNS DESCRIPTION <code>VerificationReport</code> <p>VerificationReport with pass/fail status and margins</p> Source code in <code>src/phased_array_systems/requirements/core.py</code> <pre><code>def verify(self, metrics: MetricsDict) -&gt; VerificationReport:\n    \"\"\"Verify all requirements against provided metrics.\n\n    Args:\n        metrics: Dictionary of metric_name -&gt; value\n\n    Returns:\n        VerificationReport with pass/fail status and margins\n    \"\"\"\n    results: list[RequirementResult] = []\n    failed_ids: list[str] = []\n    must_pass = 0\n    must_total = 0\n    should_pass = 0\n    should_total = 0\n\n    for req in self.requirements:\n        # Track totals by severity\n        if req.severity == \"must\":\n            must_total += 1\n        elif req.severity == \"should\":\n            should_total += 1\n\n        # Check if metric exists\n        if req.metric_key not in metrics:\n            result = RequirementResult(\n                requirement=req,\n                actual_value=None,\n                passes=False,\n                margin=None,\n                error=f\"Metric '{req.metric_key}' not found in results\",\n            )\n            failed_ids.append(req.id)\n        else:\n            actual = metrics[req.metric_key]\n            if actual is None or not isinstance(actual, (int, float)):\n                result = RequirementResult(\n                    requirement=req,\n                    actual_value=None,\n                    passes=False,\n                    margin=None,\n                    error=f\"Metric '{req.metric_key}' has invalid value: {actual}\",\n                )\n                failed_ids.append(req.id)\n            else:\n                actual_float = float(actual)\n                passes = req.check(actual_float)\n                margin = req.compute_margin(actual_float)\n                result = RequirementResult(\n                    requirement=req,\n                    actual_value=actual_float,\n                    passes=passes,\n                    margin=margin,\n                )\n                if not passes:\n                    failed_ids.append(req.id)\n                else:\n                    if req.severity == \"must\":\n                        must_pass += 1\n                    elif req.severity == \"should\":\n                        should_pass += 1\n\n        results.append(result)\n\n    # Overall pass requires all \"must\" requirements to pass\n    all_must_pass = must_pass == must_total\n\n    return VerificationReport(\n        passes=all_must_pass,\n        results=results,\n        failed_ids=failed_ids,\n        must_pass_count=must_pass,\n        must_total_count=must_total,\n        should_pass_count=should_pass,\n        should_total_count=should_total,\n    )\n</code></pre>"},{"location":"api/requirements/#phased_array_systems.requirements.core.RequirementSet.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(req_id: str) -&gt; Requirement | None\n</code></pre> <p>Get a requirement by its ID.</p> Source code in <code>src/phased_array_systems/requirements/core.py</code> <pre><code>def get_by_id(self, req_id: str) -&gt; Requirement | None:\n    \"\"\"Get a requirement by its ID.\"\"\"\n    for req in self.requirements:\n        if req.id == req_id:\n            return req\n    return None\n</code></pre>"},{"location":"api/requirements/#phased_array_systems.requirements.core.VerificationReport","title":"VerificationReport  <code>dataclass</code>","text":"<pre><code>VerificationReport(passes: bool, results: list[RequirementResult], failed_ids: list[str], must_pass_count: int = 0, must_total_count: int = 0, should_pass_count: int = 0, should_total_count: int = 0)\n</code></pre> <p>Complete verification report for a set of requirements.</p> ATTRIBUTE DESCRIPTION <code>passes</code> <p>True if ALL 'must' requirements pass</p> <p> TYPE: <code>bool</code> </p> <code>results</code> <p>List of individual requirement results</p> <p> TYPE: <code>list[RequirementResult]</code> </p> <code>failed_ids</code> <p>List of requirement IDs that failed</p> <p> TYPE: <code>list[str]</code> </p> <code>must_pass_count</code> <p>Number of must requirements that passed</p> <p> TYPE: <code>int</code> </p> <code>must_total_count</code> <p>Total number of must requirements</p> <p> TYPE: <code>int</code> </p> <code>should_pass_count</code> <p>Number of should requirements that passed</p> <p> TYPE: <code>int</code> </p> <code>should_total_count</code> <p>Total number of should requirements</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/requirements/#phased_array_systems.requirements.core.VerificationReport.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert report to dictionary for serialization.</p> Source code in <code>src/phased_array_systems/requirements/core.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert report to dictionary for serialization.\"\"\"\n    return {\n        \"passes\": self.passes,\n        \"failed_ids\": self.failed_ids,\n        \"must_pass_count\": self.must_pass_count,\n        \"must_total_count\": self.must_total_count,\n        \"should_pass_count\": self.should_pass_count,\n        \"should_total_count\": self.should_total_count,\n        \"results\": [\n            {\n                \"id\": r.requirement.id,\n                \"name\": r.requirement.name,\n                \"metric_key\": r.requirement.metric_key,\n                \"threshold\": r.requirement.value,\n                \"operator\": r.requirement.op,\n                \"actual_value\": r.actual_value,\n                \"passes\": r.passes,\n                \"margin\": r.margin,\n                \"severity\": r.requirement.severity,\n                \"error\": r.error,\n            }\n            for r in self.results\n        ],\n    }\n</code></pre>"},{"location":"api/requirements/#usage-examples","title":"Usage Examples","text":""},{"location":"api/requirements/#defining-requirements","title":"Defining Requirements","text":"<pre><code>from phased_array_systems.requirements import Requirement, RequirementSet\n\n# Create individual requirements\nreq1 = Requirement(\n    id=\"REQ-001\",\n    name=\"Minimum EIRP\",\n    metric_key=\"eirp_dbw\",\n    op=\"&gt;=\",\n    value=40.0,\n    units=\"dBW\",\n    severity=\"must\",\n)\n\nreq2 = Requirement(\n    id=\"REQ-002\",\n    name=\"Positive Link Margin\",\n    metric_key=\"link_margin_db\",\n    op=\"&gt;=\",\n    value=0.0,\n    severity=\"must\",\n)\n\n# Create requirement set\nrequirements = RequirementSet(\n    requirements=[req1, req2],\n    name=\"Communications Requirements\",\n)\n</code></pre>"},{"location":"api/requirements/#verifying-requirements","title":"Verifying Requirements","text":"<pre><code>from phased_array_systems.evaluate import evaluate_case\n\nmetrics = evaluate_case(arch, scenario)\nreport = requirements.verify(metrics)\n\n# Check overall status\nprint(f\"Overall: {'PASS' if report.passes else 'FAIL'}\")\nprint(f\"Must: {report.must_pass_count}/{report.must_total_count}\")\n\n# Check individual requirements\nfor result in report.results:\n    status = \"PASS\" if result.passes else \"FAIL\"\n    print(f\"{result.requirement.id}: {status} (margin: {result.margin:.1f})\")\n</code></pre>"},{"location":"api/requirements/#checking-individual-requirements","title":"Checking Individual Requirements","text":"<pre><code>req = Requirement(\"TEST\", \"Test\", \"value\", \"&gt;=\", 10.0)\n\n# Check if value passes\nprint(req.check(15.0))  # True\nprint(req.check(5.0))   # False\n\n# Compute margin\nprint(req.compute_margin(15.0))  # 5.0\nprint(req.compute_margin(5.0))   # -5.0\n</code></pre>"},{"location":"api/requirements/#serializing-reports","title":"Serializing Reports","text":"<pre><code>report = requirements.verify(metrics)\nreport_dict = report.to_dict()\n\n# Contains structured verification data\nimport json\nprint(json.dumps(report_dict, indent=2))\n</code></pre>"},{"location":"api/requirements/#type-aliases","title":"Type Aliases","text":"<pre><code>from phased_array_systems.types import ComparisonOp, Severity\n\n# ComparisonOp = Literal[\"&gt;=\", \"&lt;=\", \"&gt;\", \"&lt;\", \"==\"]\n# Severity = Literal[\"must\", \"should\", \"nice\"]\n</code></pre>"},{"location":"api/requirements/#see-also","title":"See Also","text":"<ul> <li>User Guide: Requirements</li> <li>Architecture API</li> <li>Trades API</li> </ul>"},{"location":"api/scenarios/","title":"Scenarios API","text":"<p>Scenario classes for defining operating conditions.</p>"},{"location":"api/scenarios/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.scenarios import (\n    ScenarioBase,\n    CommsLinkScenario,\n    RadarDetectionScenario,\n)\n</code></pre>"},{"location":"api/scenarios/#classes","title":"Classes","text":""},{"location":"api/scenarios/#phased_array_systems.scenarios.base.ScenarioBase","title":"ScenarioBase","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all scenario types.</p> <p>All scenarios must have a frequency, which is used to compute wavelength and other frequency-dependent parameters.</p> ATTRIBUTE DESCRIPTION <code>freq_hz</code> <p>Operating frequency in Hz</p> <p> TYPE: <code>float</code> </p> <code>name</code> <p>Optional name for the scenario</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"api/scenarios/#phased_array_systems.scenarios.base.ScenarioBase.wavelength_m","title":"wavelength_m  <code>property</code>","text":"<pre><code>wavelength_m: float\n</code></pre> <p>Wavelength in meters.</p>"},{"location":"api/scenarios/#phased_array_systems.scenarios.base.ScenarioBase.freq_ghz","title":"freq_ghz  <code>property</code>","text":"<pre><code>freq_ghz: float\n</code></pre> <p>Frequency in GHz.</p>"},{"location":"api/scenarios/#phased_array_systems.scenarios.comms.CommsLinkScenario","title":"CommsLinkScenario","text":"<p>               Bases: <code>ScenarioBase</code></p> <p>Scenario for communications link budget analysis.</p> <p>Defines the parameters needed for a point-to-point or satellite communications link budget calculation.</p> ATTRIBUTE DESCRIPTION <code>freq_hz</code> <p>Operating frequency (Hz)</p> <p> TYPE: <code>float</code> </p> <code>bandwidth_hz</code> <p>Signal bandwidth (Hz)</p> <p> TYPE: <code>float</code> </p> <code>range_m</code> <p>Link range/distance (meters)</p> <p> TYPE: <code>float</code> </p> <code>required_snr_db</code> <p>Required SNR for demodulation (dB)</p> <p> TYPE: <code>float</code> </p> <code>scan_angle_deg</code> <p>Beam scan angle from boresight (degrees)</p> <p> TYPE: <code>float</code> </p> <code>rx_antenna_gain_db</code> <p>Receive antenna gain (dB), None for isotropic</p> <p> TYPE: <code>float | None</code> </p> <code>rx_noise_temp_k</code> <p>Receive system noise temperature (K)</p> <p> TYPE: <code>float</code> </p> <code>path_loss_model</code> <p>Propagation model to use</p> <p> TYPE: <code>Literal['fspl']</code> </p> <code>atmospheric_loss_db</code> <p>Additional atmospheric losses (dB)</p> <p> TYPE: <code>float</code> </p> <code>rain_loss_db</code> <p>Rain fade margin (dB)</p> <p> TYPE: <code>float</code> </p> <code>polarization_loss_db</code> <p>Polarization mismatch loss (dB)</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/scenarios/#phased_array_systems.scenarios.comms.CommsLinkScenario.total_extra_loss_db","title":"total_extra_loss_db  <code>property</code>","text":"<pre><code>total_extra_loss_db: float\n</code></pre> <p>Total additional losses beyond free space path loss.</p>"},{"location":"api/scenarios/#phased_array_systems.scenarios.radar.RadarDetectionScenario","title":"RadarDetectionScenario","text":"<p>               Bases: <code>ScenarioBase</code></p> <p>Scenario for radar detection analysis.</p> <p>Defines the operating conditions for monostatic radar detection, including target characteristics, detection requirements, and pulse integration parameters.</p> ATTRIBUTE DESCRIPTION <code>freq_hz</code> <p>Operating frequency (Hz)</p> <p> TYPE: <code>float</code> </p> <code>bandwidth_hz</code> <p>Signal bandwidth (Hz)</p> <p> TYPE: <code>float</code> </p> <code>range_m</code> <p>Target range (meters)</p> <p> TYPE: <code>float</code> </p> <code>target_rcs_dbsm</code> <p>Target radar cross section (dBsm)</p> <p> TYPE: <code>float</code> </p> <code>rx_noise_temp_k</code> <p>Receiver noise temperature (K)</p> <p> TYPE: <code>float</code> </p> <code>pfa</code> <p>Probability of false alarm</p> <p> TYPE: <code>float</code> </p> <code>pd_required</code> <p>Required probability of detection</p> <p> TYPE: <code>float</code> </p> <code>n_pulses</code> <p>Number of pulses integrated</p> <p> TYPE: <code>int</code> </p> <code>scan_angle_deg</code> <p>Beam scan angle from boresight (degrees)</p> <p> TYPE: <code>float</code> </p> <code>integration_type</code> <p>Coherent or non-coherent integration</p> <p> TYPE: <code>Literal['coherent', 'noncoherent']</code> </p>"},{"location":"api/scenarios/#phased_array_systems.scenarios.radar.RadarDetectionScenario.wavelength_m","title":"wavelength_m  <code>property</code>","text":"<pre><code>wavelength_m: float\n</code></pre> <p>Wavelength in meters.</p>"},{"location":"api/scenarios/#phased_array_systems.scenarios.radar.RadarDetectionScenario.target_rcs_m2","title":"target_rcs_m2  <code>property</code>","text":"<pre><code>target_rcs_m2: float\n</code></pre> <p>Target RCS in square meters.</p>"},{"location":"api/scenarios/#usage-examples","title":"Usage Examples","text":""},{"location":"api/scenarios/#communications-scenario","title":"Communications Scenario","text":"<pre><code>from phased_array_systems.scenarios import CommsLinkScenario\n\n# Point-to-point link\nscenario = CommsLinkScenario(\n    freq_hz=10e9,\n    bandwidth_hz=10e6,\n    range_m=100e3,\n    required_snr_db=10.0,\n    scan_angle_deg=0.0,\n    rx_antenna_gain_db=30.0,\n    rx_noise_temp_k=290.0,\n)\n\nprint(f\"Wavelength: {scenario.wavelength_m * 100:.2f} cm\")\nprint(f\"Total extra loss: {scenario.total_extra_loss_db:.1f} dB\")\n</code></pre>"},{"location":"api/scenarios/#radar-scenario","title":"Radar Scenario","text":"<pre><code>from phased_array_systems.scenarios import RadarDetectionScenario\n\nscenario = RadarDetectionScenario(\n    freq_hz=10e9,\n    target_rcs_m2=1.0,\n    range_m=100e3,\n    required_pd=0.9,\n    pfa=1e-6,\n    pulse_width_s=10e-6,\n    prf_hz=1000,\n    n_pulses=10,\n    integration_type=\"coherent\",\n    swerling_model=1,\n)\n</code></pre>"},{"location":"api/scenarios/#satellite-link","title":"Satellite Link","text":"<pre><code>geo_scenario = CommsLinkScenario(\n    freq_hz=12e9,\n    bandwidth_hz=36e6,\n    range_m=36000e3,\n    required_snr_db=8.0,\n    rx_antenna_gain_db=45.0,\n    rx_noise_temp_k=80.0,\n    atmospheric_loss_db=0.3,\n    rain_loss_db=5.0,\n)\n</code></pre>"},{"location":"api/scenarios/#see-also","title":"See Also","text":"<ul> <li>User Guide: Scenarios</li> <li>User Guide: Link Budget</li> <li>User Guide: Radar Detection</li> </ul>"},{"location":"api/trades/","title":"Trades API","text":"<p>Design of Experiments, batch evaluation, and Pareto analysis.</p>"},{"location":"api/trades/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.trades import (\n    # Design Space\n    DesignSpace,\n    DesignVariable,\n\n    # DOE Generation\n    generate_doe,\n\n    # Batch Evaluation\n    BatchRunner,\n\n    # Pareto Analysis\n    filter_feasible,\n    extract_pareto,\n    rank_pareto,\n)\n\n# Additional functions via submodules\nfrom phased_array_systems.trades.doe import generate_doe_from_dict, augment_doe\nfrom phased_array_systems.trades.pareto import compute_hypervolume\n</code></pre>"},{"location":"api/trades/#design-space","title":"Design Space","text":""},{"location":"api/trades/#phased_array_systems.trades.design_space.DesignSpace","title":"DesignSpace","text":"<p>               Bases: <code>BaseModel</code></p> <p>Collection of design variables defining a design space.</p> <p>Provides methods for sampling the design space using various DOE methods (grid, random, LHS).</p> ATTRIBUTE DESCRIPTION <code>variables</code> <p>List of design variables</p> <p> TYPE: <code>list[DesignVariable]</code> </p> <code>name</code> <p>Optional name for the design space</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"api/trades/#phased_array_systems.trades.design_space.DesignSpace.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims: int\n</code></pre> <p>Number of dimensions (variables) in the design space.</p>"},{"location":"api/trades/#phased_array_systems.trades.design_space.DesignSpace.variable_names","title":"variable_names  <code>property</code>","text":"<pre><code>variable_names: list[str]\n</code></pre> <p>List of variable names.</p>"},{"location":"api/trades/#phased_array_systems.trades.design_space.DesignSpace.add_variable","title":"add_variable","text":"<pre><code>add_variable(name: str, type: Literal['int', 'float', 'categorical'] = 'float', low: float | None = None, high: float | None = None, values: list[Any] | None = None) -&gt; DesignSpace\n</code></pre> <p>Add a variable to the design space (fluent interface).</p> PARAMETER DESCRIPTION <code>name</code> <p>Variable name</p> <p> TYPE: <code>str</code> </p> <code>type</code> <p>Variable type</p> <p> TYPE: <code>Literal['int', 'float', 'categorical']</code> DEFAULT: <code>'float'</code> </p> <code>low</code> <p>Lower bound</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>high</code> <p>Upper bound</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>values</code> <p>Categorical values</p> <p> TYPE: <code>list[Any] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DesignSpace</code> <p>Self for chaining</p> Source code in <code>src/phased_array_systems/trades/design_space.py</code> <pre><code>def add_variable(\n    self,\n    name: str,\n    type: Literal[\"int\", \"float\", \"categorical\"] = \"float\",\n    low: float | None = None,\n    high: float | None = None,\n    values: list[Any] | None = None,\n) -&gt; \"DesignSpace\":\n    \"\"\"Add a variable to the design space (fluent interface).\n\n    Args:\n        name: Variable name\n        type: Variable type\n        low: Lower bound\n        high: Upper bound\n        values: Categorical values\n\n    Returns:\n        Self for chaining\n    \"\"\"\n    var = DesignVariable(name=name, type=type, low=low, high=high, values=values)\n    self.variables.append(var)\n    return self\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.design_space.DesignSpace.sample","title":"sample","text":"<pre><code>sample(method: Literal['grid', 'random', 'lhs'] = 'lhs', n_samples: int = 100, seed: int | None = None, grid_levels: int | list[int] | None = None) -&gt; DataFrame\n</code></pre> <p>Sample the design space.</p> PARAMETER DESCRIPTION <code>method</code> <p>Sampling method (\"grid\", \"random\", \"lhs\")</p> <p> TYPE: <code>Literal['grid', 'random', 'lhs']</code> DEFAULT: <code>'lhs'</code> </p> <code>n_samples</code> <p>Number of samples (ignored for grid method)</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>seed</code> <p>Random seed for reproducibility</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>grid_levels</code> <p>Number of levels per variable for grid method</p> <p> TYPE: <code>int | list[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with columns for each variable plus 'case_id'</p> Source code in <code>src/phased_array_systems/trades/design_space.py</code> <pre><code>def sample(\n    self,\n    method: Literal[\"grid\", \"random\", \"lhs\"] = \"lhs\",\n    n_samples: int = 100,\n    seed: int | None = None,\n    grid_levels: int | list[int] | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Sample the design space.\n\n    Args:\n        method: Sampling method (\"grid\", \"random\", \"lhs\")\n        n_samples: Number of samples (ignored for grid method)\n        seed: Random seed for reproducibility\n        grid_levels: Number of levels per variable for grid method\n\n    Returns:\n        DataFrame with columns for each variable plus 'case_id'\n    \"\"\"\n    if method == \"grid\":\n        return self._sample_grid(grid_levels)\n    elif method == \"random\":\n        return self._sample_random(n_samples, seed)\n    elif method == \"lhs\":\n        return self._sample_lhs(n_samples, seed)\n    else:\n        raise ValueError(f\"Unknown sampling method: {method}\")\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.design_space.DesignSpace.get_variable","title":"get_variable","text":"<pre><code>get_variable(name: str) -&gt; DesignVariable | None\n</code></pre> <p>Get a variable by name.</p> Source code in <code>src/phased_array_systems/trades/design_space.py</code> <pre><code>def get_variable(self, name: str) -&gt; DesignVariable | None:\n    \"\"\"Get a variable by name.\"\"\"\n    for var in self.variables:\n        if var.name == name:\n            return var\n    return None\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.design_space.DesignVariable","title":"DesignVariable","text":"<p>               Bases: <code>BaseModel</code></p> <p>Definition of a single design variable.</p> <p>Supports continuous (float), discrete (int), and categorical variables.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Variable name, typically a dot-path like \"array.nx\"</p> <p> TYPE: <code>str</code> </p> <code>type</code> <p>Variable type (\"int\", \"float\", or \"categorical\")</p> <p> TYPE: <code>Literal['int', 'float', 'categorical']</code> </p> <code>low</code> <p>Lower bound for continuous/discrete variables</p> <p> TYPE: <code>float | None</code> </p> <code>high</code> <p>Upper bound for continuous/discrete variables</p> <p> TYPE: <code>float | None</code> </p> <code>values</code> <p>List of allowed values for categorical variables</p> <p> TYPE: <code>list[Any] | None</code> </p>"},{"location":"api/trades/#phased_array_systems.trades.design_space.DesignVariable.validate_bounds_or_values","title":"validate_bounds_or_values","text":"<pre><code>validate_bounds_or_values() -&gt; DesignVariable\n</code></pre> <p>Ensure proper bounds/values are set based on type.</p> Source code in <code>src/phased_array_systems/trades/design_space.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_bounds_or_values(self) -&gt; \"DesignVariable\":\n    \"\"\"Ensure proper bounds/values are set based on type.\"\"\"\n    if self.type in (\"int\", \"float\"):\n        if self.low is None or self.high is None:\n            raise ValueError(f\"Variable '{self.name}': low and high required for {self.type}\")\n        if self.low &gt; self.high:\n            raise ValueError(f\"Variable '{self.name}': low must be &lt;= high\")\n    elif self.type == \"categorical\":\n        if not self.values or len(self.values) &lt; 1:\n            raise ValueError(f\"Variable '{self.name}': values required for categorical\")\n    return self\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.design_space.DesignVariable.sample_uniform","title":"sample_uniform","text":"<pre><code>sample_uniform(n: int, rng: Generator) -&gt; ndarray\n</code></pre> <p>Generate uniform random samples.</p> PARAMETER DESCRIPTION <code>n</code> <p>Number of samples</p> <p> TYPE: <code>int</code> </p> <code>rng</code> <p>NumPy random generator</p> <p> TYPE: <code>Generator</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Array of sampled values</p> Source code in <code>src/phased_array_systems/trades/design_space.py</code> <pre><code>def sample_uniform(self, n: int, rng: np.random.Generator) -&gt; np.ndarray:\n    \"\"\"Generate uniform random samples.\n\n    Args:\n        n: Number of samples\n        rng: NumPy random generator\n\n    Returns:\n        Array of sampled values\n    \"\"\"\n    if self.type == \"float\":\n        return rng.uniform(self.low, self.high, n)\n    elif self.type == \"int\":\n        return rng.integers(int(self.low), int(self.high) + 1, n)\n    else:  # categorical\n        indices = rng.integers(0, len(self.values), n)\n        return np.array([self.values[i] for i in indices])\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.design_space.DesignVariable.scale_from_unit","title":"scale_from_unit","text":"<pre><code>scale_from_unit(unit_values: ndarray) -&gt; ndarray\n</code></pre> <p>Scale values from [0, 1] to actual variable range.</p> PARAMETER DESCRIPTION <code>unit_values</code> <p>Values in [0, 1]</p> <p> TYPE: <code>ndarray</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>Scaled values in variable's actual range</p> Source code in <code>src/phased_array_systems/trades/design_space.py</code> <pre><code>def scale_from_unit(self, unit_values: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Scale values from [0, 1] to actual variable range.\n\n    Args:\n        unit_values: Values in [0, 1]\n\n    Returns:\n        Scaled values in variable's actual range\n    \"\"\"\n    if self.type == \"float\":\n        return self.low + unit_values * (self.high - self.low)\n    elif self.type == \"int\":\n        scaled = self.low + unit_values * (self.high - self.low + 1)\n        return np.floor(scaled).astype(int).clip(int(self.low), int(self.high))\n    else:  # categorical\n        indices = np.floor(unit_values * len(self.values)).astype(int)\n        indices = indices.clip(0, len(self.values) - 1)\n        return np.array([self.values[i] for i in indices])\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.design_space.DesignVariable.get_grid_values","title":"get_grid_values","text":"<pre><code>get_grid_values(n_levels: int) -&gt; list[Any]\n</code></pre> <p>Get grid values for this variable.</p> PARAMETER DESCRIPTION <code>n_levels</code> <p>Number of levels for grid</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>list[Any]</code> <p>List of values at each level</p> Source code in <code>src/phased_array_systems/trades/design_space.py</code> <pre><code>def get_grid_values(self, n_levels: int) -&gt; list[Any]:\n    \"\"\"Get grid values for this variable.\n\n    Args:\n        n_levels: Number of levels for grid\n\n    Returns:\n        List of values at each level\n    \"\"\"\n    if self.type == \"float\":\n        return list(np.linspace(self.low, self.high, n_levels))\n    elif self.type == \"int\":\n        # For integers, use actual integer values\n        all_ints = list(range(int(self.low), int(self.high) + 1))\n        if len(all_ints) &lt;= n_levels:\n            return all_ints\n        # Subsample evenly\n        indices = np.linspace(0, len(all_ints) - 1, n_levels).astype(int)\n        return [all_ints[i] for i in indices]\n    else:  # categorical\n        return list(self.values)\n</code></pre>"},{"location":"api/trades/#doe-generation","title":"DOE Generation","text":""},{"location":"api/trades/#phased_array_systems.trades.doe.generate_doe","title":"generate_doe","text":"<pre><code>generate_doe(design_space: DesignSpace, method: Literal['grid', 'random', 'lhs'] = 'lhs', n_samples: int = 100, seed: int | None = None, grid_levels: int | list[int] | None = None) -&gt; DataFrame\n</code></pre> <p>Generate a Design of Experiments from a design space.</p> <p>This is a convenience function that wraps DesignSpace.sample().</p> PARAMETER DESCRIPTION <code>design_space</code> <p>DesignSpace defining the variables and bounds</p> <p> TYPE: <code>DesignSpace</code> </p> <code>method</code> <p>Sampling method - \"grid\": Full factorial grid (n_samples ignored) - \"random\": Uniform random sampling - \"lhs\": Latin Hypercube Sampling (space-filling)</p> <p> TYPE: <code>Literal['grid', 'random', 'lhs']</code> DEFAULT: <code>'lhs'</code> </p> <code>n_samples</code> <p>Number of samples (for random/lhs methods)</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>seed</code> <p>Random seed for reproducibility</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>grid_levels</code> <p>Number of levels per variable for grid method</p> <p> TYPE: <code>int | list[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with columns: - case_id: Unique identifier for each case - One column per design variable</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; space = DesignSpace()\n&gt;&gt;&gt; space.add_variable(\"array.nx\", \"int\", low=4, high=16)\n&gt;&gt;&gt; space.add_variable(\"array.ny\", \"int\", low=4, high=16)\n&gt;&gt;&gt; space.add_variable(\"rf.tx_power_w_per_elem\", \"float\", low=0.5, high=2.0)\n&gt;&gt;&gt; doe = generate_doe(space, method=\"lhs\", n_samples=50, seed=42)\n</code></pre> Source code in <code>src/phased_array_systems/trades/doe.py</code> <pre><code>def generate_doe(\n    design_space: DesignSpace,\n    method: Literal[\"grid\", \"random\", \"lhs\"] = \"lhs\",\n    n_samples: int = 100,\n    seed: int | None = None,\n    grid_levels: int | list[int] | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Generate a Design of Experiments from a design space.\n\n    This is a convenience function that wraps DesignSpace.sample().\n\n    Args:\n        design_space: DesignSpace defining the variables and bounds\n        method: Sampling method\n            - \"grid\": Full factorial grid (n_samples ignored)\n            - \"random\": Uniform random sampling\n            - \"lhs\": Latin Hypercube Sampling (space-filling)\n        n_samples: Number of samples (for random/lhs methods)\n        seed: Random seed for reproducibility\n        grid_levels: Number of levels per variable for grid method\n\n    Returns:\n        DataFrame with columns:\n            - case_id: Unique identifier for each case\n            - One column per design variable\n\n    Examples:\n        &gt;&gt;&gt; space = DesignSpace()\n        &gt;&gt;&gt; space.add_variable(\"array.nx\", \"int\", low=4, high=16)\n        &gt;&gt;&gt; space.add_variable(\"array.ny\", \"int\", low=4, high=16)\n        &gt;&gt;&gt; space.add_variable(\"rf.tx_power_w_per_elem\", \"float\", low=0.5, high=2.0)\n        &gt;&gt;&gt; doe = generate_doe(space, method=\"lhs\", n_samples=50, seed=42)\n    \"\"\"\n    return design_space.sample(\n        method=method,\n        n_samples=n_samples,\n        seed=seed,\n        grid_levels=grid_levels,\n    )\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.doe.generate_doe_from_dict","title":"generate_doe_from_dict","text":"<pre><code>generate_doe_from_dict(variables: dict, method: Literal['grid', 'random', 'lhs'] = 'lhs', n_samples: int = 100, seed: int | None = None) -&gt; DataFrame\n</code></pre> <p>Generate DOE from a simplified dictionary specification.</p> <p>Convenience function for quick DOE generation without creating explicit DesignVariable objects.</p> PARAMETER DESCRIPTION <code>variables</code> <p>Dictionary mapping variable names to specs: - For continuous: {\"name\": (low, high)} or {\"name\": (low, high, \"float\")} - For discrete: {\"name\": (low, high, \"int\")} - For categorical: {\"name\": [\"value1\", \"value2\", ...]}</p> <p> TYPE: <code>dict</code> </p> <code>method</code> <p>Sampling method</p> <p> TYPE: <code>Literal['grid', 'random', 'lhs']</code> DEFAULT: <code>'lhs'</code> </p> <code>n_samples</code> <p>Number of samples</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>seed</code> <p>Random seed</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with DOE cases</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; doe = generate_doe_from_dict({\n...     \"array.nx\": (4, 16, \"int\"),\n...     \"array.ny\": (4, 16, \"int\"),\n...     \"rf.tx_power_w_per_elem\": (0.5, 2.0),\n...     \"array.geometry\": [\"rectangular\", \"triangular\"],\n... }, n_samples=50)\n</code></pre> Source code in <code>src/phased_array_systems/trades/doe.py</code> <pre><code>def generate_doe_from_dict(\n    variables: dict,\n    method: Literal[\"grid\", \"random\", \"lhs\"] = \"lhs\",\n    n_samples: int = 100,\n    seed: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Generate DOE from a simplified dictionary specification.\n\n    Convenience function for quick DOE generation without creating\n    explicit DesignVariable objects.\n\n    Args:\n        variables: Dictionary mapping variable names to specs:\n            - For continuous: {\"name\": (low, high)} or {\"name\": (low, high, \"float\")}\n            - For discrete: {\"name\": (low, high, \"int\")}\n            - For categorical: {\"name\": [\"value1\", \"value2\", ...]}\n        method: Sampling method\n        n_samples: Number of samples\n        seed: Random seed\n\n    Returns:\n        DataFrame with DOE cases\n\n    Examples:\n        &gt;&gt;&gt; doe = generate_doe_from_dict({\n        ...     \"array.nx\": (4, 16, \"int\"),\n        ...     \"array.ny\": (4, 16, \"int\"),\n        ...     \"rf.tx_power_w_per_elem\": (0.5, 2.0),\n        ...     \"array.geometry\": [\"rectangular\", \"triangular\"],\n        ... }, n_samples=50)\n    \"\"\"\n    space = DesignSpace()\n\n    for name, spec in variables.items():\n        if isinstance(spec, list):\n            # Categorical\n            space.add_variable(name, type=\"categorical\", values=spec)\n        elif isinstance(spec, tuple):\n            if len(spec) == 2:\n                # (low, high) -&gt; float\n                space.add_variable(name, type=\"float\", low=spec[0], high=spec[1])\n            elif len(spec) == 3:\n                # (low, high, type)\n                space.add_variable(name, type=spec[2], low=spec[0], high=spec[1])\n            else:\n                raise ValueError(f\"Invalid spec for '{name}': {spec}\")\n        else:\n            raise ValueError(f\"Invalid spec type for '{name}': {type(spec)}\")\n\n    return generate_doe(space, method=method, n_samples=n_samples, seed=seed)\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.doe.augment_doe","title":"augment_doe","text":"<pre><code>augment_doe(existing_doe: DataFrame, design_space: DesignSpace, n_additional: int, method: Literal['random', 'lhs'] = 'lhs', seed: int | None = None) -&gt; DataFrame\n</code></pre> <p>Add additional samples to an existing DOE.</p> <p>Useful for adaptive sampling or expanding a study.</p> PARAMETER DESCRIPTION <code>existing_doe</code> <p>Existing DOE DataFrame</p> <p> TYPE: <code>DataFrame</code> </p> <code>design_space</code> <p>DesignSpace defining the variables</p> <p> TYPE: <code>DesignSpace</code> </p> <code>n_additional</code> <p>Number of additional samples to add</p> <p> TYPE: <code>int</code> </p> <code>method</code> <p>Sampling method for new samples</p> <p> TYPE: <code>Literal['random', 'lhs']</code> DEFAULT: <code>'lhs'</code> </p> <code>seed</code> <p>Random seed</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Combined DataFrame with original + new cases</p> Source code in <code>src/phased_array_systems/trades/doe.py</code> <pre><code>def augment_doe(\n    existing_doe: pd.DataFrame,\n    design_space: DesignSpace,\n    n_additional: int,\n    method: Literal[\"random\", \"lhs\"] = \"lhs\",\n    seed: int | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Add additional samples to an existing DOE.\n\n    Useful for adaptive sampling or expanding a study.\n\n    Args:\n        existing_doe: Existing DOE DataFrame\n        design_space: DesignSpace defining the variables\n        n_additional: Number of additional samples to add\n        method: Sampling method for new samples\n        seed: Random seed\n\n    Returns:\n        Combined DataFrame with original + new cases\n    \"\"\"\n    # Generate new samples\n    new_doe = generate_doe(\n        design_space,\n        method=method,\n        n_samples=n_additional,\n        seed=seed,\n    )\n\n    # Renumber case IDs to avoid collision\n    max_existing_id = 0\n    for case_id in existing_doe[\"case_id\"]:\n        if case_id.startswith(\"case_\"):\n            try:\n                num = int(case_id.replace(\"case_\", \"\"))\n                max_existing_id = max(max_existing_id, num)\n            except ValueError:\n                pass\n\n    new_ids = [f\"case_{i:05d}\" for i in range(max_existing_id + 1, max_existing_id + 1 + n_additional)]\n    new_doe[\"case_id\"] = new_ids\n\n    # Combine\n    return pd.concat([existing_doe, new_doe], ignore_index=True)\n</code></pre>"},{"location":"api/trades/#batch-evaluation","title":"Batch Evaluation","text":""},{"location":"api/trades/#phased_array_systems.trades.runner.BatchRunner","title":"BatchRunner","text":"<pre><code>BatchRunner(scenario: Scenario, requirements: RequirementSet | None = None, architecture_builder: Callable[[dict], Architecture] | None = None)\n</code></pre> <p>Parallel batch evaluation of DOE cases.</p> <p>Evaluates multiple architecture/scenario combinations with case-level error handling, progress reporting, and resume capability.</p> ATTRIBUTE DESCRIPTION <code>scenario</code> <p>Scenario to evaluate against</p> <p> </p> <code>requirements</code> <p>Optional requirements for verification</p> <p> </p> <code>architecture_builder</code> <p>Function to build Architecture from case dict</p> <p> </p> <p>Initialize the batch runner.</p> PARAMETER DESCRIPTION <code>scenario</code> <p>Scenario to evaluate</p> <p> TYPE: <code>Scenario</code> </p> <code>requirements</code> <p>Optional requirements for verification</p> <p> TYPE: <code>RequirementSet | None</code> DEFAULT: <code>None</code> </p> <code>architecture_builder</code> <p>Function to convert case dict to Architecture. If None, uses default_architecture_builder.</p> <p> TYPE: <code>Callable[[dict], Architecture] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/phased_array_systems/trades/runner.py</code> <pre><code>def __init__(\n    self,\n    scenario: Scenario,\n    requirements: RequirementSet | None = None,\n    architecture_builder: Callable[[dict], Architecture] | None = None,\n):\n    \"\"\"Initialize the batch runner.\n\n    Args:\n        scenario: Scenario to evaluate\n        requirements: Optional requirements for verification\n        architecture_builder: Function to convert case dict to Architecture.\n            If None, uses default_architecture_builder.\n    \"\"\"\n    self.scenario = scenario\n    self.requirements = requirements\n    self.architecture_builder = architecture_builder or default_architecture_builder\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.runner.BatchRunner.run","title":"run","text":"<pre><code>run(cases: DataFrame, n_workers: int = 1, cache_path: Path | None = None, progress_callback: Callable[[int, int], None] | None = None) -&gt; DataFrame\n</code></pre> <p>Run batch evaluation.</p> PARAMETER DESCRIPTION <code>cases</code> <p>DataFrame with design variable columns + case_id</p> <p> TYPE: <code>DataFrame</code> </p> <code>n_workers</code> <p>Number of parallel workers (1 = sequential)</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>cache_path</code> <p>Optional path to save/load partial results</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> <code>progress_callback</code> <p>Optional callback(completed, total) for progress</p> <p> TYPE: <code>Callable[[int, int], None] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with all input columns + all metric columns</p> Source code in <code>src/phased_array_systems/trades/runner.py</code> <pre><code>def run(\n    self,\n    cases: pd.DataFrame,\n    n_workers: int = 1,\n    cache_path: Path | None = None,\n    progress_callback: Callable[[int, int], None] | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Run batch evaluation.\n\n    Args:\n        cases: DataFrame with design variable columns + case_id\n        n_workers: Number of parallel workers (1 = sequential)\n        cache_path: Optional path to save/load partial results\n        progress_callback: Optional callback(completed, total) for progress\n\n    Returns:\n        DataFrame with all input columns + all metric columns\n    \"\"\"\n    # Load cached results if available\n    completed_ids = set()\n    cached_results = []\n\n    if cache_path is not None and cache_path.exists():\n        try:\n            cached_df = pd.read_parquet(cache_path)\n            completed_ids = set(cached_df[\"case_id\"])\n            cached_results = cached_df.to_dict(\"records\")\n            print(f\"Resuming: {len(completed_ids)} cases already completed\")\n        except Exception:\n            pass  # Ignore cache errors\n\n    # Filter to uncompleted cases\n    cases_to_run = cases[~cases[\"case_id\"].isin(completed_ids)]\n    total_cases = len(cases)\n    remaining = len(cases_to_run)\n\n    if remaining == 0:\n        print(\"All cases already completed\")\n        return pd.DataFrame(cached_results)\n\n    print(f\"Running {remaining} cases ({len(completed_ids)} cached)\")\n\n    # Convert to list of dicts for processing\n    case_dicts = cases_to_run.to_dict(\"records\")\n\n    results = list(cached_results)\n    start_time = time.perf_counter()\n\n    if n_workers == 1:\n        # Sequential execution\n        for i, case_row in enumerate(case_dicts):\n            result = _evaluate_single_case(\n                case_row,\n                self.scenario,\n                self.requirements,\n                self.architecture_builder,\n            )\n            results.append(result)\n\n            if progress_callback:\n                progress_callback(len(results), total_cases)\n\n            # Save intermediate results\n            if cache_path is not None and (i + 1) % 10 == 0:\n                self._save_cache(results, cache_path)\n\n    else:\n        # Parallel execution\n        with ProcessPoolExecutor(max_workers=n_workers) as executor:\n            futures = {\n                executor.submit(\n                    _evaluate_single_case,\n                    case_row,\n                    self.scenario,\n                    self.requirements,\n                    self.architecture_builder,\n                ): case_row[\"case_id\"]\n                for case_row in case_dicts\n            }\n\n            for future in as_completed(futures):\n                result = future.result()\n                results.append(result)\n\n                if progress_callback:\n                    progress_callback(len(results), total_cases)\n\n                # Save intermediate results periodically\n                if cache_path is not None and len(results) % 10 == 0:\n                    self._save_cache(results, cache_path)\n\n    elapsed = time.perf_counter() - start_time\n    print(f\"Completed {remaining} cases in {elapsed:.1f}s ({elapsed/remaining:.3f}s/case)\")\n\n    # Final save\n    if cache_path is not None:\n        self._save_cache(results, cache_path)\n\n    # Build result DataFrame\n    result_df = pd.DataFrame(results)\n\n    # Ensure consistent column order\n    cols = list(cases.columns) + [\n        c for c in result_df.columns if c not in cases.columns\n    ]\n    result_df = result_df[[c for c in cols if c in result_df.columns]]\n\n    return result_df\n</code></pre>"},{"location":"api/trades/#pareto-analysis","title":"Pareto Analysis","text":""},{"location":"api/trades/#phased_array_systems.trades.pareto.filter_feasible","title":"filter_feasible","text":"<pre><code>filter_feasible(results: DataFrame, requirements: RequirementSet | None = None, verification_column: str = 'verification.passes') -&gt; DataFrame\n</code></pre> <p>Filter results to only feasible (requirement-passing) designs.</p> PARAMETER DESCRIPTION <code>results</code> <p>DataFrame with evaluation results</p> <p> TYPE: <code>DataFrame</code> </p> <code>requirements</code> <p>Optional RequirementSet to verify against</p> <p> TYPE: <code>RequirementSet | None</code> DEFAULT: <code>None</code> </p> <code>verification_column</code> <p>Column name for verification status</p> <p> TYPE: <code>str</code> DEFAULT: <code>'verification.passes'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame containing only feasible designs</p> Source code in <code>src/phased_array_systems/trades/pareto.py</code> <pre><code>def filter_feasible(\n    results: pd.DataFrame,\n    requirements: RequirementSet | None = None,\n    verification_column: str = \"verification.passes\",\n) -&gt; pd.DataFrame:\n    \"\"\"Filter results to only feasible (requirement-passing) designs.\n\n    Args:\n        results: DataFrame with evaluation results\n        requirements: Optional RequirementSet to verify against\n        verification_column: Column name for verification status\n\n    Returns:\n        DataFrame containing only feasible designs\n    \"\"\"\n    if requirements is not None and len(requirements) &gt; 0:\n        # Re-verify against requirements\n        mask = []\n        for _, row in results.iterrows():\n            metrics = row.to_dict()\n            report = requirements.verify(metrics)\n            mask.append(report.passes)\n        return results[mask].copy()\n\n    elif verification_column in results.columns:\n        # Use pre-computed verification\n        return results[results[verification_column] == 1.0].copy()\n\n    else:\n        # No filtering - return all\n        return results.copy()\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.pareto.extract_pareto","title":"extract_pareto","text":"<pre><code>extract_pareto(results: DataFrame, objectives: list[tuple[str, OptimizeDirection]], include_dominated: bool = False) -&gt; DataFrame\n</code></pre> <p>Extract Pareto-optimal designs from results.</p> <p>A design is Pareto-optimal if no other design is better in all objectives.</p> PARAMETER DESCRIPTION <code>results</code> <p>DataFrame with evaluation results</p> <p> TYPE: <code>DataFrame</code> </p> <code>objectives</code> <p>List of (column_name, direction) tuples where direction is \"minimize\" or \"maximize\"</p> <p> TYPE: <code>list[tuple[str, OptimizeDirection]]</code> </p> <code>include_dominated</code> <p>If True, include a 'pareto_optimal' column marking Pareto-optimal rows</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame containing only Pareto-optimal designs (or all designs</p> <code>DataFrame</code> <p>with pareto_optimal column if include_dominated=True)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pareto = extract_pareto(results, [\n...     (\"cost_usd\", \"minimize\"),\n...     (\"eirp_dbw\", \"maximize\"),\n... ])\n</code></pre> Source code in <code>src/phased_array_systems/trades/pareto.py</code> <pre><code>def extract_pareto(\n    results: pd.DataFrame,\n    objectives: list[tuple[str, OptimizeDirection]],\n    include_dominated: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"Extract Pareto-optimal designs from results.\n\n    A design is Pareto-optimal if no other design is better in all objectives.\n\n    Args:\n        results: DataFrame with evaluation results\n        objectives: List of (column_name, direction) tuples where direction\n            is \"minimize\" or \"maximize\"\n        include_dominated: If True, include a 'pareto_optimal' column marking\n            Pareto-optimal rows\n\n    Returns:\n        DataFrame containing only Pareto-optimal designs (or all designs\n        with pareto_optimal column if include_dominated=True)\n\n    Examples:\n        &gt;&gt;&gt; pareto = extract_pareto(results, [\n        ...     (\"cost_usd\", \"minimize\"),\n        ...     (\"eirp_dbw\", \"maximize\"),\n        ... ])\n    \"\"\"\n    if len(results) == 0:\n        return results.copy()\n\n    # Convert to minimization (negate maximization objectives)\n    obj_matrix = np.zeros((len(results), len(objectives)))\n    for i, (name, direction) in enumerate(objectives):\n        values = results[name].values\n        if direction == \"maximize\":\n            obj_matrix[:, i] = -values\n        else:\n            obj_matrix[:, i] = values\n\n    # Find Pareto-optimal points\n    is_pareto = np.ones(len(results), dtype=bool)\n\n    for i in range(len(results)):\n        if not is_pareto[i]:\n            continue\n\n        # Check if any other point dominates point i\n        for j in range(len(results)):\n            if i == j or not is_pareto[j]:\n                continue\n\n            # j dominates i if j is &lt;= in all objectives and &lt; in at least one\n            all_leq = np.all(obj_matrix[j] &lt;= obj_matrix[i])\n            any_lt = np.any(obj_matrix[j] &lt; obj_matrix[i])\n\n            if all_leq and any_lt:\n                is_pareto[i] = False\n                break\n\n    if include_dominated:\n        result_df = results.copy()\n        result_df[\"pareto_optimal\"] = is_pareto\n        return result_df\n    else:\n        return results[is_pareto].copy()\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.pareto.rank_pareto","title":"rank_pareto","text":"<pre><code>rank_pareto(pareto: DataFrame, objectives: list[tuple[str, OptimizeDirection]], weights: list[float] | None = None, method: Literal['weighted_sum', 'topsis'] = 'weighted_sum') -&gt; DataFrame\n</code></pre> <p>Rank Pareto-optimal designs using weighted objectives.</p> PARAMETER DESCRIPTION <code>pareto</code> <p>DataFrame with Pareto-optimal designs</p> <p> TYPE: <code>DataFrame</code> </p> <code>objectives</code> <p>List of (column_name, direction) tuples</p> <p> TYPE: <code>list[tuple[str, OptimizeDirection]]</code> </p> <code>weights</code> <p>Weights for each objective (default: equal weights)</p> <p> TYPE: <code>list[float] | None</code> DEFAULT: <code>None</code> </p> <code>method</code> <p>Ranking method (\"weighted_sum\" or \"topsis\")</p> <p> TYPE: <code>Literal['weighted_sum', 'topsis']</code> DEFAULT: <code>'weighted_sum'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>DataFrame with added 'rank' and 'score' columns, sorted by rank</p> Source code in <code>src/phased_array_systems/trades/pareto.py</code> <pre><code>def rank_pareto(\n    pareto: pd.DataFrame,\n    objectives: list[tuple[str, OptimizeDirection]],\n    weights: list[float] | None = None,\n    method: Literal[\"weighted_sum\", \"topsis\"] = \"weighted_sum\",\n) -&gt; pd.DataFrame:\n    \"\"\"Rank Pareto-optimal designs using weighted objectives.\n\n    Args:\n        pareto: DataFrame with Pareto-optimal designs\n        objectives: List of (column_name, direction) tuples\n        weights: Weights for each objective (default: equal weights)\n        method: Ranking method (\"weighted_sum\" or \"topsis\")\n\n    Returns:\n        DataFrame with added 'rank' and 'score' columns, sorted by rank\n    \"\"\"\n    if len(pareto) == 0:\n        return pareto.copy()\n\n    n_obj = len(objectives)\n    if weights is None:\n        weights = [1.0 / n_obj] * n_obj\n    else:\n        # Normalize weights\n        total = sum(weights)\n        weights = [w / total for w in weights]\n\n    # Extract and normalize objective values\n    obj_matrix = np.zeros((len(pareto), n_obj))\n    for i, (name, direction) in enumerate(objectives):\n        values = pareto[name].values.astype(float)\n        # Normalize to [0, 1]\n        min_val, max_val = values.min(), values.max()\n        if max_val &gt; min_val:\n            normalized = (values - min_val) / (max_val - min_val)\n        else:\n            normalized = np.zeros_like(values)\n\n        # Flip for maximization (higher is better -&gt; lower normalized score)\n        if direction == \"maximize\":\n            normalized = 1 - normalized\n\n        obj_matrix[:, i] = normalized\n\n    if method == \"weighted_sum\":\n        # Weighted sum (lower is better)\n        scores = np.sum(obj_matrix * weights, axis=1)\n\n    elif method == \"topsis\":\n        # TOPSIS method\n        # Ideal point: min of all (already normalized to minimization)\n        ideal = np.zeros(n_obj)\n        # Anti-ideal: max of all\n        anti_ideal = np.ones(n_obj)\n\n        # Distance to ideal and anti-ideal\n        d_ideal = np.sqrt(np.sum(weights * (obj_matrix - ideal) ** 2, axis=1))\n        d_anti = np.sqrt(np.sum(weights * (obj_matrix - anti_ideal) ** 2, axis=1))\n\n        # TOPSIS score (higher is better, so negate for ranking)\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            scores = d_ideal / (d_ideal + d_anti)\n            scores = np.nan_to_num(scores, nan=1.0)\n\n    else:\n        raise ValueError(f\"Unknown ranking method: {method}\")\n\n    # Add scores and rank\n    result_df = pareto.copy()\n    result_df[\"pareto_score\"] = scores\n    result_df[\"pareto_rank\"] = result_df[\"pareto_score\"].rank(method=\"min\").astype(int)\n\n    return result_df.sort_values(\"pareto_rank\")\n</code></pre>"},{"location":"api/trades/#phased_array_systems.trades.pareto.compute_hypervolume","title":"compute_hypervolume","text":"<pre><code>compute_hypervolume(pareto: DataFrame, objectives: list[tuple[str, OptimizeDirection]], reference_point: list[float] | None = None) -&gt; float\n</code></pre> <p>Compute hypervolume indicator for a Pareto front.</p> <p>The hypervolume is the volume of objective space dominated by the Pareto front, bounded by a reference point. Higher is better.</p> PARAMETER DESCRIPTION <code>pareto</code> <p>DataFrame with Pareto-optimal designs</p> <p> TYPE: <code>DataFrame</code> </p> <code>objectives</code> <p>List of (column_name, direction) tuples</p> <p> TYPE: <code>list[tuple[str, OptimizeDirection]]</code> </p> <code>reference_point</code> <p>Reference point in objective space (default: worst point + 10%)</p> <p> TYPE: <code>list[float] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Hypervolume value</p> Note <p>For &gt;3 objectives, this uses a simple approximation.</p> Source code in <code>src/phased_array_systems/trades/pareto.py</code> <pre><code>def compute_hypervolume(\n    pareto: pd.DataFrame,\n    objectives: list[tuple[str, OptimizeDirection]],\n    reference_point: list[float] | None = None,\n) -&gt; float:\n    \"\"\"Compute hypervolume indicator for a Pareto front.\n\n    The hypervolume is the volume of objective space dominated by the\n    Pareto front, bounded by a reference point. Higher is better.\n\n    Args:\n        pareto: DataFrame with Pareto-optimal designs\n        objectives: List of (column_name, direction) tuples\n        reference_point: Reference point in objective space (default: worst point + 10%)\n\n    Returns:\n        Hypervolume value\n\n    Note:\n        For &gt;3 objectives, this uses a simple approximation.\n    \"\"\"\n    if len(pareto) == 0:\n        return 0.0\n\n    n_obj = len(objectives)\n\n    # Extract objective values (convert to minimization)\n    obj_matrix = np.zeros((len(pareto), n_obj))\n    for i, (name, direction) in enumerate(objectives):\n        values = pareto[name].values.astype(float)\n        if direction == \"maximize\":\n            obj_matrix[:, i] = -values\n        else:\n            obj_matrix[:, i] = values\n\n    # Set reference point if not provided\n    if reference_point is None:\n        worst = obj_matrix.max(axis=0)\n        reference_point = worst * 1.1 + 0.1  # 10% beyond worst\n\n    ref = np.array(reference_point)\n\n    # For 2D, compute exact hypervolume\n    if n_obj == 2:\n        # Sort by first objective\n        sorted_idx = np.argsort(obj_matrix[:, 0])\n        sorted_obj = obj_matrix[sorted_idx]\n\n        hv = 0.0\n        prev_y = ref[1]\n        for i in range(len(sorted_obj)):\n            x, y = sorted_obj[i]\n            if x &lt; ref[0] and y &lt; ref[1]:\n                hv += (ref[0] - x) * (prev_y - y)\n                prev_y = y\n\n        return hv\n\n    else:\n        # Monte Carlo approximation for higher dimensions\n        n_samples = 10000\n        rng = np.random.default_rng(42)\n\n        # Sample random points in hyperbox\n        samples = np.zeros((n_samples, n_obj))\n        for i in range(n_obj):\n            min_val = obj_matrix[:, i].min()\n            samples[:, i] = rng.uniform(min_val, ref[i], n_samples)\n\n        # Count points dominated by at least one Pareto point\n        dominated = np.zeros(n_samples, dtype=bool)\n        for pareto_point in obj_matrix:\n            is_dominated = np.all(samples &gt;= pareto_point, axis=1)\n            dominated |= is_dominated\n\n        # Estimate hypervolume\n        box_volume = np.prod(ref - obj_matrix.min(axis=0))\n        hv = box_volume * dominated.sum() / n_samples\n\n        return hv\n</code></pre>"},{"location":"api/trades/#usage-examples","title":"Usage Examples","text":""},{"location":"api/trades/#complete-trade-study","title":"Complete Trade Study","text":"<pre><code>from phased_array_systems.trades import (\n    DesignSpace, generate_doe, BatchRunner,\n    filter_feasible, extract_pareto, rank_pareto\n)\nfrom phased_array_systems.requirements import Requirement, RequirementSet\n\n# Define design space\nspace = (\n    DesignSpace(name=\"Array Trade\")\n    .add_variable(\"array.nx\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"array.ny\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"rf.tx_power_w_per_elem\", type=\"float\", low=0.5, high=3.0)\n    # Fixed parameters\n    .add_variable(\"array.geometry\", type=\"categorical\", values=[\"rectangular\"])\n    .add_variable(\"array.dx_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.dy_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.enforce_subarray_constraint\", type=\"categorical\", values=[True])\n    .add_variable(\"rf.pa_efficiency\", type=\"float\", low=0.3, high=0.3)\n)\n\n# Define requirements\nrequirements = RequirementSet(requirements=[\n    Requirement(\"REQ-001\", \"Min EIRP\", \"eirp_dbw\", \"&gt;=\", 35.0),\n    Requirement(\"REQ-002\", \"Max Cost\", \"cost_usd\", \"&lt;=\", 100000.0),\n])\n\n# Generate DOE\ndoe = generate_doe(space, method=\"lhs\", n_samples=100, seed=42)\n\n# Run batch evaluation\nrunner = BatchRunner(scenario, requirements)\nresults = runner.run(doe, n_workers=1)\n\n# Filter and extract Pareto\nfeasible = filter_feasible(results, requirements)\nobjectives = [(\"cost_usd\", \"minimize\"), (\"eirp_dbw\", \"maximize\")]\npareto = extract_pareto(feasible, objectives)\n\n# Rank Pareto designs\nranked = rank_pareto(pareto, objectives, weights=[0.5, 0.5])\nprint(f\"Top design: {ranked.iloc[0]['case_id']}\")\n</code></pre>"},{"location":"api/trades/#quick-doe","title":"Quick DOE","text":"<pre><code>doe = generate_doe_from_dict(\n    {\n        \"array.nx\": (4, 16, \"int\"),\n        \"array.ny\": (4, 16, \"int\"),\n        \"rf.tx_power_w_per_elem\": (0.5, 3.0),\n        \"array.geometry\": [\"rectangular\", \"triangular\"],\n    },\n    n_samples=50,\n    seed=42,\n)\n</code></pre>"},{"location":"api/trades/#progress-callback","title":"Progress Callback","text":"<pre><code>def show_progress(completed, total):\n    print(f\"Progress: {completed}/{total} ({completed/total*100:.0f}%)\")\n\nresults = runner.run(doe, progress_callback=show_progress)\n</code></pre>"},{"location":"api/trades/#hypervolume","title":"Hypervolume","text":"<pre><code>from phased_array_systems.trades import compute_hypervolume\n\nhv = compute_hypervolume(pareto, objectives)\nprint(f\"Hypervolume: {hv:.2e}\")\n</code></pre>"},{"location":"api/trades/#type-aliases","title":"Type Aliases","text":"<pre><code>from phased_array_systems.types import OptimizeDirection\n\n# OptimizeDirection = Literal[\"minimize\", \"maximize\"]\n\nobjectives = [\n    (\"cost_usd\", \"minimize\"),   # Lower is better\n    (\"eirp_dbw\", \"maximize\"),   # Higher is better\n]\n</code></pre>"},{"location":"api/trades/#see-also","title":"See Also","text":"<ul> <li>User Guide: Trade Studies</li> <li>User Guide: Pareto Analysis</li> <li>Visualization API</li> </ul>"},{"location":"api/viz/","title":"Visualization API","text":"<p>Plotting functions for trade study visualization.</p>"},{"location":"api/viz/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.viz import pareto_plot, scatter_matrix, trade_space_plot\n\n# Also available from submodule\nfrom phased_array_systems.viz.plots import save_figure\n</code></pre>"},{"location":"api/viz/#functions","title":"Functions","text":""},{"location":"api/viz/#phased_array_systems.viz.plots.pareto_plot","title":"pareto_plot","text":"<pre><code>pareto_plot(results: DataFrame, x: str, y: str, pareto_front: DataFrame | None = None, feasible_mask: Series | None = None, color_by: str | None = None, size_by: str | None = None, ax: Axes | None = None, title: str | None = None, x_label: str | None = None, y_label: str | None = None, show_pareto_line: bool = True, figsize: tuple[float, float] = (8, 6)) -&gt; Figure\n</code></pre> <p>Create a Pareto plot showing trade-offs between two objectives.</p> PARAMETER DESCRIPTION <code>results</code> <p>DataFrame with all evaluation results</p> <p> TYPE: <code>DataFrame</code> </p> <code>x</code> <p>Column name for x-axis</p> <p> TYPE: <code>str</code> </p> <code>y</code> <p>Column name for y-axis</p> <p> TYPE: <code>str</code> </p> <code>pareto_front</code> <p>Optional DataFrame with Pareto-optimal points to highlight</p> <p> TYPE: <code>DataFrame | None</code> DEFAULT: <code>None</code> </p> <code>feasible_mask</code> <p>Optional boolean Series marking feasible designs</p> <p> TYPE: <code>Series | None</code> DEFAULT: <code>None</code> </p> <code>color_by</code> <p>Optional column name to color points by</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>size_by</code> <p>Optional column name to size points by</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>ax</code> <p>Optional existing Axes to plot on</p> <p> TYPE: <code>Axes | None</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>Plot title</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>x_label</code> <p>X-axis label (defaults to column name)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>y_label</code> <p>Y-axis label (defaults to column name)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>show_pareto_line</code> <p>If True, draw line connecting Pareto points</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>figsize</code> <p>Figure size (width, height)</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>(8, 6)</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>matplotlib Figure object</p> Source code in <code>src/phased_array_systems/viz/plots.py</code> <pre><code>def pareto_plot(\n    results: pd.DataFrame,\n    x: str,\n    y: str,\n    pareto_front: pd.DataFrame | None = None,\n    feasible_mask: pd.Series | None = None,\n    color_by: str | None = None,\n    size_by: str | None = None,\n    ax: plt.Axes | None = None,\n    title: str | None = None,\n    x_label: str | None = None,\n    y_label: str | None = None,\n    show_pareto_line: bool = True,\n    figsize: tuple[float, float] = (8, 6),\n) -&gt; plt.Figure:\n    \"\"\"Create a Pareto plot showing trade-offs between two objectives.\n\n    Args:\n        results: DataFrame with all evaluation results\n        x: Column name for x-axis\n        y: Column name for y-axis\n        pareto_front: Optional DataFrame with Pareto-optimal points to highlight\n        feasible_mask: Optional boolean Series marking feasible designs\n        color_by: Optional column name to color points by\n        size_by: Optional column name to size points by\n        ax: Optional existing Axes to plot on\n        title: Plot title\n        x_label: X-axis label (defaults to column name)\n        y_label: Y-axis label (defaults to column name)\n        show_pareto_line: If True, draw line connecting Pareto points\n        figsize: Figure size (width, height)\n\n    Returns:\n        matplotlib Figure object\n    \"\"\"\n    if ax is None:\n        fig, ax = plt.subplots(figsize=figsize)\n    else:\n        fig = ax.figure\n\n    # Determine point sizes\n    if size_by is not None and size_by in results.columns:\n        sizes = results[size_by]\n        sizes = (sizes - sizes.min()) / (sizes.max() - sizes.min() + 1e-10) * 100 + 20\n    else:\n        sizes = 50\n\n    # Determine colors\n    if color_by is not None and color_by in results.columns:\n        colors = results[color_by]\n        cmap = plt.cm.viridis\n    else:\n        colors = \"steelblue\"\n        cmap = None\n\n    # Plot infeasible points (if mask provided)\n    if feasible_mask is not None:\n        infeasible = results[~feasible_mask]\n        if len(infeasible) &gt; 0:\n            ax.scatter(\n                infeasible[x],\n                infeasible[y],\n                c=\"lightgray\",\n                s=30,\n                alpha=0.5,\n                marker=\"x\",\n                label=\"Infeasible\",\n            )\n\n    # Plot all feasible points\n    plot_data = results[feasible_mask] if feasible_mask is not None else results\n\n    scatter = ax.scatter(\n        plot_data[x],\n        plot_data[y],\n        c=colors if color_by is None else plot_data[color_by],\n        s=sizes if isinstance(sizes, int) else plot_data[size_by] if size_by else 50,\n        alpha=0.7,\n        cmap=cmap,\n        label=\"Feasible\" if feasible_mask is not None else None,\n    )\n\n    # Add colorbar if coloring by a metric\n    if color_by is not None and cmap is not None:\n        cbar = plt.colorbar(scatter, ax=ax)\n        cbar.set_label(color_by)\n\n    # Highlight Pareto front\n    if pareto_front is not None and len(pareto_front) &gt; 0:\n        ax.scatter(\n            pareto_front[x],\n            pareto_front[y],\n            facecolors=\"none\",\n            edgecolors=\"red\",\n            s=100,\n            linewidths=2,\n            label=\"Pareto Optimal\",\n            zorder=5,\n        )\n\n        # Draw Pareto line\n        if show_pareto_line and len(pareto_front) &gt; 1:\n            sorted_pareto = pareto_front.sort_values(x)\n            ax.plot(\n                sorted_pareto[x],\n                sorted_pareto[y],\n                \"r--\",\n                alpha=0.5,\n                linewidth=1.5,\n                zorder=4,\n            )\n\n    # Labels and title\n    ax.set_xlabel(x_label or x)\n    ax.set_ylabel(y_label or y)\n    ax.set_title(title or f\"Pareto Trade-off: {x} vs {y}\")\n\n    # Legend\n    handles, labels = ax.get_legend_handles_labels()\n    if handles:\n        ax.legend(loc=\"best\")\n\n    ax.grid(True, alpha=0.3)\n    fig.tight_layout()\n\n    return fig\n</code></pre>"},{"location":"api/viz/#phased_array_systems.viz.plots.scatter_matrix","title":"scatter_matrix","text":"<pre><code>scatter_matrix(results: DataFrame, columns: list[str], color_by: str | None = None, diagonal: Literal['hist', 'kde'] = 'hist', figsize: tuple[float, float] | None = None, title: str | None = None) -&gt; Figure\n</code></pre> <p>Create a scatter matrix showing pairwise relationships.</p> PARAMETER DESCRIPTION <code>results</code> <p>DataFrame with evaluation results</p> <p> TYPE: <code>DataFrame</code> </p> <code>columns</code> <p>List of column names to include</p> <p> TYPE: <code>list[str]</code> </p> <code>color_by</code> <p>Optional column name to color points by</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>diagonal</code> <p>What to show on diagonal (\"hist\" or \"kde\")</p> <p> TYPE: <code>Literal['hist', 'kde']</code> DEFAULT: <code>'hist'</code> </p> <code>figsize</code> <p>Figure size (auto-calculated if None)</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>Overall figure title</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>matplotlib Figure object</p> Source code in <code>src/phased_array_systems/viz/plots.py</code> <pre><code>def scatter_matrix(\n    results: pd.DataFrame,\n    columns: list[str],\n    color_by: str | None = None,\n    diagonal: Literal[\"hist\", \"kde\"] = \"hist\",\n    figsize: tuple[float, float] | None = None,\n    title: str | None = None,\n) -&gt; plt.Figure:\n    \"\"\"Create a scatter matrix showing pairwise relationships.\n\n    Args:\n        results: DataFrame with evaluation results\n        columns: List of column names to include\n        color_by: Optional column name to color points by\n        diagonal: What to show on diagonal (\"hist\" or \"kde\")\n        figsize: Figure size (auto-calculated if None)\n        title: Overall figure title\n\n    Returns:\n        matplotlib Figure object\n    \"\"\"\n    n = len(columns)\n    if figsize is None:\n        figsize = (n * 2.5, n * 2.5)\n\n    fig, axes = plt.subplots(n, n, figsize=figsize)\n\n    # Determine colors\n    if color_by is not None and color_by in results.columns:\n        colors = results[color_by].values\n        cmap = plt.cm.viridis\n        norm = plt.Normalize(colors.min(), colors.max())\n        point_colors = cmap(norm(colors))\n    else:\n        point_colors = \"steelblue\"\n\n    for i, col_i in enumerate(columns):\n        for j, col_j in enumerate(columns):\n            ax = axes[i, j]\n\n            if i == j:\n                # Diagonal: histogram or KDE\n                if diagonal == \"hist\":\n                    ax.hist(results[col_i], bins=20, alpha=0.7, color=\"steelblue\")\n                else:  # kde\n                    from scipy import stats\n\n                    data = results[col_i].dropna()\n                    if len(data) &gt; 1:\n                        kde = stats.gaussian_kde(data)\n                        x_range = np.linspace(data.min(), data.max(), 100)\n                        ax.fill_between(x_range, kde(x_range), alpha=0.5)\n                        ax.plot(x_range, kde(x_range), color=\"steelblue\")\n            else:\n                # Off-diagonal: scatter plot\n                ax.scatter(\n                    results[col_j],\n                    results[col_i],\n                    c=point_colors,\n                    s=10,\n                    alpha=0.5,\n                )\n\n            # Labels on edges only\n            if i == n - 1:\n                ax.set_xlabel(col_j, fontsize=8)\n            else:\n                ax.set_xticklabels([])\n\n            if j == 0:\n                ax.set_ylabel(col_i, fontsize=8)\n            else:\n                ax.set_yticklabels([])\n\n            ax.tick_params(labelsize=6)\n\n    if title:\n        fig.suptitle(title, fontsize=12)\n\n    fig.tight_layout()\n    if title:\n        fig.subplots_adjust(top=0.95)\n\n    return fig\n</code></pre>"},{"location":"api/viz/#phased_array_systems.viz.plots.trade_space_plot","title":"trade_space_plot","text":"<pre><code>trade_space_plot(results: DataFrame, x: str, y: str, z: str, feasible_mask: Series | None = None, pareto_front: DataFrame | None = None, ax: Axes | None = None, figsize: tuple[float, float] = (10, 8), title: str | None = None) -&gt; Figure\n</code></pre> <p>Create a 3D trade space visualization.</p> PARAMETER DESCRIPTION <code>results</code> <p>DataFrame with evaluation results</p> <p> TYPE: <code>DataFrame</code> </p> <code>x</code> <p>Column name for x-axis</p> <p> TYPE: <code>str</code> </p> <code>y</code> <p>Column name for y-axis</p> <p> TYPE: <code>str</code> </p> <code>z</code> <p>Column name for z-axis (color)</p> <p> TYPE: <code>str</code> </p> <code>feasible_mask</code> <p>Optional boolean mask for feasible designs</p> <p> TYPE: <code>Series | None</code> DEFAULT: <code>None</code> </p> <code>pareto_front</code> <p>Optional DataFrame with Pareto-optimal points</p> <p> TYPE: <code>DataFrame | None</code> DEFAULT: <code>None</code> </p> <code>ax</code> <p>Optional existing 3D Axes</p> <p> TYPE: <code>Axes | None</code> DEFAULT: <code>None</code> </p> <code>figsize</code> <p>Figure size</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>(10, 8)</code> </p> <code>title</code> <p>Plot title</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>matplotlib Figure object</p> Source code in <code>src/phased_array_systems/viz/plots.py</code> <pre><code>def trade_space_plot(\n    results: pd.DataFrame,\n    x: str,\n    y: str,\n    z: str,\n    feasible_mask: pd.Series | None = None,\n    pareto_front: pd.DataFrame | None = None,\n    ax: plt.Axes | None = None,\n    figsize: tuple[float, float] = (10, 8),\n    title: str | None = None,\n) -&gt; plt.Figure:\n    \"\"\"Create a 3D trade space visualization.\n\n    Args:\n        results: DataFrame with evaluation results\n        x: Column name for x-axis\n        y: Column name for y-axis\n        z: Column name for z-axis (color)\n        feasible_mask: Optional boolean mask for feasible designs\n        pareto_front: Optional DataFrame with Pareto-optimal points\n        ax: Optional existing 3D Axes\n        figsize: Figure size\n        title: Plot title\n\n    Returns:\n        matplotlib Figure object\n    \"\"\"\n    if ax is None:\n        fig = plt.figure(figsize=figsize)\n        ax = fig.add_subplot(111, projection=\"3d\")\n    else:\n        fig = ax.figure\n\n    # Plot points\n    if feasible_mask is not None:\n        # Infeasible\n        inf_data = results[~feasible_mask]\n        ax.scatter(\n            inf_data[x],\n            inf_data[y],\n            inf_data[z],\n            c=\"lightgray\",\n            alpha=0.3,\n            s=20,\n            marker=\"x\",\n        )\n        plot_data = results[feasible_mask]\n    else:\n        plot_data = results\n\n    scatter = ax.scatter(\n        plot_data[x],\n        plot_data[y],\n        plot_data[z],\n        c=plot_data[z],\n        cmap=\"viridis\",\n        alpha=0.7,\n        s=40,\n    )\n\n    # Highlight Pareto front\n    if pareto_front is not None and len(pareto_front) &gt; 0:\n        ax.scatter(\n            pareto_front[x],\n            pareto_front[y],\n            pareto_front[z],\n            c=\"red\",\n            s=100,\n            marker=\"*\",\n            label=\"Pareto Optimal\",\n            zorder=5,\n        )\n        ax.legend()\n\n    ax.set_xlabel(x)\n    ax.set_ylabel(y)\n    ax.set_zlabel(z)\n\n    fig.colorbar(scatter, ax=ax, label=z, shrink=0.5)\n\n    if title:\n        ax.set_title(title)\n\n    return fig\n</code></pre>"},{"location":"api/viz/#phased_array_systems.viz.plots.save_figure","title":"save_figure","text":"<pre><code>save_figure(fig: Figure, path: str, dpi: int = 150, transparent: bool = False) -&gt; None\n</code></pre> <p>Save a figure to file.</p> PARAMETER DESCRIPTION <code>fig</code> <p>matplotlib Figure to save</p> <p> TYPE: <code>Figure</code> </p> <code>path</code> <p>Output path (extension determines format)</p> <p> TYPE: <code>str</code> </p> <code>dpi</code> <p>Resolution for raster formats</p> <p> TYPE: <code>int</code> DEFAULT: <code>150</code> </p> <code>transparent</code> <p>Whether to use transparent background</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/phased_array_systems/viz/plots.py</code> <pre><code>def save_figure(\n    fig: plt.Figure,\n    path: str,\n    dpi: int = 150,\n    transparent: bool = False,\n) -&gt; None:\n    \"\"\"Save a figure to file.\n\n    Args:\n        fig: matplotlib Figure to save\n        path: Output path (extension determines format)\n        dpi: Resolution for raster formats\n        transparent: Whether to use transparent background\n    \"\"\"\n    fig.savefig(path, dpi=dpi, transparent=transparent, bbox_inches=\"tight\")\n</code></pre>"},{"location":"api/viz/#usage-examples","title":"Usage Examples","text":""},{"location":"api/viz/#pareto-plot","title":"Pareto Plot","text":"<pre><code>from phased_array_systems.viz import pareto_plot\nfrom phased_array_systems.trades import extract_pareto\n\n# Extract Pareto frontier\npareto = extract_pareto(results, [(\"cost_usd\", \"minimize\"), (\"eirp_dbw\", \"maximize\")])\n\n# Create feasibility mask\nfeasible_mask = results[\"verification.passes\"] == 1.0\n\n# Generate plot\nfig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    pareto_front=pareto,\n    feasible_mask=feasible_mask,\n    color_by=\"link_margin_db\",\n    title=\"Cost vs EIRP Trade Space\",\n    x_label=\"Total Cost (USD)\",\n    y_label=\"EIRP (dBW)\",\n)\nfig.savefig(\"pareto.png\", dpi=150, bbox_inches=\"tight\")\n</code></pre>"},{"location":"api/viz/#scatter-matrix","title":"Scatter Matrix","text":"<pre><code>from phased_array_systems.viz import scatter_matrix\n\nfig = scatter_matrix(\n    feasible,\n    columns=[\"cost_usd\", \"eirp_dbw\", \"link_margin_db\", \"prime_power_w\"],\n    color_by=\"n_elements\",\n    diagonal=\"hist\",\n    title=\"Trade Space Correlations\",\n)\nfig.savefig(\"scatter.png\", dpi=150)\n</code></pre>"},{"location":"api/viz/#3d-trade-space","title":"3D Trade Space","text":"<pre><code>from phased_array_systems.viz import trade_space_plot\n\nfig = trade_space_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    z=\"prime_power_w\",\n    feasible_mask=feasible_mask,\n    pareto_front=pareto_3d,\n    title=\"3D Trade Space\",\n)\nfig.savefig(\"trade_space_3d.png\", dpi=150)\n</code></pre>"},{"location":"api/viz/#multi-panel-figure","title":"Multi-Panel Figure","text":"<pre><code>import matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(1, 2, figsize=(14, 6))\n\npareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\", ax=axes[0])\npareto_plot(results, x=\"cost_usd\", y=\"link_margin_db\", ax=axes[1])\n\nfig.tight_layout()\nfig.savefig(\"combined.png\", dpi=150)\n</code></pre>"},{"location":"api/viz/#saving-figures","title":"Saving Figures","text":"<pre><code>from phased_array_systems.viz import save_figure\n\nfig = pareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\")\n\n# Various formats\nsave_figure(fig, \"plot.png\", dpi=150)\nsave_figure(fig, \"plot.pdf\")\nsave_figure(fig, \"plot.svg\")\nsave_figure(fig, \"plot_transparent.png\", transparent=True)\n</code></pre>"},{"location":"api/viz/#plot-customization","title":"Plot Customization","text":""},{"location":"api/viz/#adding-annotations","title":"Adding Annotations","text":"<pre><code>fig = pareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\")\nax = fig.axes[0]\n\n# Add reference lines\nax.axhline(y=40, color='r', linestyle='--', label='Min EIRP')\nax.axvline(x=50000, color='g', linestyle='--', label='Budget')\n\n# Add annotation\nax.annotate(\n    \"Target Region\",\n    xy=(40000, 45),\n    xytext=(55000, 50),\n    arrowprops=dict(arrowstyle=\"-&gt;\"),\n)\n\nax.legend()\n</code></pre>"},{"location":"api/viz/#custom-color-maps","title":"Custom Color Maps","text":"<pre><code>fig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    color_by=\"link_margin_db\",\n)\n\n# Access scatter for custom colorbar\nax = fig.axes[0]\n# Colorbar is automatically added when color_by is specified\n</code></pre>"},{"location":"api/viz/#non-interactive-usage","title":"Non-Interactive Usage","text":"<p>For scripts without display:</p> <pre><code>import matplotlib\nmatplotlib.use(\"Agg\")  # Must be before pyplot import\nimport matplotlib.pyplot as plt\n\nfrom phased_array_systems.viz import pareto_plot\n\nfig = pareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\")\nfig.savefig(\"output.png\", dpi=150)\nplt.close(fig)  # Release memory\n</code></pre>"},{"location":"api/viz/#see-also","title":"See Also","text":"<ul> <li>User Guide: Visualization</li> <li>User Guide: Pareto Analysis</li> <li>Trades API</li> </ul>"},{"location":"api/models/","title":"Models API","text":"<p>Computational models for antenna, communications, radar, and SWaP-C analysis.</p>"},{"location":"api/models/#overview","title":"Overview","text":"<p>Models follow the <code>ModelBlock</code> protocol:</p> <pre><code>from typing import Protocol\n\nclass ModelBlock(Protocol):\n    name: str\n\n    def evaluate(\n        self,\n        arch: Architecture,\n        scenario: Scenario,\n        context: dict,\n    ) -&gt; dict[str, float]:\n        \"\"\"Evaluate model and return metrics.\"\"\"\n        ...\n</code></pre>"},{"location":"api/models/#model-categories","title":"Model Categories","text":"Module Purpose Antenna Array metrics and <code>phased-array-modeling</code> adapter Communications Link budget calculations Radar Radar equation and detection Digital ADC/DAC, bandwidth, timeline scheduling RF Noise figure, gain cascade, dynamic range SWaP-C Size, Weight, Power, and Cost"},{"location":"api/models/#canonical-metrics","title":"Canonical Metrics","text":"<p>All models contribute to a unified metrics dictionary:</p>"},{"location":"api/models/#antenna-metrics","title":"Antenna Metrics","text":"Key Units Description <code>g_peak_db</code> dB Peak antenna gain <code>beamwidth_az_deg</code> degrees Azimuth beamwidth <code>beamwidth_el_deg</code> degrees Elevation beamwidth <code>sll_db</code> dB Sidelobe level <code>scan_loss_db</code> dB Scan loss <code>directivity_db</code> dB Directivity"},{"location":"api/models/#communications-metrics","title":"Communications Metrics","text":"Key Units Description <code>eirp_dbw</code> dBW Effective isotropic radiated power <code>path_loss_db</code> dB Total path loss <code>rx_power_dbw</code> dBW Received power <code>noise_power_dbw</code> dBW Receiver noise power <code>snr_rx_db</code> dB Received SNR <code>link_margin_db</code> dB Link margin"},{"location":"api/models/#radar-metrics","title":"Radar Metrics","text":"Key Units Description <code>snr_single_pulse_db</code> dB Single-pulse SNR <code>snr_integrated_db</code> dB Integrated SNR <code>snr_required_db</code> dB Required SNR for Pd/Pfa <code>snr_margin_db</code> dB SNR margin <code>detection_range_m</code> m Maximum detection range"},{"location":"api/models/#swap-c-metrics","title":"SWaP-C Metrics","text":"Key Units Description <code>cost_usd</code> USD Total cost <code>recurring_cost_usd</code> USD Recurring cost <code>prime_power_w</code> W Prime power consumption <code>rf_power_w</code> W RF power <code>dc_power_w</code> W DC power"},{"location":"api/models/#metadata","title":"Metadata","text":"Key Units Description <code>meta.case_id</code> - Unique case identifier <code>meta.runtime_s</code> s Evaluation runtime <code>meta.error</code> - Error message (if any)"},{"location":"api/models/#using-models-directly","title":"Using Models Directly","text":"<pre><code>from phased_array_systems.models.comms.link_budget import CommsLinkModel\n\nmodel = CommsLinkModel()\n\n# Evaluate with context\ncontext = {\"g_peak_db\": 28.0}  # Pre-computed antenna gain\nmetrics = model.evaluate(arch, scenario, context)\n</code></pre>"},{"location":"api/models/#see-also","title":"See Also","text":"<ul> <li>User Guide: Link Budget</li> <li>User Guide: Radar Detection</li> </ul>"},{"location":"api/models/antenna/","title":"Antenna Models API","text":"<p>Antenna array adapter and metrics extraction.</p>"},{"location":"api/models/antenna/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.models.antenna import (\n    PhasedArrayAdapter,\n    compute_beamwidth,\n    compute_scan_loss,\n    compute_sidelobe_level,\n)\n</code></pre> <p>The antenna module provides an adapter to the <code>phased-array-modeling</code> package for detailed antenna pattern computations.</p>"},{"location":"api/models/antenna/#classes","title":"Classes","text":""},{"location":"api/models/antenna/#phased_array_systems.models.antenna.adapter.PhasedArrayAdapter","title":"PhasedArrayAdapter","text":"<pre><code>PhasedArrayAdapter(use_analytical_fallback: bool = True)\n</code></pre> <p>Adapter for phased-array-modeling library.</p> <p>Provides a consistent interface for computing antenna pattern metrics using the phased-array-modeling library, with fallback to analytical approximations when the library is not available.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Model block name for identification</p> <p> TYPE: <code>str</code> </p> <code>use_analytical_fallback</code> <p>If True, use analytical approximations when phased-array-modeling is not available</p> <p> </p> <p>Initialize the adapter.</p> PARAMETER DESCRIPTION <code>use_analytical_fallback</code> <p>Use analytical methods if PAM unavailable</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/phased_array_systems/models/antenna/adapter.py</code> <pre><code>def __init__(self, use_analytical_fallback: bool = True):\n    \"\"\"Initialize the adapter.\n\n    Args:\n        use_analytical_fallback: Use analytical methods if PAM unavailable\n    \"\"\"\n    self.use_analytical_fallback = use_analytical_fallback\n\n    if not HAS_PAM and not use_analytical_fallback:\n        raise ImportError(\n            \"phased-array-modeling not installed. Install with: \"\n            \"pip install phased-array-modeling\"\n        )\n</code></pre>"},{"location":"api/models/antenna/#phased_array_systems.models.antenna.adapter.PhasedArrayAdapter.evaluate","title":"evaluate","text":"<pre><code>evaluate(arch: Architecture, scenario: Scenario, context: dict[str, Any]) -&gt; MetricsDict\n</code></pre> <p>Evaluate antenna performance metrics.</p> PARAMETER DESCRIPTION <code>arch</code> <p>Architecture configuration</p> <p> TYPE: <code>Architecture</code> </p> <code>scenario</code> <p>Scenario with frequency and scan angle info</p> <p> TYPE: <code>Scenario</code> </p> <code>context</code> <p>Additional context (unused)</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>MetricsDict</code> <p>Dictionary with antenna metrics: - g_peak_db: Peak array gain (dB) - beamwidth_az_deg: Azimuth beamwidth (degrees) - beamwidth_el_deg: Elevation beamwidth (degrees) - sll_db: Peak sidelobe level (dB, negative) - scan_loss_db: Scan loss at operating angle (dB) - directivity_db: Array directivity (dB) - n_elements: Number of array elements</p> Source code in <code>src/phased_array_systems/models/antenna/adapter.py</code> <pre><code>def evaluate(\n    self, arch: Architecture, scenario: Scenario, context: dict[str, Any]\n) -&gt; MetricsDict:\n    \"\"\"Evaluate antenna performance metrics.\n\n    Args:\n        arch: Architecture configuration\n        scenario: Scenario with frequency and scan angle info\n        context: Additional context (unused)\n\n    Returns:\n        Dictionary with antenna metrics:\n            - g_peak_db: Peak array gain (dB)\n            - beamwidth_az_deg: Azimuth beamwidth (degrees)\n            - beamwidth_el_deg: Elevation beamwidth (degrees)\n            - sll_db: Peak sidelobe level (dB, negative)\n            - scan_loss_db: Scan loss at operating angle (dB)\n            - directivity_db: Array directivity (dB)\n            - n_elements: Number of array elements\n    \"\"\"\n    # Extract scan angle from scenario if available\n    scan_angle_deg = getattr(scenario, \"scan_angle_deg\", 0.0)\n\n    if HAS_PAM:\n        return self._evaluate_with_pam(arch, scenario, scan_angle_deg)\n    else:\n        return self._evaluate_analytical(arch, scenario, scan_angle_deg)\n</code></pre>"},{"location":"api/models/antenna/#functions","title":"Functions","text":""},{"location":"api/models/antenna/#phased_array_systems.models.antenna.metrics.compute_beamwidth","title":"compute_beamwidth","text":"<pre><code>compute_beamwidth(pattern_db: NDArray[floating], angles_deg: NDArray[floating], level_db: float = -3.0) -&gt; float\n</code></pre> <p>Compute beamwidth at specified level below peak.</p> PARAMETER DESCRIPTION <code>pattern_db</code> <p>Pattern magnitude in dB</p> <p> TYPE: <code>NDArray[floating]</code> </p> <code>angles_deg</code> <p>Corresponding angles in degrees</p> <p> TYPE: <code>NDArray[floating]</code> </p> <code>level_db</code> <p>Level below peak to measure (default -3 dB)</p> <p> TYPE: <code>float</code> DEFAULT: <code>-3.0</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Beamwidth in degrees, or NaN if not found</p> Source code in <code>src/phased_array_systems/models/antenna/metrics.py</code> <pre><code>def compute_beamwidth(\n    pattern_db: NDArray[np.floating],\n    angles_deg: NDArray[np.floating],\n    level_db: float = -3.0,\n) -&gt; float:\n    \"\"\"Compute beamwidth at specified level below peak.\n\n    Args:\n        pattern_db: Pattern magnitude in dB\n        angles_deg: Corresponding angles in degrees\n        level_db: Level below peak to measure (default -3 dB)\n\n    Returns:\n        Beamwidth in degrees, or NaN if not found\n    \"\"\"\n    peak_db = np.max(pattern_db)\n    threshold = peak_db + level_db  # level_db is negative\n\n    # Find peak index\n    peak_idx = np.argmax(pattern_db)\n\n    # Search left from peak\n    left_idx = peak_idx\n    for i in range(peak_idx, -1, -1):\n        if pattern_db[i] &lt; threshold:\n            left_idx = i\n            break\n\n    # Search right from peak\n    right_idx = peak_idx\n    for i in range(peak_idx, len(pattern_db)):\n        if pattern_db[i] &lt; threshold:\n            right_idx = i\n            break\n\n    if left_idx == peak_idx or right_idx == peak_idx:\n        return float(\"nan\")\n\n    # Linear interpolation for more accurate crossing points\n    left_angle = np.interp(threshold, [pattern_db[left_idx], pattern_db[left_idx + 1]],\n                           [angles_deg[left_idx], angles_deg[left_idx + 1]])\n    right_angle = np.interp(threshold, [pattern_db[right_idx], pattern_db[right_idx - 1]],\n                            [angles_deg[right_idx], angles_deg[right_idx - 1]])\n\n    return abs(right_angle - left_angle)\n</code></pre>"},{"location":"api/models/antenna/#phased_array_systems.models.antenna.metrics.compute_scan_loss","title":"compute_scan_loss","text":"<pre><code>compute_scan_loss(scan_angle_deg: float, model: str = 'cosine') -&gt; float\n</code></pre> <p>Compute scan loss for a phased array at given scan angle.</p> PARAMETER DESCRIPTION <code>scan_angle_deg</code> <p>Scan angle from boresight (degrees)</p> <p> TYPE: <code>float</code> </p> <code>model</code> <p>Scan loss model (\"cosine\" or \"cosine_squared\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cosine'</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Scan loss in dB (positive value representing loss)</p> Source code in <code>src/phased_array_systems/models/antenna/metrics.py</code> <pre><code>def compute_scan_loss(scan_angle_deg: float, model: str = \"cosine\") -&gt; float:\n    \"\"\"Compute scan loss for a phased array at given scan angle.\n\n    Args:\n        scan_angle_deg: Scan angle from boresight (degrees)\n        model: Scan loss model (\"cosine\" or \"cosine_squared\")\n\n    Returns:\n        Scan loss in dB (positive value representing loss)\n    \"\"\"\n    if scan_angle_deg &gt;= 90:\n        return float(\"inf\")\n\n    scan_rad = math.radians(scan_angle_deg)\n\n    if model == \"cosine\":\n        # Standard cos(theta) scan loss\n        loss_linear = math.cos(scan_rad)\n    elif model == \"cosine_squared\":\n        # More aggressive cos^2(theta) model\n        loss_linear = math.cos(scan_rad) ** 2\n    else:\n        raise ValueError(f\"Unknown scan loss model: {model}\")\n\n    if loss_linear &lt;= 0:\n        return float(\"inf\")\n\n    loss_db = -10 * math.log10(loss_linear)\n    return abs(loss_db) if abs(loss_db) &lt; 1e-10 else loss_db  # Avoid -0.0 display\n</code></pre>"},{"location":"api/models/antenna/#phased_array_systems.models.antenna.metrics.compute_sidelobe_level","title":"compute_sidelobe_level","text":"<pre><code>compute_sidelobe_level(pattern_db: NDArray[floating], angles_deg: NDArray[floating], main_lobe_width_deg: float | None = None) -&gt; float\n</code></pre> <p>Compute peak sidelobe level relative to main beam.</p> PARAMETER DESCRIPTION <code>pattern_db</code> <p>Pattern magnitude in dB</p> <p> TYPE: <code>NDArray[floating]</code> </p> <code>angles_deg</code> <p>Corresponding angles in degrees</p> <p> TYPE: <code>NDArray[floating]</code> </p> <code>main_lobe_width_deg</code> <p>Width of main lobe to exclude (auto-detected if None)</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Peak sidelobe level in dB (negative value)</p> Source code in <code>src/phased_array_systems/models/antenna/metrics.py</code> <pre><code>def compute_sidelobe_level(\n    pattern_db: NDArray[np.floating],\n    angles_deg: NDArray[np.floating],\n    main_lobe_width_deg: float | None = None,\n) -&gt; float:\n    \"\"\"Compute peak sidelobe level relative to main beam.\n\n    Args:\n        pattern_db: Pattern magnitude in dB\n        angles_deg: Corresponding angles in degrees\n        main_lobe_width_deg: Width of main lobe to exclude (auto-detected if None)\n\n    Returns:\n        Peak sidelobe level in dB (negative value)\n    \"\"\"\n    peak_db = np.max(pattern_db)\n    peak_idx = np.argmax(pattern_db)\n    peak_angle = angles_deg[peak_idx]\n\n    # Auto-detect main lobe width if not provided\n    if main_lobe_width_deg is None:\n        bw = compute_beamwidth(pattern_db, angles_deg, -3.0)\n        if np.isnan(bw):\n            bw = 10.0  # Default fallback\n        main_lobe_width_deg = bw * 2  # Use 2x beamwidth as exclusion zone\n\n    # Mask out main lobe region\n    half_width = main_lobe_width_deg / 2\n    mask = np.abs(angles_deg - peak_angle) &gt; half_width\n\n    if not np.any(mask):\n        return float(\"-inf\")\n\n    sidelobe_pattern = pattern_db[mask]\n    peak_sidelobe_db = np.max(sidelobe_pattern)\n\n    return peak_sidelobe_db - peak_db\n</code></pre>"},{"location":"api/models/antenna/#output-metrics","title":"Output Metrics","text":"Metric Units Description <code>g_peak_db</code> dB Peak antenna gain <code>beamwidth_az_deg</code> degrees 3 dB beamwidth in azimuth <code>beamwidth_el_deg</code> degrees 3 dB beamwidth in elevation <code>sll_db</code> dB Peak sidelobe level <code>scan_loss_db</code> dB Gain reduction due to scan <code>directivity_db</code> dB Antenna directivity <code>n_elements</code> - Total element count"},{"location":"api/models/antenna/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/antenna/#using-the-adapter","title":"Using the Adapter","text":"<pre><code>from phased_array_systems.models.antenna import PhasedArrayAdapter\nfrom phased_array_systems.architecture import Architecture, ArrayConfig, RFChainConfig\n\narch = Architecture(\n    array=ArrayConfig(nx=8, ny=8, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(tx_power_w_per_elem=1.0),\n)\n\nadapter = PhasedArrayAdapter()\nmetrics = adapter.evaluate(arch, scenario, context={})\n\nprint(f\"Peak Gain: {metrics['g_peak_db']:.1f} dB\")\nprint(f\"Beamwidth: {metrics['beamwidth_az_deg']:.1f}\u00b0 x {metrics['beamwidth_el_deg']:.1f}\u00b0\")\n</code></pre>"},{"location":"api/models/antenna/#with-scan-angle","title":"With Scan Angle","text":"<pre><code>from phased_array_systems.scenarios import CommsLinkScenario\n\nscenario = CommsLinkScenario(\n    freq_hz=10e9,\n    bandwidth_hz=10e6,\n    range_m=100e3,\n    required_snr_db=10.0,\n    scan_angle_deg=30.0,  # 30\u00b0 off boresight\n)\n\nmetrics = adapter.evaluate(arch, scenario, context={})\nprint(f\"Scan Loss: {metrics['scan_loss_db']:.1f} dB\")\n</code></pre>"},{"location":"api/models/antenna/#gain-approximation","title":"Gain Approximation","text":"<p>When the full antenna adapter is not used, gain is approximated:</p> \\[ G \\approx 4\\pi \\cdot n_x d_x \\cdot n_y d_y \\] <p>Where \\(d_x, d_y\\) are element spacings in wavelengths.</p> <p>This approximation is used in the link budget model when antenna metrics aren't pre-computed.</p>"},{"location":"api/models/antenna/#see-also","title":"See Also","text":"<ul> <li>Communications Models</li> <li>User Guide: Link Budget</li> </ul>"},{"location":"api/models/comms/","title":"Communications Models API","text":"<p>Link budget calculations for communications systems.</p>"},{"location":"api/models/comms/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.models.comms import CommsLinkModel, compute_fspl\n\n# For direct link margin calculations\nfrom phased_array_systems.models.comms.link_budget import compute_link_margin\n</code></pre>"},{"location":"api/models/comms/#classes","title":"Classes","text":""},{"location":"api/models/comms/#phased_array_systems.models.comms.link_budget.CommsLinkModel","title":"CommsLinkModel","text":"<p>Communications link budget calculator.</p> <p>Computes EIRP, received power, noise power, SNR, and link margin for a point-to-point or satellite communications link.</p> Link Budget Equations <p>EIRP = P_tx_total + G_tx - L_tx P_rx = EIRP - L_path + G_rx N = 10log10(kT*B) + NF SNR = P_rx - N Margin = SNR - required_SNR</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Model block name for identification</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/models/comms/#phased_array_systems.models.comms.link_budget.CommsLinkModel.evaluate","title":"evaluate","text":"<pre><code>evaluate(arch: Architecture, scenario: CommsLinkScenario, context: dict[str, Any]) -&gt; MetricsDict\n</code></pre> <p>Evaluate communications link budget.</p> PARAMETER DESCRIPTION <code>arch</code> <p>Architecture configuration</p> <p> TYPE: <code>Architecture</code> </p> <code>scenario</code> <p>Communications link scenario</p> <p> TYPE: <code>CommsLinkScenario</code> </p> <code>context</code> <p>Additional context, may include antenna metrics: - g_peak_db: Antenna gain (uses this if provided) - scan_loss_db: Scan loss (uses this if provided)</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>MetricsDict</code> <p>Dictionary with link budget metrics: - tx_power_total_dbw: Total transmit power (dBW) - tx_power_per_elem_dbw: TX power per element (dBW) - g_tx_db: Transmit antenna gain (dB) - eirp_dbw: Effective Isotropic Radiated Power (dBW) - path_loss_db: Total path loss (dB) - g_rx_db: Receive antenna gain (dB) - rx_power_dbw: Received power (dBW) - noise_power_dbw: Noise power (dBW) - snr_rx_db: Received SNR (dB) - link_margin_db: Link margin (dB)</p> Source code in <code>src/phased_array_systems/models/comms/link_budget.py</code> <pre><code>def evaluate(\n    self,\n    arch: Architecture,\n    scenario: CommsLinkScenario,\n    context: dict[str, Any],\n) -&gt; MetricsDict:\n    \"\"\"Evaluate communications link budget.\n\n    Args:\n        arch: Architecture configuration\n        scenario: Communications link scenario\n        context: Additional context, may include antenna metrics:\n            - g_peak_db: Antenna gain (uses this if provided)\n            - scan_loss_db: Scan loss (uses this if provided)\n\n    Returns:\n        Dictionary with link budget metrics:\n            - tx_power_total_dbw: Total transmit power (dBW)\n            - tx_power_per_elem_dbw: TX power per element (dBW)\n            - g_tx_db: Transmit antenna gain (dB)\n            - eirp_dbw: Effective Isotropic Radiated Power (dBW)\n            - path_loss_db: Total path loss (dB)\n            - g_rx_db: Receive antenna gain (dB)\n            - rx_power_dbw: Received power (dBW)\n            - noise_power_dbw: Noise power (dBW)\n            - snr_rx_db: Received SNR (dB)\n            - link_margin_db: Link margin (dB)\n    \"\"\"\n    # Get transmit power\n    n_elements = arch.array.n_elements\n    tx_power_per_elem_w = arch.rf.tx_power_w_per_elem\n    tx_power_total_w = tx_power_per_elem_w * n_elements\n    tx_power_total_dbw = W_TO_DBW(tx_power_total_w)\n    tx_power_per_elem_dbw = W_TO_DBW(tx_power_per_elem_w)\n\n    # Get antenna gain from context or compute approximate\n    if \"g_peak_db\" in context:\n        g_tx_db = context[\"g_peak_db\"]\n    else:\n        # Approximate gain for uniform array\n        # G = 4*pi*A/lambda^2 \u2248 pi * nx * dx * ny * dy * 4\n        aperture_area_lambda_sq = (\n            arch.array.nx * arch.array.dx_lambda *\n            arch.array.ny * arch.array.dy_lambda\n        )\n        g_tx_linear = 4 * math.pi * aperture_area_lambda_sq\n        g_tx_db = 10 * math.log10(g_tx_linear)\n\n        # Apply scan loss if provided\n        if \"scan_loss_db\" in context:\n            g_tx_db -= context[\"scan_loss_db\"]\n\n    # Transmit losses (feed network + system)\n    tx_loss_db = arch.rf.feed_loss_db + arch.rf.system_loss_db\n\n    # EIRP\n    eirp_dbw = tx_power_total_dbw + g_tx_db - tx_loss_db\n\n    # Path loss\n    if scenario.path_loss_model == \"fspl\":\n        path_loss_db = compute_fspl(scenario.freq_hz, scenario.range_m)\n    else:\n        raise ValueError(f\"Unknown path loss model: {scenario.path_loss_model}\")\n\n    # Add extra losses\n    total_path_loss_db = path_loss_db + scenario.total_extra_loss_db\n\n    # Receive antenna gain (isotropic if not specified)\n    g_rx_db = scenario.rx_antenna_gain_db if scenario.rx_antenna_gain_db is not None else 0.0\n\n    # Received power\n    rx_power_dbw = eirp_dbw - total_path_loss_db + g_rx_db\n\n    # Noise power: N = k*T*B\n    noise_power_w = K_B * scenario.rx_noise_temp_k * scenario.bandwidth_hz\n    noise_power_dbw = W_TO_DBW(noise_power_w)\n\n    # Add receiver noise figure\n    noise_power_dbw += arch.rf.noise_figure_db\n\n    # SNR\n    snr_rx_db = rx_power_dbw - noise_power_dbw\n\n    # Link margin\n    link_margin_db = snr_rx_db - scenario.required_snr_db\n\n    return {\n        \"tx_power_total_dbw\": tx_power_total_dbw,\n        \"tx_power_per_elem_dbw\": tx_power_per_elem_dbw,\n        \"g_tx_db\": g_tx_db,\n        \"eirp_dbw\": eirp_dbw,\n        \"path_loss_db\": total_path_loss_db,\n        \"fspl_db\": path_loss_db,\n        \"g_rx_db\": g_rx_db,\n        \"rx_power_dbw\": rx_power_dbw,\n        \"noise_power_dbw\": noise_power_dbw,\n        \"snr_rx_db\": snr_rx_db,\n        \"link_margin_db\": link_margin_db,\n        \"required_snr_db\": scenario.required_snr_db,\n    }\n</code></pre>"},{"location":"api/models/comms/#functions","title":"Functions","text":""},{"location":"api/models/comms/#phased_array_systems.models.comms.link_budget.compute_link_margin","title":"compute_link_margin","text":"<pre><code>compute_link_margin(eirp_dbw: float, path_loss_db: float, g_rx_db: float, noise_temp_k: float, bandwidth_hz: float, noise_figure_db: float, required_snr_db: float) -&gt; dict[str, float]\n</code></pre> <p>Standalone link margin calculation.</p> <p>Convenience function for quick link budget calculations without full Architecture/Scenario objects.</p> PARAMETER DESCRIPTION <code>eirp_dbw</code> <p>Effective Isotropic Radiated Power (dBW)</p> <p> TYPE: <code>float</code> </p> <code>path_loss_db</code> <p>Total path loss (dB)</p> <p> TYPE: <code>float</code> </p> <code>g_rx_db</code> <p>Receive antenna gain (dB)</p> <p> TYPE: <code>float</code> </p> <code>noise_temp_k</code> <p>System noise temperature (K)</p> <p> TYPE: <code>float</code> </p> <code>bandwidth_hz</code> <p>Signal bandwidth (Hz)</p> <p> TYPE: <code>float</code> </p> <code>noise_figure_db</code> <p>Receiver noise figure (dB)</p> <p> TYPE: <code>float</code> </p> <code>required_snr_db</code> <p>Required SNR for demodulation (dB)</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with rx_power_dbw, noise_power_dbw, snr_db, margin_db</p> Source code in <code>src/phased_array_systems/models/comms/link_budget.py</code> <pre><code>def compute_link_margin(\n    eirp_dbw: float,\n    path_loss_db: float,\n    g_rx_db: float,\n    noise_temp_k: float,\n    bandwidth_hz: float,\n    noise_figure_db: float,\n    required_snr_db: float,\n) -&gt; dict[str, float]:\n    \"\"\"Standalone link margin calculation.\n\n    Convenience function for quick link budget calculations\n    without full Architecture/Scenario objects.\n\n    Args:\n        eirp_dbw: Effective Isotropic Radiated Power (dBW)\n        path_loss_db: Total path loss (dB)\n        g_rx_db: Receive antenna gain (dB)\n        noise_temp_k: System noise temperature (K)\n        bandwidth_hz: Signal bandwidth (Hz)\n        noise_figure_db: Receiver noise figure (dB)\n        required_snr_db: Required SNR for demodulation (dB)\n\n    Returns:\n        Dictionary with rx_power_dbw, noise_power_dbw, snr_db, margin_db\n    \"\"\"\n    rx_power_dbw = eirp_dbw - path_loss_db + g_rx_db\n    noise_power_w = K_B * noise_temp_k * bandwidth_hz\n    noise_power_dbw = W_TO_DBW(noise_power_w) + noise_figure_db\n    snr_db = rx_power_dbw - noise_power_dbw\n    margin_db = snr_db - required_snr_db\n\n    return {\n        \"rx_power_dbw\": rx_power_dbw,\n        \"noise_power_dbw\": noise_power_dbw,\n        \"snr_db\": snr_db,\n        \"margin_db\": margin_db,\n    }\n</code></pre>"},{"location":"api/models/comms/#phased_array_systems.models.comms.propagation.compute_fspl","title":"compute_fspl","text":"<pre><code>compute_fspl(freq_hz: float, range_m: float) -&gt; float\n</code></pre> <p>Compute Free Space Path Loss (FSPL).</p> <p>FSPL = 20log10(4pidf/c)      = 20log10(d) + 20log10(f) + 20log10(4pi/c)      = 20log10(d) + 20log10(f) - 147.55 (with d in m, f in Hz)</p> PARAMETER DESCRIPTION <code>freq_hz</code> <p>Frequency in Hz</p> <p> TYPE: <code>float</code> </p> <code>range_m</code> <p>Range/distance in meters</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Free space path loss in dB (positive value)</p> Source code in <code>src/phased_array_systems/models/comms/propagation.py</code> <pre><code>def compute_fspl(freq_hz: float, range_m: float) -&gt; float:\n    \"\"\"Compute Free Space Path Loss (FSPL).\n\n    FSPL = 20*log10(4*pi*d*f/c)\n         = 20*log10(d) + 20*log10(f) + 20*log10(4*pi/c)\n         = 20*log10(d) + 20*log10(f) - 147.55 (with d in m, f in Hz)\n\n    Args:\n        freq_hz: Frequency in Hz\n        range_m: Range/distance in meters\n\n    Returns:\n        Free space path loss in dB (positive value)\n    \"\"\"\n    if freq_hz &lt;= 0:\n        raise ValueError(\"Frequency must be positive\")\n    if range_m &lt;= 0:\n        raise ValueError(\"Range must be positive\")\n\n    wavelength = C / freq_hz\n    fspl_linear = (4 * math.pi * range_m / wavelength) ** 2\n    return 10 * math.log10(fspl_linear)\n</code></pre>"},{"location":"api/models/comms/#output-metrics","title":"Output Metrics","text":"Metric Units Description <code>tx_power_total_dbw</code> dBW Total TX power <code>tx_power_per_elem_dbw</code> dBW TX power per element <code>g_tx_db</code> dB Transmit antenna gain <code>eirp_dbw</code> dBW Effective isotropic radiated power <code>path_loss_db</code> dB Total path loss <code>fspl_db</code> dB Free space path loss only <code>g_rx_db</code> dB Receive antenna gain <code>rx_power_dbw</code> dBW Received signal power <code>noise_power_dbw</code> dBW Receiver noise power <code>snr_rx_db</code> dB Received SNR <code>link_margin_db</code> dB Margin above required SNR <code>required_snr_db</code> dB Required SNR"},{"location":"api/models/comms/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/comms/#using-commslinkmodel","title":"Using CommsLinkModel","text":"<pre><code>from phased_array_systems.models.comms.link_budget import CommsLinkModel\n\nmodel = CommsLinkModel()\n\n# Without pre-computed antenna gain\nmetrics = model.evaluate(arch, scenario, context={})\n\n# With pre-computed antenna gain\ncontext = {\n    \"g_peak_db\": 28.0,\n    \"scan_loss_db\": 2.5,\n}\nmetrics = model.evaluate(arch, scenario, context)\n</code></pre>"},{"location":"api/models/comms/#quick-link-margin-calculation","title":"Quick Link Margin Calculation","text":"<pre><code>from phased_array_systems.models.comms.link_budget import compute_link_margin\n\nresult = compute_link_margin(\n    eirp_dbw=50.0,\n    path_loss_db=160.0,\n    g_rx_db=30.0,\n    noise_temp_k=290.0,\n    bandwidth_hz=10e6,\n    noise_figure_db=3.0,\n    required_snr_db=10.0,\n)\n\nprint(f\"SNR: {result['snr_db']:.1f} dB\")\nprint(f\"Margin: {result['margin_db']:.1f} dB\")\n</code></pre>"},{"location":"api/models/comms/#free-space-path-loss","title":"Free Space Path Loss","text":"<pre><code>from phased_array_systems.models.comms.propagation import compute_fspl\n\n# At 10 GHz, 100 km\nloss = compute_fspl(freq_hz=10e9, range_m=100e3)\nprint(f\"FSPL: {loss:.1f} dB\")  # ~152.4 dB\n</code></pre>"},{"location":"api/models/comms/#link-budget-equations","title":"Link Budget Equations","text":""},{"location":"api/models/comms/#eirp","title":"EIRP","text":"\\[ EIRP = P_{tx} + G_{tx} - L_{tx} \\]"},{"location":"api/models/comms/#path-loss","title":"Path Loss","text":"\\[ L_{path} = L_{FSPL} + L_{atm} + L_{rain} + L_{pol} \\]"},{"location":"api/models/comms/#free-space-path-loss_1","title":"Free Space Path Loss","text":"\\[ L_{FSPL} = 20 \\log_{10}\\left(\\frac{4\\pi d f}{c}\\right) \\]"},{"location":"api/models/comms/#received-power","title":"Received Power","text":"\\[ P_{rx} = EIRP - L_{path} + G_{rx} \\]"},{"location":"api/models/comms/#noise-power","title":"Noise Power","text":"\\[ N = 10 \\log_{10}(kTB) + NF \\]"},{"location":"api/models/comms/#snr-and-margin","title":"SNR and Margin","text":"\\[ SNR = P_{rx} - N $$ $$ Margin = SNR - SNR_{required} \\]"},{"location":"api/models/comms/#see-also","title":"See Also","text":"<ul> <li>Theory: Link Budget Equations</li> <li>User Guide: Link Budget</li> <li>Scenarios API</li> </ul>"},{"location":"api/models/digital/","title":"Digital Array Models API","text":"<p>ADC/DAC converters, bandwidth calculations, and timeline scheduling for digital phased arrays.</p>"},{"location":"api/models/digital/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.models.digital import (\n    # Converters\n    enob_to_snr,\n    snr_to_enob,\n    enob_to_sfdr,\n    sfdr_to_enob,\n    quantization_noise_floor,\n    sample_rate_for_bandwidth,\n    max_signal_bandwidth,\n    adc_dynamic_range,\n    dac_output_power,\n    # Bandwidth\n    beam_bandwidth_product,\n    max_simultaneous_beams,\n    digital_beamformer_data_rate,\n    channelizer_output_rate,\n    processing_margin,\n    beamformer_operations,\n    # Scheduling\n    Dwell,\n    Timeline,\n    Function,\n    timeline_utilization,\n    max_update_rate,\n    search_timeline,\n    interleaved_timeline,\n)\n</code></pre>"},{"location":"api/models/digital/#converters","title":"Converters","text":"<p>Functions for analyzing ADC/DAC performance including ENOB, SNR, SFDR, and quantization noise.</p>"},{"location":"api/models/digital/#key-relationships","title":"Key Relationships","text":"<ul> <li>SNR (ideal) = 6.02 * ENOB + 1.76 dB</li> <li>SFDR ~ SNR for ideal converters</li> <li>Nyquist: fs &gt;= 2 * BW (practical: fs &gt;= 2.5 * BW)</li> </ul>"},{"location":"api/models/digital/#phased_array_systems.models.digital.converters.enob_to_snr","title":"enob_to_snr","text":"<pre><code>enob_to_snr(enob: float) -&gt; float\n</code></pre> <p>Convert Effective Number of Bits to SNR.</p> The ideal SNR for a converter with ENOB effective bits is <p>SNR = 6.02 * ENOB + 1.76 dB</p> <p>This assumes full-scale sinusoidal input and ideal quantization.</p> PARAMETER DESCRIPTION <code>enob</code> <p>Effective number of bits</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>SNR in dB</p> Source code in <code>src/phased_array_systems/models/digital/converters.py</code> <pre><code>def enob_to_snr(enob: float) -&gt; float:\n    \"\"\"Convert Effective Number of Bits to SNR.\n\n    The ideal SNR for a converter with ENOB effective bits is:\n        SNR = 6.02 * ENOB + 1.76 dB\n\n    This assumes full-scale sinusoidal input and ideal quantization.\n\n    Args:\n        enob: Effective number of bits\n\n    Returns:\n        SNR in dB\n    \"\"\"\n    return 6.02 * enob + 1.76\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.converters.snr_to_enob","title":"snr_to_enob","text":"<pre><code>snr_to_enob(snr_db: float) -&gt; float\n</code></pre> <p>Convert SNR to Effective Number of Bits.</p> Inverse of enob_to_snr <p>ENOB = (SNR - 1.76) / 6.02</p> <p>Useful for determining effective resolution from measured SNR.</p> PARAMETER DESCRIPTION <code>snr_db</code> <p>Signal-to-noise ratio in dB</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Effective number of bits</p> Source code in <code>src/phased_array_systems/models/digital/converters.py</code> <pre><code>def snr_to_enob(snr_db: float) -&gt; float:\n    \"\"\"Convert SNR to Effective Number of Bits.\n\n    Inverse of enob_to_snr:\n        ENOB = (SNR - 1.76) / 6.02\n\n    Useful for determining effective resolution from measured SNR.\n\n    Args:\n        snr_db: Signal-to-noise ratio in dB\n\n    Returns:\n        Effective number of bits\n    \"\"\"\n    return (snr_db - 1.76) / 6.02\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.converters.enob_to_sfdr","title":"enob_to_sfdr","text":"<pre><code>enob_to_sfdr(enob: float, margin_db: float = 0.0) -&gt; float\n</code></pre> <p>Estimate SFDR from ENOB.</p> <p>For an ideal converter, SFDR is approximately equal to SNR. Real converters may have SFDR limited by harmonic distortion.</p> PARAMETER DESCRIPTION <code>enob</code> <p>Effective number of bits</p> <p> TYPE: <code>float</code> </p> <code>margin_db</code> <p>Derate factor for non-ideal behavior (default 0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Estimated SFDR in dB</p> Source code in <code>src/phased_array_systems/models/digital/converters.py</code> <pre><code>def enob_to_sfdr(enob: float, margin_db: float = 0.0) -&gt; float:\n    \"\"\"Estimate SFDR from ENOB.\n\n    For an ideal converter, SFDR is approximately equal to SNR.\n    Real converters may have SFDR limited by harmonic distortion.\n\n    Args:\n        enob: Effective number of bits\n        margin_db: Derate factor for non-ideal behavior (default 0)\n\n    Returns:\n        Estimated SFDR in dB\n    \"\"\"\n    return enob_to_snr(enob) - margin_db\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.converters.sfdr_to_enob","title":"sfdr_to_enob","text":"<pre><code>sfdr_to_enob(sfdr_db: float) -&gt; float\n</code></pre> <p>Convert SFDR to equivalent ENOB.</p> <p>Useful for determining effective dynamic range in bits.</p> PARAMETER DESCRIPTION <code>sfdr_db</code> <p>Spurious-free dynamic range in dB</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Equivalent ENOB</p> Source code in <code>src/phased_array_systems/models/digital/converters.py</code> <pre><code>def sfdr_to_enob(sfdr_db: float) -&gt; float:\n    \"\"\"Convert SFDR to equivalent ENOB.\n\n    Useful for determining effective dynamic range in bits.\n\n    Args:\n        sfdr_db: Spurious-free dynamic range in dB\n\n    Returns:\n        Equivalent ENOB\n    \"\"\"\n    return snr_to_enob(sfdr_db)\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.converters.quantization_noise_floor","title":"quantization_noise_floor","text":"<pre><code>quantization_noise_floor(enob: float, full_scale_dbm: float, bandwidth_hz: float, sample_rate_hz: float) -&gt; float\n</code></pre> <p>Calculate quantization noise floor in dBm/Hz.</p> <p>The quantization noise power is spread across the Nyquist bandwidth. Noise floor density = Full scale - SNR - 10*log10(fs/2)</p> PARAMETER DESCRIPTION <code>enob</code> <p>Effective number of bits</p> <p> TYPE: <code>float</code> </p> <code>full_scale_dbm</code> <p>Full-scale input power in dBm</p> <p> TYPE: <code>float</code> </p> <code>bandwidth_hz</code> <p>Signal bandwidth in Hz</p> <p> TYPE: <code>float</code> </p> <code>sample_rate_hz</code> <p>Sample rate in Hz</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Noise floor spectral density in dBm/Hz</p> Source code in <code>src/phased_array_systems/models/digital/converters.py</code> <pre><code>def quantization_noise_floor(\n    enob: float,\n    full_scale_dbm: float,\n    bandwidth_hz: float,\n    sample_rate_hz: float,\n) -&gt; float:\n    \"\"\"Calculate quantization noise floor in dBm/Hz.\n\n    The quantization noise power is spread across the Nyquist bandwidth.\n    Noise floor density = Full scale - SNR - 10*log10(fs/2)\n\n    Args:\n        enob: Effective number of bits\n        full_scale_dbm: Full-scale input power in dBm\n        bandwidth_hz: Signal bandwidth in Hz\n        sample_rate_hz: Sample rate in Hz\n\n    Returns:\n        Noise floor spectral density in dBm/Hz\n    \"\"\"\n    snr_db = enob_to_snr(enob)\n    nyquist_bw = sample_rate_hz / 2\n    noise_floor_dbm_hz = full_scale_dbm - snr_db - 10 * math.log10(nyquist_bw)\n    return noise_floor_dbm_hz\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.converters.sample_rate_for_bandwidth","title":"sample_rate_for_bandwidth","text":"<pre><code>sample_rate_for_bandwidth(signal_bandwidth_hz: float, oversampling_ratio: float = 2.5) -&gt; float\n</code></pre> <p>Calculate minimum sample rate for a given signal bandwidth.</p> <p>Nyquist requires fs &gt;= 2*BW, but practical systems use oversampling to ease anti-aliasing filter requirements.</p> PARAMETER DESCRIPTION <code>signal_bandwidth_hz</code> <p>Signal bandwidth in Hz</p> <p> TYPE: <code>float</code> </p> <code>oversampling_ratio</code> <p>Ratio of sample rate to Nyquist rate - 2.0: Minimum (steep filter required) - 2.5: Typical (recommended) - 4.0: Relaxed filtering</p> <p> TYPE: <code>float</code> DEFAULT: <code>2.5</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Required sample rate in Hz</p> Source code in <code>src/phased_array_systems/models/digital/converters.py</code> <pre><code>def sample_rate_for_bandwidth(\n    signal_bandwidth_hz: float,\n    oversampling_ratio: float = 2.5,\n) -&gt; float:\n    \"\"\"Calculate minimum sample rate for a given signal bandwidth.\n\n    Nyquist requires fs &gt;= 2*BW, but practical systems use oversampling\n    to ease anti-aliasing filter requirements.\n\n    Args:\n        signal_bandwidth_hz: Signal bandwidth in Hz\n        oversampling_ratio: Ratio of sample rate to Nyquist rate\n            - 2.0: Minimum (steep filter required)\n            - 2.5: Typical (recommended)\n            - 4.0: Relaxed filtering\n\n    Returns:\n        Required sample rate in Hz\n    \"\"\"\n    return signal_bandwidth_hz * oversampling_ratio\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.converters.max_signal_bandwidth","title":"max_signal_bandwidth","text":"<pre><code>max_signal_bandwidth(sample_rate_hz: float, oversampling_ratio: float = 2.5) -&gt; float\n</code></pre> <p>Calculate maximum signal bandwidth for a given sample rate.</p> <p>Inverse of sample_rate_for_bandwidth.</p> PARAMETER DESCRIPTION <code>sample_rate_hz</code> <p>ADC/DAC sample rate in Hz</p> <p> TYPE: <code>float</code> </p> <code>oversampling_ratio</code> <p>Ratio of sample rate to Nyquist rate</p> <p> TYPE: <code>float</code> DEFAULT: <code>2.5</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Maximum signal bandwidth in Hz</p> Source code in <code>src/phased_array_systems/models/digital/converters.py</code> <pre><code>def max_signal_bandwidth(\n    sample_rate_hz: float,\n    oversampling_ratio: float = 2.5,\n) -&gt; float:\n    \"\"\"Calculate maximum signal bandwidth for a given sample rate.\n\n    Inverse of sample_rate_for_bandwidth.\n\n    Args:\n        sample_rate_hz: ADC/DAC sample rate in Hz\n        oversampling_ratio: Ratio of sample rate to Nyquist rate\n\n    Returns:\n        Maximum signal bandwidth in Hz\n    \"\"\"\n    return sample_rate_hz / oversampling_ratio\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.converters.adc_dynamic_range","title":"adc_dynamic_range","text":"<pre><code>adc_dynamic_range(enob: float, noise_figure_db: float = 0.0, input_noise_dbm_hz: float = -174.0, bandwidth_hz: float = 1.0) -&gt; dict[str, float]\n</code></pre> <p>Calculate ADC dynamic range metrics.</p> <p>Computes the usable dynamic range considering both quantization noise and thermal noise contributions.</p> PARAMETER DESCRIPTION <code>enob</code> <p>Effective number of bits</p> <p> TYPE: <code>float</code> </p> <code>noise_figure_db</code> <p>Front-end noise figure in dB</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>input_noise_dbm_hz</code> <p>Input noise density (default: thermal at 290K)</p> <p> TYPE: <code>float</code> DEFAULT: <code>-174.0</code> </p> <code>bandwidth_hz</code> <p>Signal bandwidth for integrated noise</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - snr_db: Quantization-limited SNR - noise_floor_dbm: Integrated noise floor - max_input_dbm: Maximum input before clipping - dynamic_range_db: Usable dynamic range</p> Source code in <code>src/phased_array_systems/models/digital/converters.py</code> <pre><code>def adc_dynamic_range(\n    enob: float,\n    noise_figure_db: float = 0.0,\n    input_noise_dbm_hz: float = -174.0,\n    bandwidth_hz: float = 1.0,\n) -&gt; dict[str, float]:\n    \"\"\"Calculate ADC dynamic range metrics.\n\n    Computes the usable dynamic range considering both quantization\n    noise and thermal noise contributions.\n\n    Args:\n        enob: Effective number of bits\n        noise_figure_db: Front-end noise figure in dB\n        input_noise_dbm_hz: Input noise density (default: thermal at 290K)\n        bandwidth_hz: Signal bandwidth for integrated noise\n\n    Returns:\n        Dictionary with:\n            - snr_db: Quantization-limited SNR\n            - noise_floor_dbm: Integrated noise floor\n            - max_input_dbm: Maximum input before clipping\n            - dynamic_range_db: Usable dynamic range\n    \"\"\"\n    snr_db = enob_to_snr(enob)\n\n    # Thermal noise floor\n    thermal_noise_dbm = input_noise_dbm_hz + noise_figure_db + 10 * math.log10(bandwidth_hz)\n\n    # Full scale (assume 0 dBm reference, adjust as needed)\n    full_scale_dbm = 0.0\n\n    # Quantization noise\n    quant_noise_dbm = full_scale_dbm - snr_db\n\n    # Total noise (power sum)\n    total_noise_linear = 10 ** (thermal_noise_dbm / 10) + 10 ** (quant_noise_dbm / 10)\n    total_noise_dbm = 10 * math.log10(total_noise_linear)\n\n    dynamic_range_db = full_scale_dbm - total_noise_dbm\n\n    return {\n        \"snr_db\": snr_db,\n        \"noise_floor_dbm\": total_noise_dbm,\n        \"max_input_dbm\": full_scale_dbm,\n        \"dynamic_range_db\": dynamic_range_db,\n        \"thermal_noise_dbm\": thermal_noise_dbm,\n        \"quant_noise_dbm\": quant_noise_dbm,\n    }\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.converters.dac_output_power","title":"dac_output_power","text":"<pre><code>dac_output_power(enob: float, full_scale_dbm: float, backoff_db: float = 6.0) -&gt; dict[str, float]\n</code></pre> <p>Calculate DAC output power metrics.</p> <p>DACs typically operate with backoff from full scale to maintain linearity and avoid clipping on signal peaks.</p> PARAMETER DESCRIPTION <code>enob</code> <p>Effective number of bits</p> <p> TYPE: <code>float</code> </p> <code>full_scale_dbm</code> <p>Full-scale output power in dBm</p> <p> TYPE: <code>float</code> </p> <code>backoff_db</code> <p>Operating backoff from full scale</p> <p> TYPE: <code>float</code> DEFAULT: <code>6.0</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - full_scale_dbm: Maximum output power - operating_power_dbm: Power with backoff - snr_db: Signal-to-quantization-noise ratio - sfdr_db: Estimated spurious-free dynamic range - noise_floor_dbm: Quantization noise floor</p> Source code in <code>src/phased_array_systems/models/digital/converters.py</code> <pre><code>def dac_output_power(\n    enob: float,\n    full_scale_dbm: float,\n    backoff_db: float = 6.0,\n) -&gt; dict[str, float]:\n    \"\"\"Calculate DAC output power metrics.\n\n    DACs typically operate with backoff from full scale to maintain\n    linearity and avoid clipping on signal peaks.\n\n    Args:\n        enob: Effective number of bits\n        full_scale_dbm: Full-scale output power in dBm\n        backoff_db: Operating backoff from full scale\n\n    Returns:\n        Dictionary with:\n            - full_scale_dbm: Maximum output power\n            - operating_power_dbm: Power with backoff\n            - snr_db: Signal-to-quantization-noise ratio\n            - sfdr_db: Estimated spurious-free dynamic range\n            - noise_floor_dbm: Quantization noise floor\n    \"\"\"\n    snr_db = enob_to_snr(enob)\n    sfdr_db = enob_to_sfdr(enob)\n    operating_power_dbm = full_scale_dbm - backoff_db\n    noise_floor_dbm = full_scale_dbm - snr_db\n\n    return {\n        \"full_scale_dbm\": full_scale_dbm,\n        \"operating_power_dbm\": operating_power_dbm,\n        \"backoff_db\": backoff_db,\n        \"snr_db\": snr_db,\n        \"sfdr_db\": sfdr_db,\n        \"noise_floor_dbm\": noise_floor_dbm,\n    }\n</code></pre>"},{"location":"api/models/digital/#bandwidth","title":"Bandwidth","text":"<p>Functions for analyzing digital beamformer bandwidth constraints, beam-bandwidth products, and data rates.</p>"},{"location":"api/models/digital/#phased_array_systems.models.digital.bandwidth.beam_bandwidth_product","title":"beam_bandwidth_product","text":"<pre><code>beam_bandwidth_product(n_beams: int, bandwidth_per_beam_hz: float) -&gt; float\n</code></pre> <p>Calculate total beam-bandwidth product.</p> <p>The beam-bandwidth product represents the total instantaneous processing bandwidth required for simultaneous beams.</p> PARAMETER DESCRIPTION <code>n_beams</code> <p>Number of simultaneous beams</p> <p> TYPE: <code>int</code> </p> <code>bandwidth_per_beam_hz</code> <p>Bandwidth per beam in Hz</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Total beam-bandwidth product in Hz</p> Source code in <code>src/phased_array_systems/models/digital/bandwidth.py</code> <pre><code>def beam_bandwidth_product(\n    n_beams: int,\n    bandwidth_per_beam_hz: float,\n) -&gt; float:\n    \"\"\"Calculate total beam-bandwidth product.\n\n    The beam-bandwidth product represents the total instantaneous\n    processing bandwidth required for simultaneous beams.\n\n    Args:\n        n_beams: Number of simultaneous beams\n        bandwidth_per_beam_hz: Bandwidth per beam in Hz\n\n    Returns:\n        Total beam-bandwidth product in Hz\n    \"\"\"\n    return n_beams * bandwidth_per_beam_hz\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.bandwidth.max_simultaneous_beams","title":"max_simultaneous_beams","text":"<pre><code>max_simultaneous_beams(processing_bandwidth_hz: float, bandwidth_per_beam_hz: float, overhead_factor: float = 1.1) -&gt; int\n</code></pre> <p>Calculate maximum number of simultaneous beams.</p> <p>Given a fixed processing bandwidth, determine how many beams can be formed simultaneously.</p> PARAMETER DESCRIPTION <code>processing_bandwidth_hz</code> <p>Total available processing bandwidth</p> <p> TYPE: <code>float</code> </p> <code>bandwidth_per_beam_hz</code> <p>Required bandwidth per beam</p> <p> TYPE: <code>float</code> </p> <code>overhead_factor</code> <p>Processing overhead (default 10%)</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.1</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Maximum number of simultaneous beams (integer)</p> Source code in <code>src/phased_array_systems/models/digital/bandwidth.py</code> <pre><code>def max_simultaneous_beams(\n    processing_bandwidth_hz: float,\n    bandwidth_per_beam_hz: float,\n    overhead_factor: float = 1.1,\n) -&gt; int:\n    \"\"\"Calculate maximum number of simultaneous beams.\n\n    Given a fixed processing bandwidth, determine how many beams\n    can be formed simultaneously.\n\n    Args:\n        processing_bandwidth_hz: Total available processing bandwidth\n        bandwidth_per_beam_hz: Required bandwidth per beam\n        overhead_factor: Processing overhead (default 10%)\n\n    Returns:\n        Maximum number of simultaneous beams (integer)\n    \"\"\"\n    effective_bw = processing_bandwidth_hz / overhead_factor\n    return int(effective_bw / bandwidth_per_beam_hz)\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.bandwidth.digital_beamformer_data_rate","title":"digital_beamformer_data_rate","text":"<pre><code>digital_beamformer_data_rate(n_elements: int, sample_rate_hz: float, bits_per_sample: int, n_channels: int = 2, overhead_factor: float = 1.25) -&gt; dict[str, float]\n</code></pre> <p>Calculate digital beamformer input data rate.</p> <p>Computes the raw data rate from ADCs into the digital beamformer.</p> PARAMETER DESCRIPTION <code>n_elements</code> <p>Number of array elements (each with ADC)</p> <p> TYPE: <code>int</code> </p> <code>sample_rate_hz</code> <p>ADC sample rate in Hz</p> <p> TYPE: <code>float</code> </p> <code>bits_per_sample</code> <p>Bits per sample (typically 12-16)</p> <p> TYPE: <code>int</code> </p> <code>n_channels</code> <p>Number of channels per element (2 for I/Q)</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>overhead_factor</code> <p>Protocol overhead (framing, sync, etc.)</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.25</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - raw_rate_bps: Raw data rate in bits/second - raw_rate_gbps: Raw data rate in Gbps - with_overhead_gbps: Rate including overhead - per_element_gbps: Rate per element</p> Source code in <code>src/phased_array_systems/models/digital/bandwidth.py</code> <pre><code>def digital_beamformer_data_rate(\n    n_elements: int,\n    sample_rate_hz: float,\n    bits_per_sample: int,\n    n_channels: int = 2,  # I and Q\n    overhead_factor: float = 1.25,\n) -&gt; dict[str, float]:\n    \"\"\"Calculate digital beamformer input data rate.\n\n    Computes the raw data rate from ADCs into the digital beamformer.\n\n    Args:\n        n_elements: Number of array elements (each with ADC)\n        sample_rate_hz: ADC sample rate in Hz\n        bits_per_sample: Bits per sample (typically 12-16)\n        n_channels: Number of channels per element (2 for I/Q)\n        overhead_factor: Protocol overhead (framing, sync, etc.)\n\n    Returns:\n        Dictionary with:\n            - raw_rate_bps: Raw data rate in bits/second\n            - raw_rate_gbps: Raw data rate in Gbps\n            - with_overhead_gbps: Rate including overhead\n            - per_element_gbps: Rate per element\n    \"\"\"\n    raw_rate_bps = n_elements * sample_rate_hz * bits_per_sample * n_channels\n    raw_rate_gbps = raw_rate_bps / 1e9\n    with_overhead_gbps = raw_rate_gbps * overhead_factor\n    per_element_gbps = with_overhead_gbps / n_elements\n\n    return {\n        \"raw_rate_bps\": raw_rate_bps,\n        \"raw_rate_gbps\": raw_rate_gbps,\n        \"with_overhead_gbps\": with_overhead_gbps,\n        \"per_element_gbps\": per_element_gbps,\n        \"n_elements\": n_elements,\n        \"sample_rate_hz\": sample_rate_hz,\n        \"bits_per_sample\": bits_per_sample,\n    }\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.bandwidth.channelizer_output_rate","title":"channelizer_output_rate","text":"<pre><code>channelizer_output_rate(input_bandwidth_hz: float, n_channels: int, overlap_factor: float = 1.0, bits_per_output: int = 32) -&gt; dict[str, float]\n</code></pre> <p>Calculate polyphase channelizer output data rate.</p> <p>A channelizer divides a wideband input into narrowband channels. Output rate depends on channel count and overlap.</p> PARAMETER DESCRIPTION <code>input_bandwidth_hz</code> <p>Total input bandwidth</p> <p> TYPE: <code>float</code> </p> <code>n_channels</code> <p>Number of output channels</p> <p> TYPE: <code>int</code> </p> <code>overlap_factor</code> <p>Channel overlap (1.0 = no overlap, 2.0 = 50% overlap)</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>bits_per_output</code> <p>Bits per output sample (32 for complex float)</p> <p> TYPE: <code>int</code> DEFAULT: <code>32</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - channel_bandwidth_hz: Bandwidth per channel - channel_sample_rate_hz: Sample rate per channel - output_rate_gbps: Total output data rate - samples_per_channel_per_sec: Output samples per channel</p> Source code in <code>src/phased_array_systems/models/digital/bandwidth.py</code> <pre><code>def channelizer_output_rate(\n    input_bandwidth_hz: float,\n    n_channels: int,\n    overlap_factor: float = 1.0,\n    bits_per_output: int = 32,  # Complex float\n) -&gt; dict[str, float]:\n    \"\"\"Calculate polyphase channelizer output data rate.\n\n    A channelizer divides a wideband input into narrowband channels.\n    Output rate depends on channel count and overlap.\n\n    Args:\n        input_bandwidth_hz: Total input bandwidth\n        n_channels: Number of output channels\n        overlap_factor: Channel overlap (1.0 = no overlap, 2.0 = 50% overlap)\n        bits_per_output: Bits per output sample (32 for complex float)\n\n    Returns:\n        Dictionary with:\n            - channel_bandwidth_hz: Bandwidth per channel\n            - channel_sample_rate_hz: Sample rate per channel\n            - output_rate_gbps: Total output data rate\n            - samples_per_channel_per_sec: Output samples per channel\n    \"\"\"\n    channel_bandwidth_hz = input_bandwidth_hz / n_channels\n    channel_sample_rate_hz = channel_bandwidth_hz * overlap_factor\n\n    total_output_samples = n_channels * channel_sample_rate_hz\n    output_rate_bps = total_output_samples * bits_per_output * 2  # Complex\n    output_rate_gbps = output_rate_bps / 1e9\n\n    return {\n        \"channel_bandwidth_hz\": channel_bandwidth_hz,\n        \"channel_sample_rate_hz\": channel_sample_rate_hz,\n        \"output_rate_gbps\": output_rate_gbps,\n        \"samples_per_channel_per_sec\": channel_sample_rate_hz,\n        \"n_channels\": n_channels,\n        \"input_bandwidth_hz\": input_bandwidth_hz,\n    }\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.bandwidth.processing_margin","title":"processing_margin","text":"<pre><code>processing_margin(available_throughput_gops: float, required_throughput_gops: float) -&gt; dict[str, float]\n</code></pre> <p>Calculate processing margin for digital beamformer.</p> <p>Compares available FPGA/GPU throughput against requirements.</p> PARAMETER DESCRIPTION <code>available_throughput_gops</code> <p>Available processing (Giga-ops/sec)</p> <p> TYPE: <code>float</code> </p> <code>required_throughput_gops</code> <p>Required processing (Giga-ops/sec)</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - margin_ratio: Available / Required (&gt;1 is good) - margin_db: Margin in dB - utilization_percent: Percentage of capacity used - headroom_percent: Remaining capacity</p> Source code in <code>src/phased_array_systems/models/digital/bandwidth.py</code> <pre><code>def processing_margin(\n    available_throughput_gops: float,\n    required_throughput_gops: float,\n) -&gt; dict[str, float]:\n    \"\"\"Calculate processing margin for digital beamformer.\n\n    Compares available FPGA/GPU throughput against requirements.\n\n    Args:\n        available_throughput_gops: Available processing (Giga-ops/sec)\n        required_throughput_gops: Required processing (Giga-ops/sec)\n\n    Returns:\n        Dictionary with:\n            - margin_ratio: Available / Required (&gt;1 is good)\n            - margin_db: Margin in dB\n            - utilization_percent: Percentage of capacity used\n            - headroom_percent: Remaining capacity\n    \"\"\"\n    margin_ratio = available_throughput_gops / required_throughput_gops\n    margin_db = 10 * math.log10(margin_ratio) if margin_ratio &gt; 0 else float('-inf')\n    utilization_percent = (required_throughput_gops / available_throughput_gops) * 100\n    headroom_percent = 100 - utilization_percent\n\n    return {\n        \"margin_ratio\": margin_ratio,\n        \"margin_db\": margin_db,\n        \"utilization_percent\": utilization_percent,\n        \"headroom_percent\": headroom_percent,\n        \"available_gops\": available_throughput_gops,\n        \"required_gops\": required_throughput_gops,\n    }\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.bandwidth.beamformer_operations","title":"beamformer_operations","text":"<pre><code>beamformer_operations(n_elements: int, n_beams: int, sample_rate_hz: float, fft_size: int = 0) -&gt; dict[str, float]\n</code></pre> <p>Estimate digital beamformer computational requirements.</p> <p>Calculates operations per second for time-domain or frequency-domain beamforming.</p> PARAMETER DESCRIPTION <code>n_elements</code> <p>Number of array elements</p> <p> TYPE: <code>int</code> </p> <code>n_beams</code> <p>Number of simultaneous beams</p> <p> TYPE: <code>int</code> </p> <code>sample_rate_hz</code> <p>Sample rate in Hz</p> <p> TYPE: <code>float</code> </p> <code>fft_size</code> <p>FFT size (0 for time-domain beamforming)</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - complex_mults_per_sec: Complex multiplications/sec - complex_adds_per_sec: Complex additions/sec - total_gops: Total Giga-operations/sec - method: 'time_domain' or 'frequency_domain'</p> Source code in <code>src/phased_array_systems/models/digital/bandwidth.py</code> <pre><code>def beamformer_operations(\n    n_elements: int,\n    n_beams: int,\n    sample_rate_hz: float,\n    fft_size: int = 0,\n) -&gt; dict[str, float]:\n    \"\"\"Estimate digital beamformer computational requirements.\n\n    Calculates operations per second for time-domain or frequency-domain\n    beamforming.\n\n    Args:\n        n_elements: Number of array elements\n        n_beams: Number of simultaneous beams\n        sample_rate_hz: Sample rate in Hz\n        fft_size: FFT size (0 for time-domain beamforming)\n\n    Returns:\n        Dictionary with:\n            - complex_mults_per_sec: Complex multiplications/sec\n            - complex_adds_per_sec: Complex additions/sec\n            - total_gops: Total Giga-operations/sec\n            - method: 'time_domain' or 'frequency_domain'\n    \"\"\"\n    if fft_size &gt; 0:\n        # Frequency-domain: FFT + multiply + IFFT\n        # FFT ops \u2248 5 * N * log2(N) per transform\n        fft_ops = 5 * fft_size * math.log2(fft_size)\n        transforms_per_sec = sample_rate_hz / fft_size\n\n        # Per beam: FFT(input) + N_elem multiplies + IFFT(output)\n        fft_total_ops = transforms_per_sec * fft_ops * n_elements  # Input FFTs\n        mult_ops = transforms_per_sec * fft_size * n_elements * n_beams\n        ifft_ops = transforms_per_sec * fft_ops * n_beams  # Output IFFTs\n\n        total_ops = fft_total_ops + mult_ops + ifft_ops\n        method = \"frequency_domain\"\n    else:\n        # Time-domain: weight and sum per sample\n        # Each beam: N_elements complex multiplies + (N_elements-1) adds\n        mults_per_sample = n_elements * n_beams\n        adds_per_sample = (n_elements - 1) * n_beams\n\n        complex_mults_per_sec = mults_per_sample * sample_rate_hz\n        complex_adds_per_sec = adds_per_sample * sample_rate_hz\n\n        # Complex mult \u2248 6 real ops, complex add \u2248 2 real ops\n        total_ops = complex_mults_per_sec * 6 + complex_adds_per_sec * 2\n        method = \"time_domain\"\n\n    total_gops = total_ops / 1e9\n\n    return {\n        \"total_gops\": total_gops,\n        \"total_ops_per_sec\": total_ops,\n        \"method\": method,\n        \"n_elements\": n_elements,\n        \"n_beams\": n_beams,\n        \"sample_rate_hz\": sample_rate_hz,\n    }\n</code></pre>"},{"location":"api/models/digital/#scheduling","title":"Scheduling","text":"<p>Classes and functions for timeline and scheduling in multi-function arrays.</p>"},{"location":"api/models/digital/#classes","title":"Classes","text":""},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.Function","title":"Function","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Array function types for multi-function scheduling.</p>"},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.Dwell","title":"Dwell  <code>dataclass</code>","text":"<pre><code>Dwell(function: Function, duration_us: float, azimuth_deg: float = 0.0, elevation_deg: float = 0.0, bandwidth_hz: float = 0.0, priority: int = 1, metadata: dict = dict())\n</code></pre> <p>A single dwell (beam position) in the timeline.</p> ATTRIBUTE DESCRIPTION <code>function</code> <p>Type of function being performed</p> <p> TYPE: <code>Function</code> </p> <code>duration_us</code> <p>Dwell duration in microseconds</p> <p> TYPE: <code>float</code> </p> <code>azimuth_deg</code> <p>Beam azimuth angle in degrees</p> <p> TYPE: <code>float</code> </p> <code>elevation_deg</code> <p>Beam elevation angle in degrees</p> <p> TYPE: <code>float</code> </p> <code>bandwidth_hz</code> <p>Instantaneous bandwidth for this dwell</p> <p> TYPE: <code>float</code> </p> <code>priority</code> <p>Scheduling priority (higher = more important)</p> <p> TYPE: <code>int</code> </p> <code>metadata</code> <p>Additional function-specific parameters</p> <p> TYPE: <code>dict</code> </p>"},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.Dwell.duration_ms","title":"duration_ms  <code>property</code>","text":"<pre><code>duration_ms: float\n</code></pre> <p>Duration in milliseconds.</p>"},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.Dwell.duration_s","title":"duration_s  <code>property</code>","text":"<pre><code>duration_s: float\n</code></pre> <p>Duration in seconds.</p>"},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.Timeline","title":"Timeline  <code>dataclass</code>","text":"<pre><code>Timeline(dwells: list[Dwell], frame_time_ms: float, name: str = '')\n</code></pre> <p>A complete timeline of dwells over a frame period.</p> ATTRIBUTE DESCRIPTION <code>dwells</code> <p>List of dwells in chronological order</p> <p> TYPE: <code>list[Dwell]</code> </p> <code>frame_time_ms</code> <p>Total frame duration in milliseconds</p> <p> TYPE: <code>float</code> </p> <code>name</code> <p>Optional timeline identifier</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.Timeline.total_dwell_time_ms","title":"total_dwell_time_ms  <code>property</code>","text":"<pre><code>total_dwell_time_ms: float\n</code></pre> <p>Sum of all dwell durations.</p>"},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.Timeline.n_dwells","title":"n_dwells  <code>property</code>","text":"<pre><code>n_dwells: int\n</code></pre> <p>Number of dwells in timeline.</p>"},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.Timeline.dwells_by_function","title":"dwells_by_function","text":"<pre><code>dwells_by_function(function: Function) -&gt; list[Dwell]\n</code></pre> <p>Get all dwells for a specific function.</p> Source code in <code>src/phased_array_systems/models/digital/scheduling.py</code> <pre><code>def dwells_by_function(self, function: Function) -&gt; list[Dwell]:\n    \"\"\"Get all dwells for a specific function.\"\"\"\n    return [d for d in self.dwells if d.function == function]\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.Timeline.time_for_function","title":"time_for_function","text":"<pre><code>time_for_function(function: Function) -&gt; float\n</code></pre> <p>Total time allocated to a function in ms.</p> Source code in <code>src/phased_array_systems/models/digital/scheduling.py</code> <pre><code>def time_for_function(self, function: Function) -&gt; float:\n    \"\"\"Total time allocated to a function in ms.\"\"\"\n    return sum(d.duration_ms for d in self.dwells_by_function(function))\n</code></pre>"},{"location":"api/models/digital/#functions","title":"Functions","text":""},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.timeline_utilization","title":"timeline_utilization","text":"<pre><code>timeline_utilization(timeline: Timeline) -&gt; dict[str, float]\n</code></pre> <p>Calculate timeline utilization metrics.</p> <p>Analyzes how efficiently the timeline uses available time and breaks down allocation by function.</p> PARAMETER DESCRIPTION <code>timeline</code> <p>Timeline object to analyze</p> <p> TYPE: <code>Timeline</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - total_utilization: Fraction of frame time used (0-1) - idle_time_ms: Unused time in milliseconds - by_function: Dict of function -&gt; time allocation - by_function_percent: Dict of function -&gt; percentage</p> Source code in <code>src/phased_array_systems/models/digital/scheduling.py</code> <pre><code>def timeline_utilization(timeline: Timeline) -&gt; dict[str, float]:\n    \"\"\"Calculate timeline utilization metrics.\n\n    Analyzes how efficiently the timeline uses available time\n    and breaks down allocation by function.\n\n    Args:\n        timeline: Timeline object to analyze\n\n    Returns:\n        Dictionary with:\n            - total_utilization: Fraction of frame time used (0-1)\n            - idle_time_ms: Unused time in milliseconds\n            - by_function: Dict of function -&gt; time allocation\n            - by_function_percent: Dict of function -&gt; percentage\n    \"\"\"\n    total_dwell_ms = timeline.total_dwell_time_ms\n    idle_time_ms = max(0, timeline.frame_time_ms - total_dwell_ms)\n    utilization = total_dwell_ms / timeline.frame_time_ms if timeline.frame_time_ms &gt; 0 else 0\n\n    # Breakdown by function\n    by_function = {}\n    by_function_percent = {}\n\n    for func in Function:\n        time_ms = timeline.time_for_function(func)\n        by_function[func.value] = time_ms\n        by_function_percent[func.value] = (time_ms / timeline.frame_time_ms * 100) if timeline.frame_time_ms &gt; 0 else 0\n\n    return {\n        \"total_utilization\": utilization,\n        \"total_dwell_time_ms\": total_dwell_ms,\n        \"idle_time_ms\": idle_time_ms,\n        \"frame_time_ms\": timeline.frame_time_ms,\n        \"n_dwells\": timeline.n_dwells,\n        \"by_function\": by_function,\n        \"by_function_percent\": by_function_percent,\n    }\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.max_update_rate","title":"max_update_rate","text":"<pre><code>max_update_rate(scan_volume_sr: float, beam_solid_angle_sr: float, dwell_time_us: float, overhead_us: float = 10.0) -&gt; dict[str, float]\n</code></pre> <p>Calculate maximum volume update rate for search.</p> <p>Determines how quickly a phased array can search a given volume.</p> PARAMETER DESCRIPTION <code>scan_volume_sr</code> <p>Search volume in steradians</p> <p> TYPE: <code>float</code> </p> <code>beam_solid_angle_sr</code> <p>Beam solid angle in steradians (\u2248 \u03b8_az * \u03b8_el)</p> <p> TYPE: <code>float</code> </p> <code>dwell_time_us</code> <p>Time per beam position in microseconds</p> <p> TYPE: <code>float</code> </p> <code>overhead_us</code> <p>Beam switching overhead in microseconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>10.0</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - n_beam_positions: Number of beams to cover volume - frame_time_ms: Time to complete one scan - update_rate_hz: Volume scans per second - scan_time_s: Time for one complete scan</p> Source code in <code>src/phased_array_systems/models/digital/scheduling.py</code> <pre><code>def max_update_rate(\n    scan_volume_sr: float,\n    beam_solid_angle_sr: float,\n    dwell_time_us: float,\n    overhead_us: float = 10.0,\n) -&gt; dict[str, float]:\n    \"\"\"Calculate maximum volume update rate for search.\n\n    Determines how quickly a phased array can search a given volume.\n\n    Args:\n        scan_volume_sr: Search volume in steradians\n        beam_solid_angle_sr: Beam solid angle in steradians (\u2248 \u03b8_az * \u03b8_el)\n        dwell_time_us: Time per beam position in microseconds\n        overhead_us: Beam switching overhead in microseconds\n\n    Returns:\n        Dictionary with:\n            - n_beam_positions: Number of beams to cover volume\n            - frame_time_ms: Time to complete one scan\n            - update_rate_hz: Volume scans per second\n            - scan_time_s: Time for one complete scan\n    \"\"\"\n    n_beam_positions = math.ceil(scan_volume_sr / beam_solid_angle_sr)\n    time_per_position_us = dwell_time_us + overhead_us\n    frame_time_us = n_beam_positions * time_per_position_us\n    frame_time_ms = frame_time_us / 1000\n    scan_time_s = frame_time_us / 1e6\n    update_rate_hz = 1 / scan_time_s if scan_time_s &gt; 0 else float('inf')\n\n    return {\n        \"n_beam_positions\": n_beam_positions,\n        \"frame_time_ms\": frame_time_ms,\n        \"scan_time_s\": scan_time_s,\n        \"update_rate_hz\": update_rate_hz,\n        \"time_per_position_us\": time_per_position_us,\n    }\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.search_timeline","title":"search_timeline","text":"<pre><code>search_timeline(azimuth_range_deg: tuple[float, float], elevation_range_deg: tuple[float, float], azimuth_step_deg: float, elevation_step_deg: float, dwell_time_us: float, function: Function = RADAR_SEARCH) -&gt; Timeline\n</code></pre> <p>Generate a raster search timeline.</p> <p>Creates a timeline of dwells covering a rectangular search volume using a raster scan pattern.</p> PARAMETER DESCRIPTION <code>azimuth_range_deg</code> <p>(min, max) azimuth in degrees</p> <p> TYPE: <code>tuple[float, float]</code> </p> <code>elevation_range_deg</code> <p>(min, max) elevation in degrees</p> <p> TYPE: <code>tuple[float, float]</code> </p> <code>azimuth_step_deg</code> <p>Azimuth step between beams</p> <p> TYPE: <code>float</code> </p> <code>elevation_step_deg</code> <p>Elevation step between beams</p> <p> TYPE: <code>float</code> </p> <code>dwell_time_us</code> <p>Dwell time per position</p> <p> TYPE: <code>float</code> </p> <code>function</code> <p>Function type for dwells</p> <p> TYPE: <code>Function</code> DEFAULT: <code>RADAR_SEARCH</code> </p> RETURNS DESCRIPTION <code>Timeline</code> <p>Timeline with search dwells</p> Source code in <code>src/phased_array_systems/models/digital/scheduling.py</code> <pre><code>def search_timeline(\n    azimuth_range_deg: tuple[float, float],\n    elevation_range_deg: tuple[float, float],\n    azimuth_step_deg: float,\n    elevation_step_deg: float,\n    dwell_time_us: float,\n    function: Function = Function.RADAR_SEARCH,\n) -&gt; Timeline:\n    \"\"\"Generate a raster search timeline.\n\n    Creates a timeline of dwells covering a rectangular search volume\n    using a raster scan pattern.\n\n    Args:\n        azimuth_range_deg: (min, max) azimuth in degrees\n        elevation_range_deg: (min, max) elevation in degrees\n        azimuth_step_deg: Azimuth step between beams\n        elevation_step_deg: Elevation step between beams\n        dwell_time_us: Dwell time per position\n        function: Function type for dwells\n\n    Returns:\n        Timeline with search dwells\n    \"\"\"\n    dwells = []\n\n    az_min, az_max = azimuth_range_deg\n    el_min, el_max = elevation_range_deg\n\n    el = el_min\n    row = 0\n    while el &lt;= el_max:\n        # Alternate scan direction for efficiency\n        if row % 2 == 0:\n            az_range = _frange(az_min, az_max, azimuth_step_deg)\n        else:\n            az_range = _frange(az_max, az_min, -azimuth_step_deg)\n\n        for az in az_range:\n            dwell = Dwell(\n                function=function,\n                duration_us=dwell_time_us,\n                azimuth_deg=az,\n                elevation_deg=el,\n            )\n            dwells.append(dwell)\n\n        el += elevation_step_deg\n        row += 1\n\n    total_time_ms = sum(d.duration_ms for d in dwells)\n\n    return Timeline(\n        dwells=dwells,\n        frame_time_ms=total_time_ms,\n        name=f\"Search {az_min:.0f}:{az_max:.0f} az, {el_min:.0f}:{el_max:.0f} el\",\n    )\n</code></pre>"},{"location":"api/models/digital/#phased_array_systems.models.digital.scheduling.interleaved_timeline","title":"interleaved_timeline","text":"<pre><code>interleaved_timeline(functions: list[dict], frame_time_ms: float) -&gt; Timeline\n</code></pre> <p>Generate an interleaved multi-function timeline.</p> <p>Creates a timeline that allocates time to multiple functions based on specified priorities and time allocations.</p> PARAMETER DESCRIPTION <code>functions</code> <p>List of dicts with: - function: Function enum value - time_percent: Percentage of frame time - dwell_time_us: Duration of each dwell - dwells_per_burst: Number of consecutive dwells</p> <p> TYPE: <code>list[dict]</code> </p> <code>frame_time_ms</code> <p>Total frame duration</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Timeline</code> <p>Timeline with interleaved function dwells</p> Source code in <code>src/phased_array_systems/models/digital/scheduling.py</code> <pre><code>def interleaved_timeline(\n    functions: list[dict],\n    frame_time_ms: float,\n) -&gt; Timeline:\n    \"\"\"Generate an interleaved multi-function timeline.\n\n    Creates a timeline that allocates time to multiple functions\n    based on specified priorities and time allocations.\n\n    Args:\n        functions: List of dicts with:\n            - function: Function enum value\n            - time_percent: Percentage of frame time\n            - dwell_time_us: Duration of each dwell\n            - dwells_per_burst: Number of consecutive dwells\n        frame_time_ms: Total frame duration\n\n    Returns:\n        Timeline with interleaved function dwells\n    \"\"\"\n    dwells = []\n\n    # Calculate time budget for each function\n    for func_spec in functions:\n        func = func_spec[\"function\"]\n        time_budget_ms = frame_time_ms * func_spec[\"time_percent\"] / 100\n        dwell_time_us = func_spec[\"dwell_time_us\"]\n\n        # How many dwells fit in budget?\n        dwell_time_ms = dwell_time_us / 1000\n        n_dwells = int(time_budget_ms / dwell_time_ms)\n\n        # Create dwells (simple placeholder positions)\n        for _ in range(n_dwells):\n            dwell = Dwell(\n                function=func,\n                duration_us=dwell_time_us,\n                azimuth_deg=0.0,  # Would be populated by scheduler\n                elevation_deg=0.0,\n                priority=func_spec.get(\"priority\", 1),\n            )\n            dwells.append(dwell)\n\n    # Sort by priority (higher priority dwells interleaved more frequently)\n    # This is a simplified scheduling - real systems use more sophisticated algorithms\n    dwells.sort(key=lambda d: -d.priority)\n\n    return Timeline(\n        dwells=dwells,\n        frame_time_ms=frame_time_ms,\n        name=\"Interleaved multi-function\",\n    )\n</code></pre>"},{"location":"api/models/digital/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/digital/#adc-performance-analysis","title":"ADC Performance Analysis","text":"<pre><code>from phased_array_systems.models.digital import (\n    enob_to_snr,\n    adc_dynamic_range,\n    sample_rate_for_bandwidth,\n)\n\n# 14-bit ADC analysis\nenob = 14\nsnr = enob_to_snr(enob)\nprint(f\"Ideal SNR: {snr:.1f} dB\")  # 86.0 dB\n\n# Dynamic range with front-end noise\nresult = adc_dynamic_range(\n    enob=14,\n    noise_figure_db=3,\n    bandwidth_hz=100e6\n)\nprint(f\"Dynamic Range: {result['dynamic_range_db']:.1f} dB\")\n\n# Sample rate for 100 MHz signal\nfs = sample_rate_for_bandwidth(100e6)\nprint(f\"Required Sample Rate: {fs/1e6:.0f} MHz\")  # 250 MHz\n</code></pre>"},{"location":"api/models/digital/#digital-beamformer-data-rate","title":"Digital Beamformer Data Rate","text":"<pre><code>from phased_array_systems.models.digital import (\n    digital_beamformer_data_rate,\n    beam_bandwidth_product,\n    max_simultaneous_beams,\n)\n\n# 256-element array with 1 GSPS ADCs\nresult = digital_beamformer_data_rate(\n    n_elements=256,\n    sample_rate_hz=1e9,\n    bits_per_sample=14,\n)\nprint(f\"Total Data Rate: {result['with_overhead_gbps']:.1f} Gbps\")\n\n# How many beams with 10 GHz processing bandwidth?\nn_beams = max_simultaneous_beams(\n    processing_bandwidth_hz=10e9,\n    bandwidth_per_beam_hz=100e6,\n)\nprint(f\"Max Simultaneous Beams: {n_beams}\")\n</code></pre>"},{"location":"api/models/digital/#radar-search-timeline","title":"Radar Search Timeline","text":"<pre><code>from phased_array_systems.models.digital import (\n    search_timeline,\n    timeline_utilization,\n    max_update_rate,\n)\n\n# Generate raster search pattern\ntl = search_timeline(\n    azimuth_range_deg=(-60, 60),\n    elevation_range_deg=(0, 30),\n    azimuth_step_deg=3.0,\n    elevation_step_deg=3.0,\n    dwell_time_us=100,\n)\nprint(f\"Search requires {tl.n_dwells} beam positions\")\n\n# Analyze utilization\nutil = timeline_utilization(tl)\nprint(f\"Frame time: {util['frame_time_ms']:.1f} ms\")\nprint(f\"Utilization: {util['total_utilization']*100:.1f}%\")\n</code></pre>"},{"location":"api/models/digital/#multi-function-interleaved-timeline","title":"Multi-Function Interleaved Timeline","text":"<pre><code>from phased_array_systems.models.digital import (\n    Function,\n    interleaved_timeline,\n    timeline_utilization,\n)\n\n# Create interleaved search/track timeline\ntl = interleaved_timeline(\n    functions=[\n        {\"function\": Function.RADAR_SEARCH, \"time_percent\": 60,\n         \"dwell_time_us\": 100, \"priority\": 1},\n        {\"function\": Function.RADAR_TRACK, \"time_percent\": 30,\n         \"dwell_time_us\": 50, \"priority\": 2},\n        {\"function\": Function.ESM, \"time_percent\": 10,\n         \"dwell_time_us\": 200, \"priority\": 1},\n    ],\n    frame_time_ms=100,\n)\n\nutil = timeline_utilization(tl)\nprint(f\"Search allocation: {util['by_function_percent']['radar_search']:.1f}%\")\nprint(f\"Track allocation: {util['by_function_percent']['radar_track']:.1f}%\")\n</code></pre>"},{"location":"api/models/digital/#key-equations","title":"Key Equations","text":""},{"location":"api/models/digital/#enob-snr-relationship","title":"ENOB-SNR Relationship","text":"\\[ SNR = 6.02 \\times ENOB + 1.76 \\text{ dB} \\]"},{"location":"api/models/digital/#quantization-noise-floor","title":"Quantization Noise Floor","text":"\\[ N_{floor} = P_{fs} - SNR - 10\\log_{10}\\left(\\frac{f_s}{2}\\right) \\text{ dBm/Hz} \\]"},{"location":"api/models/digital/#beam-bandwidth-product","title":"Beam-Bandwidth Product","text":"\\[ BBP = N_{beams} \\times BW_{per\\_beam} \\]"},{"location":"api/models/digital/#digital-beamformer-data-rate_1","title":"Digital Beamformer Data Rate","text":"\\[ R_{data} = N_{elements} \\times f_s \\times bits \\times N_{channels} \\times overhead \\]"},{"location":"api/models/digital/#see-also","title":"See Also","text":"<ul> <li>RF Models - RF cascade analysis</li> <li>Radar Models - Radar detection calculations</li> <li>Theory: Phased Arrays</li> </ul>"},{"location":"api/models/radar/","title":"Radar Models API","text":"<p>Radar equation and detection probability calculations.</p>"},{"location":"api/models/radar/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.models.radar import (\n    RadarModel,\n    compute_detection_threshold,\n    compute_pd_from_snr,\n    compute_snr_for_pd,\n    albersheim_snr,\n    coherent_integration_gain,\n    noncoherent_integration_gain,\n    integration_loss,\n)\n</code></pre>"},{"location":"api/models/radar/#classes","title":"Classes","text":""},{"location":"api/models/radar/#phased_array_systems.models.radar.equation.RadarModel","title":"RadarModel","text":"<p>Radar range equation calculator.</p> <p>Implements the monostatic radar range equation:</p> <pre><code>P_r = (P_t * G^2 * \u03bb^2 * \u03c3) / ((4\u03c0)^3 * R^4 * L_sys)\n</code></pre> Or in dB form <p>SNR = P_t + 2G + 2\u03bb_dB + \u03c3_dBsm - 4*R_dB - L_sys - (4\u03c0)^3_dB - N_dB</p> Where <p>P_t = Peak transmit power (W) G = Antenna gain (same for Tx/Rx in monostatic) \u03bb = Wavelength (m) \u03c3 = Target radar cross section (m^2) R = Range to target (m) L_sys = System losses N = Noise power = kTB</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Model block name for identification</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/models/radar/#phased_array_systems.models.radar.equation.RadarModel.evaluate","title":"evaluate","text":"<pre><code>evaluate(arch: Architecture, scenario: RadarDetectionScenario, context: dict[str, Any]) -&gt; MetricsDict\n</code></pre> <p>Evaluate radar detection performance.</p> PARAMETER DESCRIPTION <code>arch</code> <p>Architecture configuration</p> <p> TYPE: <code>Architecture</code> </p> <code>scenario</code> <p>Radar detection scenario</p> <p> TYPE: <code>RadarDetectionScenario</code> </p> <code>context</code> <p>Additional context (may include antenna metrics): - g_peak_db: Antenna gain (uses this if provided) - scan_loss_db: Scan loss (uses this if provided)</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>MetricsDict</code> <p>Dictionary with radar metrics: - peak_power_w: Peak transmit power (W) - peak_power_dbw: Peak transmit power (dBW) - g_ant_db: Antenna gain (dB) - wavelength_m: Wavelength (m) - target_rcs_dbsm: Target RCS (dBsm) - target_rcs_m2: Target RCS (m^2) - range_m: Target range (m) - noise_power_dbw: Noise power (dBW) - snr_single_pulse_db: Single-pulse SNR (dB) - integration_gain_db: Integration gain (dB) - snr_integrated_db: Integrated SNR (dB) - snr_required_db: Required SNR for Pd/Pfa (dB) - snr_margin_db: SNR margin (dB) - pd_achieved: Achieved probability of detection - detection_range_m: Max detection range for required Pd (m)</p> Source code in <code>src/phased_array_systems/models/radar/equation.py</code> <pre><code>def evaluate(\n    self,\n    arch: Architecture,\n    scenario: RadarDetectionScenario,\n    context: dict[str, Any],\n) -&gt; MetricsDict:\n    \"\"\"Evaluate radar detection performance.\n\n    Args:\n        arch: Architecture configuration\n        scenario: Radar detection scenario\n        context: Additional context (may include antenna metrics):\n            - g_peak_db: Antenna gain (uses this if provided)\n            - scan_loss_db: Scan loss (uses this if provided)\n\n    Returns:\n        Dictionary with radar metrics:\n            - peak_power_w: Peak transmit power (W)\n            - peak_power_dbw: Peak transmit power (dBW)\n            - g_ant_db: Antenna gain (dB)\n            - wavelength_m: Wavelength (m)\n            - target_rcs_dbsm: Target RCS (dBsm)\n            - target_rcs_m2: Target RCS (m^2)\n            - range_m: Target range (m)\n            - noise_power_dbw: Noise power (dBW)\n            - snr_single_pulse_db: Single-pulse SNR (dB)\n            - integration_gain_db: Integration gain (dB)\n            - snr_integrated_db: Integrated SNR (dB)\n            - snr_required_db: Required SNR for Pd/Pfa (dB)\n            - snr_margin_db: SNR margin (dB)\n            - pd_achieved: Achieved probability of detection\n            - detection_range_m: Max detection range for required Pd (m)\n    \"\"\"\n    # Get antenna gain from context or compute approximate\n    if \"g_peak_db\" in context:\n        g_ant_db = context[\"g_peak_db\"]\n        # Apply scan loss if provided\n        if \"scan_loss_db\" in context:\n            g_ant_db -= context[\"scan_loss_db\"]\n    else:\n        # Approximate gain for uniform rectangular array\n        # G \u2248 4*pi*A/\u03bb^2 = 4*pi * (nx*dx) * (ny*dy) when spacing in wavelengths\n        aperture_lambda_sq = (\n            arch.array.nx * arch.array.dx_lambda * arch.array.ny * arch.array.dy_lambda\n        )\n        g_ant_linear = 4 * math.pi * aperture_lambda_sq\n        g_ant_db = 10 * math.log10(g_ant_linear)\n\n    # Transmit power (peak)\n    n_elements = arch.array.n_elements\n    peak_power_w = arch.rf.tx_power_w_per_elem * n_elements\n    peak_power_dbw = W_TO_DBW(peak_power_w)\n\n    # Wavelength\n    wavelength_m = C_LIGHT / scenario.freq_hz\n    wavelength_db = 10 * math.log10(wavelength_m)\n\n    # System losses (feed network + additional system losses)\n    system_loss_db = arch.rf.feed_loss_db + arch.rf.system_loss_db\n\n    # Target RCS\n    rcs_dbsm = scenario.target_rcs_dbsm\n    rcs_m2 = 10 ** (rcs_dbsm / 10)\n\n    # Range\n    range_m = scenario.range_m\n    range_db = 10 * math.log10(range_m)\n\n    # Noise power: N = kTB\n    noise_temp_k = scenario.rx_noise_temp_k\n    noise_power_w = K_B * noise_temp_k * scenario.bandwidth_hz\n    noise_power_dbw = W_TO_DBW(noise_power_w) + arch.rf.noise_figure_db\n\n    # Radar equation constant: (4\u03c0)^3 in dB\n    radar_constant_db = 30 * math.log10(4 * math.pi)  # \u2248 32.98 dB\n\n    # Single-pulse SNR (monostatic radar equation in dB)\n    # SNR = Pt + 2*G + 2*\u03bb_dB + \u03c3 - 4*R_dB - L - (4\u03c0)^3_dB - N\n    snr_single_db = (\n        peak_power_dbw\n        + 2 * g_ant_db\n        + 2 * wavelength_db\n        + rcs_dbsm\n        - 4 * range_db\n        - system_loss_db\n        - radar_constant_db\n        - noise_power_dbw\n    )\n\n    # Integration gain\n    n_pulses = scenario.n_pulses\n    if scenario.integration_type == \"coherent\":\n        integration_gain_db = coherent_integration_gain(n_pulses)\n    else:\n        integration_gain_db = noncoherent_integration_gain(\n            n_pulses, pd=scenario.pd_required, pfa=scenario.pfa\n        )\n\n    # Integrated SNR\n    snr_integrated_db = snr_single_db + integration_gain_db\n\n    # Required SNR for Pd/Pfa using Albersheim's equation\n    snr_required_db = albersheim_snr(\n        pd=scenario.pd_required,\n        pfa=scenario.pfa,\n        n_pulses=1,  # Integration gain already applied\n    )\n\n    # SNR margin\n    snr_margin_db = snr_integrated_db - snr_required_db\n\n    # Achieved Pd at the given range\n    pd_achieved = compute_pd_from_snr(\n        snr_integrated_db,\n        scenario.pfa,\n        swerling=0,  # Non-fluctuating\n        n_pulses=1,  # Already integrated\n        integration=\"coherent\",  # SNR already includes integration\n    )\n\n    # Detection range (range where margin = 0)\n    # From radar equation: R^4 proportional to SNR\n    # R_det / R = (SNR_integrated / SNR_required)^(1/4)\n    # In dB: R_det = R * 10^(margin_dB / 40)\n    detection_range_m = range_m * 10 ** (snr_margin_db / 40) if snr_margin_db &gt; -40 else 0.0\n\n    return {\n        # Power\n        \"peak_power_w\": peak_power_w,\n        \"peak_power_dbw\": peak_power_dbw,\n        # Antenna\n        \"g_ant_db\": g_ant_db,\n        # Target/Environment\n        \"wavelength_m\": wavelength_m,\n        \"target_rcs_dbsm\": rcs_dbsm,\n        \"target_rcs_m2\": rcs_m2,\n        \"range_m\": range_m,\n        # Noise\n        \"noise_power_dbw\": noise_power_dbw,\n        \"system_loss_db\": system_loss_db,\n        # SNR\n        \"snr_single_pulse_db\": snr_single_db,\n        \"integration_gain_db\": integration_gain_db,\n        \"snr_integrated_db\": snr_integrated_db,\n        \"snr_required_db\": snr_required_db,\n        \"snr_margin_db\": snr_margin_db,\n        # Detection\n        \"pd_achieved\": pd_achieved,\n        \"pd_required\": scenario.pd_required,\n        \"pfa\": scenario.pfa,\n        \"n_pulses\": n_pulses,\n        \"integration_type\": scenario.integration_type,\n        \"detection_range_m\": detection_range_m,\n    }\n</code></pre>"},{"location":"api/models/radar/#functions","title":"Functions","text":""},{"location":"api/models/radar/#phased_array_systems.models.radar.detection.compute_snr_for_pd","title":"compute_snr_for_pd","text":"<pre><code>compute_snr_for_pd(pd: float, pfa: float, swerling: SwerlingModel = 0, n_pulses: int = 1, integration: Literal['coherent', 'noncoherent'] = 'noncoherent') -&gt; float\n</code></pre> <p>Compute required SNR for given Pd and Pfa.</p> <p>Inverse of compute_pd_from_snr using numerical root finding.</p> PARAMETER DESCRIPTION <code>pd</code> <p>Required probability of detection (0 &lt; pd &lt; 1)</p> <p> TYPE: <code>float</code> </p> <code>pfa</code> <p>Probability of false alarm (0 &lt; pfa &lt; 1)</p> <p> TYPE: <code>float</code> </p> <code>swerling</code> <p>Swerling target model (0-4)</p> <p> TYPE: <code>SwerlingModel</code> DEFAULT: <code>0</code> </p> <code>n_pulses</code> <p>Number of pulses integrated</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>integration</code> <p>Integration type</p> <p> TYPE: <code>Literal['coherent', 'noncoherent']</code> DEFAULT: <code>'noncoherent'</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Required single-pulse SNR in dB</p> Source code in <code>src/phased_array_systems/models/radar/detection.py</code> <pre><code>def compute_snr_for_pd(\n    pd: float,\n    pfa: float,\n    swerling: SwerlingModel = 0,\n    n_pulses: int = 1,\n    integration: Literal[\"coherent\", \"noncoherent\"] = \"noncoherent\",\n) -&gt; float:\n    \"\"\"Compute required SNR for given Pd and Pfa.\n\n    Inverse of compute_pd_from_snr using numerical root finding.\n\n    Args:\n        pd: Required probability of detection (0 &lt; pd &lt; 1)\n        pfa: Probability of false alarm (0 &lt; pfa &lt; 1)\n        swerling: Swerling target model (0-4)\n        n_pulses: Number of pulses integrated\n        integration: Integration type\n\n    Returns:\n        Required single-pulse SNR in dB\n    \"\"\"\n    if not 0 &lt; pd &lt; 1:\n        raise ValueError(\"pd must be between 0 and 1\")\n    if not 0 &lt; pfa &lt; 1:\n        raise ValueError(\"pfa must be between 0 and 1\")\n\n    def objective(snr_db: float) -&gt; float:\n        pd_calc = compute_pd_from_snr(snr_db, pfa, swerling, n_pulses, integration)\n        return pd_calc - pd\n\n    # Use Albersheim as initial guess\n    snr_guess = albersheim_snr(pd, pfa, n_pulses)\n\n    try:\n        result = optimize.brentq(objective, snr_guess - 20, snr_guess + 20)\n        return result\n    except ValueError:\n        # If brentq fails, return Albersheim estimate\n        return snr_guess\n</code></pre>"},{"location":"api/models/radar/#phased_array_systems.models.radar.detection.compute_pd_from_snr","title":"compute_pd_from_snr","text":"<pre><code>compute_pd_from_snr(snr_db: float, pfa: float, swerling: SwerlingModel = 0, n_pulses: int = 1, integration: Literal['coherent', 'noncoherent'] = 'noncoherent') -&gt; float\n</code></pre> <p>Compute probability of detection for given SNR.</p> <p>Uses Marcum Q-function for Swerling 0 (non-fluctuating) targets.</p> PARAMETER DESCRIPTION <code>snr_db</code> <p>Signal-to-noise ratio per pulse (dB)</p> <p> TYPE: <code>float</code> </p> <code>pfa</code> <p>Probability of false alarm</p> <p> TYPE: <code>float</code> </p> <code>swerling</code> <p>Swerling target model (0 = non-fluctuating)</p> <p> TYPE: <code>SwerlingModel</code> DEFAULT: <code>0</code> </p> <code>n_pulses</code> <p>Number of pulses integrated</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>integration</code> <p>Integration type (\"coherent\" or \"noncoherent\")</p> <p> TYPE: <code>Literal['coherent', 'noncoherent']</code> DEFAULT: <code>'noncoherent'</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Probability of detection (0-1)</p> Source code in <code>src/phased_array_systems/models/radar/detection.py</code> <pre><code>def compute_pd_from_snr(\n    snr_db: float,\n    pfa: float,\n    swerling: SwerlingModel = 0,\n    n_pulses: int = 1,\n    integration: Literal[\"coherent\", \"noncoherent\"] = \"noncoherent\",\n) -&gt; float:\n    \"\"\"Compute probability of detection for given SNR.\n\n    Uses Marcum Q-function for Swerling 0 (non-fluctuating) targets.\n\n    Args:\n        snr_db: Signal-to-noise ratio per pulse (dB)\n        pfa: Probability of false alarm\n        swerling: Swerling target model (0 = non-fluctuating)\n        n_pulses: Number of pulses integrated\n        integration: Integration type (\"coherent\" or \"noncoherent\")\n\n    Returns:\n        Probability of detection (0-1)\n    \"\"\"\n    if not 0 &lt; pfa &lt; 1:\n        raise ValueError(\"pfa must be between 0 and 1\")\n\n    snr_linear = 10 ** (snr_db / 10)\n\n    # Apply integration gain\n    if integration == \"coherent\":\n        # Coherent integration: SNR scales linearly with n\n        snr_integrated = snr_linear * n_pulses\n    else:\n        # Non-coherent integration: approximate gain\n        # Using empirical formula: effective SNR \u2248 snr * n^0.8\n        snr_integrated = snr_linear * (n_pulses ** 0.8)\n\n    # Compute threshold from Pfa\n    threshold = compute_detection_threshold(pfa, n_samples=1)\n\n    # For Swerling 0 (non-fluctuating), use Marcum Q-function approximation\n    # Pd = Q(sqrt(2*SNR), sqrt(2*threshold))\n    # Using Rice distribution approximation\n    if swerling == 0:\n        # Marcum Q-function: Q_1(a, b) where a = sqrt(2*SNR), b = sqrt(threshold)\n        a = math.sqrt(2 * snr_integrated)\n        b = math.sqrt(2 * threshold)\n\n        # Approximate Marcum Q using modified Bessel function\n        # For high SNR, Pd \u2248 1 - 0.5 * erfc((a - b) / sqrt(2))\n        if a &gt; b:\n            pd = 0.5 * special.erfc((b - a) / math.sqrt(2))\n        else:\n            pd = 0.5 * special.erfc((b - a) / math.sqrt(2))\n\n        # Clamp to valid range\n        return max(0.0, min(1.0, pd))\n\n    elif swerling in (1, 2, 3, 4):\n        # Swerling models with fluctuating RCS\n        # Use empirical adjustment factors\n        if swerling == 1:\n            # Slow fluctuation, Rayleigh\n            factor = 1.0 + 1.0 / snr_integrated if snr_integrated &gt; 0 else 0\n        elif swerling == 2:\n            # Fast fluctuation, Rayleigh\n            factor = 1.0 + 0.5 / snr_integrated if snr_integrated &gt; 0 else 0\n        elif swerling == 3:\n            # Slow fluctuation, chi-squared (4 DOF)\n            factor = 1.0 + 2.0 / snr_integrated if snr_integrated &gt; 0 else 0\n        else:  # swerling == 4\n            # Fast fluctuation, chi-squared (4 DOF)\n            factor = 1.0 + 1.0 / snr_integrated if snr_integrated &gt; 0 else 0\n\n        # Adjusted threshold\n        adj_snr = snr_integrated / factor if factor &gt; 0 else snr_integrated\n        a = math.sqrt(2 * adj_snr)\n        b = math.sqrt(2 * threshold)\n        pd = 0.5 * special.erfc((b - a) / math.sqrt(2))\n        return max(0.0, min(1.0, pd))\n\n    else:\n        raise ValueError(f\"Unknown Swerling model: {swerling}\")\n</code></pre>"},{"location":"api/models/radar/#phased_array_systems.models.radar.detection.albersheim_snr","title":"albersheim_snr","text":"<pre><code>albersheim_snr(pd: float, pfa: float, n_pulses: int = 1) -&gt; float\n</code></pre> <p>Albersheim's equation for required SNR (Swerling 0).</p> <p>Empirical approximation valid for: - 0.1 &lt;= Pd &lt;= 0.99 - 1e-9 &lt;= Pfa &lt;= 1e-3 - 1 &lt;= n_pulses &lt;= 8096</p> PARAMETER DESCRIPTION <code>pd</code> <p>Probability of detection</p> <p> TYPE: <code>float</code> </p> <code>pfa</code> <p>Probability of false alarm</p> <p> TYPE: <code>float</code> </p> <code>n_pulses</code> <p>Number of pulses (non-coherent integration)</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Required single-pulse SNR in dB</p> Source code in <code>src/phased_array_systems/models/radar/detection.py</code> <pre><code>def albersheim_snr(\n    pd: float,\n    pfa: float,\n    n_pulses: int = 1,\n) -&gt; float:\n    \"\"\"Albersheim's equation for required SNR (Swerling 0).\n\n    Empirical approximation valid for:\n    - 0.1 &lt;= Pd &lt;= 0.99\n    - 1e-9 &lt;= Pfa &lt;= 1e-3\n    - 1 &lt;= n_pulses &lt;= 8096\n\n    Args:\n        pd: Probability of detection\n        pfa: Probability of false alarm\n        n_pulses: Number of pulses (non-coherent integration)\n\n    Returns:\n        Required single-pulse SNR in dB\n    \"\"\"\n    if not 0.1 &lt;= pd &lt;= 0.9999:\n        raise ValueError(\"pd must be between 0.1 and 0.9999 for Albersheim\")\n    if not 1e-10 &lt;= pfa &lt;= 0.1:\n        raise ValueError(\"pfa must be between 1e-10 and 0.1 for Albersheim\")\n    if n_pulses &lt; 1:\n        raise ValueError(\"n_pulses must be &gt;= 1\")\n\n    # Albersheim's equation\n    A = math.log(0.62 / pfa)\n    B = math.log(pd / (1 - pd))\n\n    # SNR required for n pulses (non-coherent integration)\n    snr_n_db = -5 * math.log10(n_pulses) + (6.2 + 4.54 / math.sqrt(n_pulses + 0.44)) * math.log10(\n        A + 0.12 * A * B + 1.7 * B\n    )\n\n    return snr_n_db\n</code></pre>"},{"location":"api/models/radar/#phased_array_systems.models.radar.integration.coherent_integration_gain","title":"coherent_integration_gain","text":"<pre><code>coherent_integration_gain(n_pulses: int) -&gt; float\n</code></pre> <p>Coherent integration gain in dB.</p> <p>Coherent integration (phase-preserving) provides full N-times improvement in SNR because signals add coherently while noise adds incoherently.</p> PARAMETER DESCRIPTION <code>n_pulses</code> <p>Number of pulses integrated (must be &gt;= 1)</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Integration gain in dB: 10 * log10(n_pulses)</p> RAISES DESCRIPTION <code>ValueError</code> <p>If n_pulses &lt; 1</p> Source code in <code>src/phased_array_systems/models/radar/integration.py</code> <pre><code>def coherent_integration_gain(n_pulses: int) -&gt; float:\n    \"\"\"Coherent integration gain in dB.\n\n    Coherent integration (phase-preserving) provides full N-times\n    improvement in SNR because signals add coherently while noise\n    adds incoherently.\n\n    Args:\n        n_pulses: Number of pulses integrated (must be &gt;= 1)\n\n    Returns:\n        Integration gain in dB: 10 * log10(n_pulses)\n\n    Raises:\n        ValueError: If n_pulses &lt; 1\n    \"\"\"\n    if n_pulses &lt; 1:\n        raise ValueError(\"n_pulses must be &gt;= 1\")\n\n    if n_pulses == 1:\n        return 0.0\n\n    return 10 * math.log10(n_pulses)\n</code></pre>"},{"location":"api/models/radar/#phased_array_systems.models.radar.integration.noncoherent_integration_gain","title":"noncoherent_integration_gain","text":"<pre><code>noncoherent_integration_gain(n_pulses: int, pd: float = 0.9, pfa: float = 1e-06) -&gt; float\n</code></pre> <p>Non-coherent integration gain in dB.</p> <p>Non-coherent integration (magnitude-only) provides less than full N-times gain because both signal and noise magnitudes are combined. The efficiency depends on SNR and Pd/Pfa.</p> <p>Uses empirical approximation: gain \u2248 10 * log10(n^efficiency) where efficiency \u2248 0.8 for typical radar parameters.</p> PARAMETER DESCRIPTION <code>n_pulses</code> <p>Number of pulses integrated (must be &gt;= 1)</p> <p> TYPE: <code>int</code> </p> <code>pd</code> <p>Probability of detection (affects efficiency)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.9</code> </p> <code>pfa</code> <p>Probability of false alarm (affects efficiency)</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-06</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Integration gain in dB (always &lt;= coherent gain)</p> RAISES DESCRIPTION <code>ValueError</code> <p>If n_pulses &lt; 1</p> Source code in <code>src/phased_array_systems/models/radar/integration.py</code> <pre><code>def noncoherent_integration_gain(\n    n_pulses: int,\n    pd: float = 0.9,\n    pfa: float = 1e-6,\n) -&gt; float:\n    \"\"\"Non-coherent integration gain in dB.\n\n    Non-coherent integration (magnitude-only) provides less than\n    full N-times gain because both signal and noise magnitudes\n    are combined. The efficiency depends on SNR and Pd/Pfa.\n\n    Uses empirical approximation: gain \u2248 10 * log10(n^efficiency)\n    where efficiency \u2248 0.8 for typical radar parameters.\n\n    Args:\n        n_pulses: Number of pulses integrated (must be &gt;= 1)\n        pd: Probability of detection (affects efficiency)\n        pfa: Probability of false alarm (affects efficiency)\n\n    Returns:\n        Integration gain in dB (always &lt;= coherent gain)\n\n    Raises:\n        ValueError: If n_pulses &lt; 1\n    \"\"\"\n    if n_pulses &lt; 1:\n        raise ValueError(\"n_pulses must be &gt;= 1\")\n\n    if n_pulses == 1:\n        return 0.0\n\n    # Efficiency factor depends on operating point\n    # Higher Pd requires higher SNR, reducing integration efficiency\n    if pd &gt;= 0.99:\n        efficiency = 0.7\n    elif pd &gt;= 0.9:\n        efficiency = 0.8\n    elif pd &gt;= 0.5:\n        efficiency = 0.85\n    else:\n        efficiency = 0.9\n\n    # Non-coherent gain: approximately n^efficiency\n    return 10 * efficiency * math.log10(n_pulses)\n</code></pre>"},{"location":"api/models/radar/#output-metrics","title":"Output Metrics","text":"Metric Units Description <code>snr_single_pulse_db</code> dB Single-pulse SNR <code>snr_integrated_db</code> dB SNR after integration <code>snr_required_db</code> dB Required SNR for Pd/Pfa <code>snr_margin_db</code> dB Margin above required <code>detection_range_m</code> m Maximum detection range <code>integration_gain_db</code> dB Gain from pulse integration"},{"location":"api/models/radar/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/radar/#using-radarmodel","title":"Using RadarModel","text":"<pre><code>from phased_array_systems.models.radar import RadarModel\nfrom phased_array_systems.scenarios import RadarDetectionScenario\n\nscenario = RadarDetectionScenario(\n    freq_hz=10e9,\n    target_rcs_m2=1.0,\n    range_m=100e3,\n    required_pd=0.9,\n    pfa=1e-6,\n    pulse_width_s=10e-6,\n    prf_hz=1000,\n    n_pulses=10,\n    integration_type=\"coherent\",\n    swerling_model=1,\n)\n\nmodel = RadarModel()\nmetrics = model.evaluate(arch, scenario, context={})\n\nprint(f\"Single-Pulse SNR: {metrics['snr_single_pulse_db']:.1f} dB\")\nprint(f\"Integrated SNR: {metrics['snr_integrated_db']:.1f} dB\")\nprint(f\"SNR Margin: {metrics['snr_margin_db']:.1f} dB\")\n</code></pre>"},{"location":"api/models/radar/#computing-required-snr","title":"Computing Required SNR","text":"<pre><code>from phased_array_systems.models.radar import compute_snr_for_pd\n\nsnr_req = compute_snr_for_pd(\n    pd=0.9,\n    pfa=1e-6,\n    swerling_model=1,\n)\nprint(f\"Required SNR: {snr_req:.1f} dB\")\n</code></pre>"},{"location":"api/models/radar/#computing-detection-probability","title":"Computing Detection Probability","text":"<pre><code>from phased_array_systems.models.radar import compute_pd_from_snr\n\npd = compute_pd_from_snr(\n    snr_db=15.0,\n    pfa=1e-6,\n    swerling_model=1,\n)\nprint(f\"Detection Probability: {pd:.3f}\")\n</code></pre>"},{"location":"api/models/radar/#integration-gain","title":"Integration Gain","text":"<pre><code>from phased_array_systems.models.radar import coherent_integration_gain, noncoherent_integration_gain\n\n# Coherent integration\ngain_coherent = coherent_integration_gain(n_pulses=16)\nprint(f\"Coherent Gain: {gain_coherent:.1f} dB\")  # 12.0 dB\n\n# Non-coherent integration\ngain_noncoherent = noncoherent_integration_gain(n_pulses=16)\nprint(f\"Non-coherent Gain: {gain_noncoherent:.1f} dB\")  # ~6.0 dB\n</code></pre>"},{"location":"api/models/radar/#radar-range-equation","title":"Radar Range Equation","text":"\\[ SNR = \\frac{P_t G^2 \\lambda^2 \\sigma}{(4\\pi)^3 R^4 k T_s B_n L_s} \\] <p>Where:</p> <ul> <li>\\(P_t\\) = Peak transmit power (W)</li> <li>\\(G\\) = Antenna gain (linear)</li> <li>\\(\\lambda\\) = Wavelength (m)</li> <li>\\(\\sigma\\) = Target RCS (m\u00b2)</li> <li>\\(R\\) = Target range (m)</li> <li>\\(k\\) = Boltzmann constant</li> <li>\\(T_s\\) = System noise temperature (K)</li> <li>\\(B_n\\) = Noise bandwidth (Hz)</li> <li>\\(L_s\\) = System losses (linear)</li> </ul>"},{"location":"api/models/radar/#swerling-models","title":"Swerling Models","text":"Model PDF Decorrelation 0 Constant None 1 Rayleigh Scan-to-scan 2 Rayleigh Pulse-to-pulse 3 Chi-squared (4 DOF) Scan-to-scan 4 Chi-squared (4 DOF) Pulse-to-pulse"},{"location":"api/models/radar/#see-also","title":"See Also","text":"<ul> <li>Theory: Radar Equation</li> <li>User Guide: Radar Detection</li> <li>Scenarios API</li> </ul>"},{"location":"api/models/rf/","title":"RF Cascade Models API","text":"<p>Noise figure, gain cascade, and dynamic range calculations for RF receiver/transmitter chains.</p>"},{"location":"api/models/rf/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.models.rf import (\n    # Noise figure\n    friis_noise_figure,\n    noise_figure_to_temp,\n    noise_temp_to_figure,\n    system_noise_temperature,\n    # Gain\n    cascade_gain,\n    cascade_gain_db,\n    # Dynamic range\n    cascade_iip3,\n    cascade_oip3,\n    sfdr_from_iip3,\n    sfdr_from_oip3,\n    mds_from_noise_figure,\n    # Complete cascade\n    RFStage,\n    cascade_analysis,\n)\n</code></pre>"},{"location":"api/models/rf/#noise-figure-functions","title":"Noise Figure Functions","text":"<p>Functions for calculating cascaded noise figure and noise temperature conversions.</p>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.noise_figure_to_temp","title":"noise_figure_to_temp","text":"<pre><code>noise_figure_to_temp(nf_db: float, t0: float = T0) -&gt; float\n</code></pre> <p>Convert noise figure to equivalent noise temperature.</p> <p>Te = T0 * (F - 1)</p> PARAMETER DESCRIPTION <code>nf_db</code> <p>Noise figure in dB</p> <p> TYPE: <code>float</code> </p> <code>t0</code> <p>Reference temperature in Kelvin (default 290K)</p> <p> TYPE: <code>float</code> DEFAULT: <code>T0</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Equivalent noise temperature in Kelvin</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def noise_figure_to_temp(nf_db: float, t0: float = T0) -&gt; float:\n    \"\"\"Convert noise figure to equivalent noise temperature.\n\n    Te = T0 * (F - 1)\n\n    Args:\n        nf_db: Noise figure in dB\n        t0: Reference temperature in Kelvin (default 290K)\n\n    Returns:\n        Equivalent noise temperature in Kelvin\n    \"\"\"\n    f_linear = 10 ** (nf_db / 10)\n    return t0 * (f_linear - 1)\n</code></pre>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.noise_temp_to_figure","title":"noise_temp_to_figure","text":"<pre><code>noise_temp_to_figure(te: float, t0: float = T0) -&gt; float\n</code></pre> <p>Convert equivalent noise temperature to noise figure.</p> <p>F = 1 + Te/T0</p> PARAMETER DESCRIPTION <code>te</code> <p>Equivalent noise temperature in Kelvin</p> <p> TYPE: <code>float</code> </p> <code>t0</code> <p>Reference temperature in Kelvin (default 290K)</p> <p> TYPE: <code>float</code> DEFAULT: <code>T0</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Noise figure in dB</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def noise_temp_to_figure(te: float, t0: float = T0) -&gt; float:\n    \"\"\"Convert equivalent noise temperature to noise figure.\n\n    F = 1 + Te/T0\n\n    Args:\n        te: Equivalent noise temperature in Kelvin\n        t0: Reference temperature in Kelvin (default 290K)\n\n    Returns:\n        Noise figure in dB\n    \"\"\"\n    f_linear = 1 + te / t0\n    return 10 * math.log10(f_linear)\n</code></pre>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.friis_noise_figure","title":"friis_noise_figure","text":"<pre><code>friis_noise_figure(stages: list[tuple[float, float]]) -&gt; dict[str, float]\n</code></pre> <p>Calculate cascaded noise figure using Friis equation.</p> The Friis formula for cascaded noise figure <p>F_total = F1 + (F2-1)/G1 + (F3-1)/(G1*G2) + ...</p> <p>This shows why low-noise amplifiers (LNAs) are placed first - the first stage dominates the system noise figure.</p> PARAMETER DESCRIPTION <code>stages</code> <p>List of (gain_db, noise_figure_db) tuples for each stage     Stages are in signal flow order (first = input)</p> <p> TYPE: <code>list[tuple[float, float]]</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - total_nf_db: Cascaded noise figure in dB - total_gain_db: Cascaded gain in dB - noise_temp_k: Equivalent noise temperature - stage_contributions_db: NF contribution from each stage</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def friis_noise_figure(\n    stages: list[tuple[float, float]],\n) -&gt; dict[str, float]:\n    \"\"\"Calculate cascaded noise figure using Friis equation.\n\n    The Friis formula for cascaded noise figure:\n        F_total = F1 + (F2-1)/G1 + (F3-1)/(G1*G2) + ...\n\n    This shows why low-noise amplifiers (LNAs) are placed first -\n    the first stage dominates the system noise figure.\n\n    Args:\n        stages: List of (gain_db, noise_figure_db) tuples for each stage\n                Stages are in signal flow order (first = input)\n\n    Returns:\n        Dictionary with:\n            - total_nf_db: Cascaded noise figure in dB\n            - total_gain_db: Cascaded gain in dB\n            - noise_temp_k: Equivalent noise temperature\n            - stage_contributions_db: NF contribution from each stage\n    \"\"\"\n    if not stages:\n        return {\n            \"total_nf_db\": 0.0,\n            \"total_gain_db\": 0.0,\n            \"noise_temp_k\": 0.0,\n            \"stage_contributions_db\": [],\n        }\n\n    # Convert to linear\n    gains_linear = [10 ** (g / 10) for g, _ in stages]\n    nfs_linear = [10 ** (nf / 10) for _, nf in stages]\n\n    # Friis equation\n    f_total = nfs_linear[0]\n    cumulative_gain = gains_linear[0]\n    contributions = [nfs_linear[0] - 1]  # First stage contribution\n\n    for i in range(1, len(stages)):\n        contribution = (nfs_linear[i] - 1) / cumulative_gain\n        contributions.append(contribution)\n        f_total += contribution\n        cumulative_gain *= gains_linear[i]\n\n    # Convert contributions to dB (referenced to total)\n    contributions_db = [10 * math.log10(1 + c) for c in contributions]\n\n    total_nf_db = 10 * math.log10(f_total)\n    total_gain_db = sum(g for g, _ in stages)\n    noise_temp_k = noise_figure_to_temp(total_nf_db)\n\n    return {\n        \"total_nf_db\": total_nf_db,\n        \"total_gain_db\": total_gain_db,\n        \"noise_temp_k\": noise_temp_k,\n        \"stage_contributions_db\": contributions_db,\n        \"n_stages\": len(stages),\n    }\n</code></pre>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.system_noise_temperature","title":"system_noise_temperature","text":"<pre><code>system_noise_temperature(antenna_temp_k: float, receiver_nf_db: float, line_loss_db: float = 0.0, line_temp_k: float = T0) -&gt; dict[str, float]\n</code></pre> <p>Calculate system noise temperature including antenna and losses.</p> <p>T_sys = T_ant + T_line + T_rx</p> <p>Where T_line accounts for loss between antenna and receiver.</p> PARAMETER DESCRIPTION <code>antenna_temp_k</code> <p>Antenna noise temperature in Kelvin</p> <p> TYPE: <code>float</code> </p> <code>receiver_nf_db</code> <p>Receiver noise figure in dB</p> <p> TYPE: <code>float</code> </p> <code>line_loss_db</code> <p>Transmission line loss in dB (default 0)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>line_temp_k</code> <p>Physical temperature of line in Kelvin</p> <p> TYPE: <code>float</code> DEFAULT: <code>T0</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - system_temp_k: Total system noise temperature - antenna_contribution_k: Antenna noise contribution - line_contribution_k: Line loss contribution - receiver_contribution_k: Receiver contribution - system_nf_db: Effective system noise figure</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def system_noise_temperature(\n    antenna_temp_k: float,\n    receiver_nf_db: float,\n    line_loss_db: float = 0.0,\n    line_temp_k: float = T0,\n) -&gt; dict[str, float]:\n    \"\"\"Calculate system noise temperature including antenna and losses.\n\n    T_sys = T_ant + T_line + T_rx\n\n    Where T_line accounts for loss between antenna and receiver.\n\n    Args:\n        antenna_temp_k: Antenna noise temperature in Kelvin\n        receiver_nf_db: Receiver noise figure in dB\n        line_loss_db: Transmission line loss in dB (default 0)\n        line_temp_k: Physical temperature of line in Kelvin\n\n    Returns:\n        Dictionary with:\n            - system_temp_k: Total system noise temperature\n            - antenna_contribution_k: Antenna noise contribution\n            - line_contribution_k: Line loss contribution\n            - receiver_contribution_k: Receiver contribution\n            - system_nf_db: Effective system noise figure\n    \"\"\"\n    # Receiver noise temperature\n    t_rx = noise_figure_to_temp(receiver_nf_db)\n\n    # Line loss contribution\n    # T_line = (L - 1) * T_physical where L is loss factor\n    l_linear = 10 ** (line_loss_db / 10)\n    t_line = (l_linear - 1) * line_temp_k\n\n    # Antenna temperature after line loss\n    t_ant_after_loss = antenna_temp_k / l_linear\n\n    # Total system temperature\n    t_sys = t_ant_after_loss + t_line + t_rx\n\n    # Effective system NF (referenced to antenna)\n    system_nf_db = noise_temp_to_figure(t_sys - T0) if t_sys &gt; T0 else 0.0\n\n    return {\n        \"system_temp_k\": t_sys,\n        \"antenna_contribution_k\": t_ant_after_loss,\n        \"line_contribution_k\": t_line,\n        \"receiver_contribution_k\": t_rx,\n        \"system_nf_db\": system_nf_db,\n    }\n</code></pre>"},{"location":"api/models/rf/#gain-functions","title":"Gain Functions","text":"<p>Functions for calculating cascaded gain through multi-stage RF chains.</p>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.cascade_gain","title":"cascade_gain","text":"<pre><code>cascade_gain(gains_db: list[float]) -&gt; float\n</code></pre> <p>Calculate total cascaded gain.</p> <p>Simply sums gains in dB (multiplies in linear).</p> PARAMETER DESCRIPTION <code>gains_db</code> <p>List of stage gains in dB (negative for loss)</p> <p> TYPE: <code>list[float]</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Total gain in dB</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def cascade_gain(gains_db: list[float]) -&gt; float:\n    \"\"\"Calculate total cascaded gain.\n\n    Simply sums gains in dB (multiplies in linear).\n\n    Args:\n        gains_db: List of stage gains in dB (negative for loss)\n\n    Returns:\n        Total gain in dB\n    \"\"\"\n    return sum(gains_db)\n</code></pre>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.cascade_gain_db","title":"cascade_gain_db","text":"<pre><code>cascade_gain_db(stages: list[tuple[float, float]]) -&gt; float\n</code></pre> <p>Calculate total cascaded gain from stage tuples.</p> PARAMETER DESCRIPTION <code>stages</code> <p>List of (gain_db, noise_figure_db) tuples</p> <p> TYPE: <code>list[tuple[float, float]]</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Total gain in dB</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def cascade_gain_db(stages: list[tuple[float, float]]) -&gt; float:\n    \"\"\"Calculate total cascaded gain from stage tuples.\n\n    Args:\n        stages: List of (gain_db, noise_figure_db) tuples\n\n    Returns:\n        Total gain in dB\n    \"\"\"\n    return sum(g for g, _ in stages)\n</code></pre>"},{"location":"api/models/rf/#dynamic-range-functions","title":"Dynamic Range Functions","text":"<p>Functions for calculating cascaded intercept points and spurious-free dynamic range.</p>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.cascade_iip3","title":"cascade_iip3","text":"<pre><code>cascade_iip3(stages: list[tuple[float, float]]) -&gt; dict[str, float]\n</code></pre> <p>Calculate cascaded input third-order intercept point.</p> For cascaded stages <p>1/IIP3_total = 1/IIP3_1 + G1/IIP3_2 + G1*G2/IIP3_3 + ...</p> <p>(All values in linear power, not dB)</p> PARAMETER DESCRIPTION <code>stages</code> <p>List of (gain_db, iip3_dbm) tuples for each stage</p> <p> TYPE: <code>list[tuple[float, float]]</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - iip3_dbm: Cascaded input IP3 in dBm - oip3_dbm: Cascaded output IP3 in dBm - total_gain_db: Cascaded gain</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def cascade_iip3(\n    stages: list[tuple[float, float]],\n) -&gt; dict[str, float]:\n    \"\"\"Calculate cascaded input third-order intercept point.\n\n    For cascaded stages:\n        1/IIP3_total = 1/IIP3_1 + G1/IIP3_2 + G1*G2/IIP3_3 + ...\n\n    (All values in linear power, not dB)\n\n    Args:\n        stages: List of (gain_db, iip3_dbm) tuples for each stage\n\n    Returns:\n        Dictionary with:\n            - iip3_dbm: Cascaded input IP3 in dBm\n            - oip3_dbm: Cascaded output IP3 in dBm\n            - total_gain_db: Cascaded gain\n    \"\"\"\n    if not stages:\n        return {\"iip3_dbm\": float('inf'), \"oip3_dbm\": float('inf'), \"total_gain_db\": 0}\n\n    # Convert to linear (mW)\n    gains_linear = [10 ** (g / 10) for g, _ in stages]\n    iip3s_linear = [10 ** (iip3 / 10) for _, iip3 in stages]\n\n    # Cascade formula\n    inv_iip3_total = 1 / iip3s_linear[0]\n    cumulative_gain = gains_linear[0]\n\n    for i in range(1, len(stages)):\n        inv_iip3_total += cumulative_gain / iip3s_linear[i]\n        cumulative_gain *= gains_linear[i]\n\n    iip3_total_linear = 1 / inv_iip3_total\n    iip3_dbm = 10 * math.log10(iip3_total_linear)\n\n    total_gain_db = sum(g for g, _ in stages)\n    oip3_dbm = iip3_dbm + total_gain_db\n\n    return {\n        \"iip3_dbm\": iip3_dbm,\n        \"oip3_dbm\": oip3_dbm,\n        \"total_gain_db\": total_gain_db,\n    }\n</code></pre>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.cascade_oip3","title":"cascade_oip3","text":"<pre><code>cascade_oip3(stages: list[tuple[float, float]]) -&gt; dict[str, float]\n</code></pre> <p>Calculate cascaded output third-order intercept point.</p> <p>Same as cascade_iip3 but with OIP3 inputs.</p> PARAMETER DESCRIPTION <code>stages</code> <p>List of (gain_db, oip3_dbm) tuples for each stage</p> <p> TYPE: <code>list[tuple[float, float]]</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with iip3_dbm, oip3_dbm, total_gain_db</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def cascade_oip3(\n    stages: list[tuple[float, float]],\n) -&gt; dict[str, float]:\n    \"\"\"Calculate cascaded output third-order intercept point.\n\n    Same as cascade_iip3 but with OIP3 inputs.\n\n    Args:\n        stages: List of (gain_db, oip3_dbm) tuples for each stage\n\n    Returns:\n        Dictionary with iip3_dbm, oip3_dbm, total_gain_db\n    \"\"\"\n    # Convert OIP3 to IIP3 for each stage\n    iip3_stages = [(g, oip3 - g) for g, oip3 in stages]\n    result = cascade_iip3(iip3_stages)\n    return result\n</code></pre>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.sfdr_from_iip3","title":"sfdr_from_iip3","text":"<pre><code>sfdr_from_iip3(iip3_dbm: float, noise_floor_dbm_hz: float, bandwidth_hz: float) -&gt; dict[str, float]\n</code></pre> <p>Calculate spurious-free dynamic range from IIP3.</p> <p>SFDR is the range between the noise floor and the signal level where third-order intermodulation products equal the noise.</p> <p>SFDR = (2/3) * (IIP3 - Noise Floor)</p> PARAMETER DESCRIPTION <code>iip3_dbm</code> <p>Input third-order intercept point in dBm</p> <p> TYPE: <code>float</code> </p> <code>noise_floor_dbm_hz</code> <p>Noise floor spectral density in dBm/Hz</p> <p> TYPE: <code>float</code> </p> <code>bandwidth_hz</code> <p>Signal bandwidth for integrated noise</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - sfdr_db: Spurious-free dynamic range in dB - noise_floor_dbm: Integrated noise floor - max_signal_dbm: Maximum signal before spurs exceed noise</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def sfdr_from_iip3(\n    iip3_dbm: float,\n    noise_floor_dbm_hz: float,\n    bandwidth_hz: float,\n) -&gt; dict[str, float]:\n    \"\"\"Calculate spurious-free dynamic range from IIP3.\n\n    SFDR is the range between the noise floor and the signal level\n    where third-order intermodulation products equal the noise.\n\n    SFDR = (2/3) * (IIP3 - Noise Floor)\n\n    Args:\n        iip3_dbm: Input third-order intercept point in dBm\n        noise_floor_dbm_hz: Noise floor spectral density in dBm/Hz\n        bandwidth_hz: Signal bandwidth for integrated noise\n\n    Returns:\n        Dictionary with:\n            - sfdr_db: Spurious-free dynamic range in dB\n            - noise_floor_dbm: Integrated noise floor\n            - max_signal_dbm: Maximum signal before spurs exceed noise\n    \"\"\"\n    noise_floor_dbm = noise_floor_dbm_hz + 10 * math.log10(bandwidth_hz)\n    sfdr_db = (2 / 3) * (iip3_dbm - noise_floor_dbm)\n    max_signal_dbm = noise_floor_dbm + sfdr_db\n\n    return {\n        \"sfdr_db\": sfdr_db,\n        \"noise_floor_dbm\": noise_floor_dbm,\n        \"max_signal_dbm\": max_signal_dbm,\n        \"iip3_dbm\": iip3_dbm,\n    }\n</code></pre>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.sfdr_from_oip3","title":"sfdr_from_oip3","text":"<pre><code>sfdr_from_oip3(oip3_dbm: float, noise_floor_dbm_hz: float, bandwidth_hz: float, gain_db: float) -&gt; dict[str, float]\n</code></pre> <p>Calculate spurious-free dynamic range from OIP3.</p> PARAMETER DESCRIPTION <code>oip3_dbm</code> <p>Output third-order intercept point in dBm</p> <p> TYPE: <code>float</code> </p> <code>noise_floor_dbm_hz</code> <p>Noise floor spectral density in dBm/Hz</p> <p> TYPE: <code>float</code> </p> <code>bandwidth_hz</code> <p>Signal bandwidth for integrated noise</p> <p> TYPE: <code>float</code> </p> <code>gain_db</code> <p>Total system gain in dB</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with sfdr_db, noise_floor_dbm, max_signal_dbm</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def sfdr_from_oip3(\n    oip3_dbm: float,\n    noise_floor_dbm_hz: float,\n    bandwidth_hz: float,\n    gain_db: float,\n) -&gt; dict[str, float]:\n    \"\"\"Calculate spurious-free dynamic range from OIP3.\n\n    Args:\n        oip3_dbm: Output third-order intercept point in dBm\n        noise_floor_dbm_hz: Noise floor spectral density in dBm/Hz\n        bandwidth_hz: Signal bandwidth for integrated noise\n        gain_db: Total system gain in dB\n\n    Returns:\n        Dictionary with sfdr_db, noise_floor_dbm, max_signal_dbm\n    \"\"\"\n    iip3_dbm = oip3_dbm - gain_db\n    return sfdr_from_iip3(iip3_dbm, noise_floor_dbm_hz, bandwidth_hz)\n</code></pre>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.mds_from_noise_figure","title":"mds_from_noise_figure","text":"<pre><code>mds_from_noise_figure(noise_figure_db: float, bandwidth_hz: float, snr_required_db: float = 0.0, t0: float = T0) -&gt; dict[str, float]\n</code></pre> <p>Calculate minimum detectable signal from noise figure.</p> <p>MDS = kTB + NF + SNR_required</p> PARAMETER DESCRIPTION <code>noise_figure_db</code> <p>System noise figure in dB</p> <p> TYPE: <code>float</code> </p> <code>bandwidth_hz</code> <p>Receiver bandwidth in Hz</p> <p> TYPE: <code>float</code> </p> <code>snr_required_db</code> <p>Required SNR for detection (default 0 dB)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>t0</code> <p>Reference temperature in Kelvin</p> <p> TYPE: <code>float</code> DEFAULT: <code>T0</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with: - mds_dbm: Minimum detectable signal in dBm - noise_floor_dbm: Noise floor in dBm - ktb_dbm: Thermal noise power</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def mds_from_noise_figure(\n    noise_figure_db: float,\n    bandwidth_hz: float,\n    snr_required_db: float = 0.0,\n    t0: float = T0,\n) -&gt; dict[str, float]:\n    \"\"\"Calculate minimum detectable signal from noise figure.\n\n    MDS = kTB + NF + SNR_required\n\n    Args:\n        noise_figure_db: System noise figure in dB\n        bandwidth_hz: Receiver bandwidth in Hz\n        snr_required_db: Required SNR for detection (default 0 dB)\n        t0: Reference temperature in Kelvin\n\n    Returns:\n        Dictionary with:\n            - mds_dbm: Minimum detectable signal in dBm\n            - noise_floor_dbm: Noise floor in dBm\n            - ktb_dbm: Thermal noise power\n    \"\"\"\n    # kT in dBm/Hz at T0\n    kt_dbm_hz = 10 * math.log10(K_B * t0 * 1000)  # *1000 for mW\n\n    # kTB\n    ktb_dbm = kt_dbm_hz + 10 * math.log10(bandwidth_hz)\n\n    # Noise floor = kTB + NF\n    noise_floor_dbm = ktb_dbm + noise_figure_db\n\n    # MDS\n    mds_dbm = noise_floor_dbm + snr_required_db\n\n    return {\n        \"mds_dbm\": mds_dbm,\n        \"noise_floor_dbm\": noise_floor_dbm,\n        \"ktb_dbm\": ktb_dbm,\n        \"kt_dbm_hz\": kt_dbm_hz,\n    }\n</code></pre>"},{"location":"api/models/rf/#complete-cascade-analysis","title":"Complete Cascade Analysis","text":"<p>Classes and functions for comprehensive RF chain analysis.</p>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.RFStage","title":"RFStage  <code>dataclass</code>","text":"<pre><code>RFStage(name: str, gain_db: float, noise_figure_db: float, iip3_dbm: float = 100.0, p1db_dbm: float = 100.0)\n</code></pre> <p>A single stage in an RF chain.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Descriptive name for the stage</p> <p> TYPE: <code>str</code> </p> <code>gain_db</code> <p>Stage gain in dB (negative for loss)</p> <p> TYPE: <code>float</code> </p> <code>noise_figure_db</code> <p>Stage noise figure in dB</p> <p> TYPE: <code>float</code> </p> <code>iip3_dbm</code> <p>Input third-order intercept point in dBm</p> <p> TYPE: <code>float</code> </p> <code>p1db_dbm</code> <p>Input 1dB compression point in dBm (optional)</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.RFStage.oip3_dbm","title":"oip3_dbm  <code>property</code>","text":"<pre><code>oip3_dbm: float\n</code></pre> <p>Output IP3.</p>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.RFStage.op1db_dbm","title":"op1db_dbm  <code>property</code>","text":"<pre><code>op1db_dbm: float\n</code></pre> <p>Output P1dB.</p>"},{"location":"api/models/rf/#phased_array_systems.models.rf.cascade.cascade_analysis","title":"cascade_analysis","text":"<pre><code>cascade_analysis(stages: list[RFStage], bandwidth_hz: float = 1000000.0, input_power_dbm: float = -60.0) -&gt; dict[str, float | list]\n</code></pre> <p>Perform complete cascaded analysis of an RF chain.</p> <p>This is the main function for analyzing a complete receiver or transmitter chain, computing noise figure, gain, linearity, and dynamic range.</p> PARAMETER DESCRIPTION <code>stages</code> <p>List of RFStage objects in signal flow order</p> <p> TYPE: <code>list[RFStage]</code> </p> <code>bandwidth_hz</code> <p>Analysis bandwidth in Hz</p> <p> TYPE: <code>float</code> DEFAULT: <code>1000000.0</code> </p> <code>input_power_dbm</code> <p>Reference input power for level tracking</p> <p> TYPE: <code>float</code> DEFAULT: <code>-60.0</code> </p> RETURNS DESCRIPTION <code>dict[str, float | list]</code> <p>Dictionary with comprehensive cascade results: - total_gain_db: Cascaded gain - total_nf_db: Cascaded noise figure - noise_temp_k: Equivalent noise temperature - iip3_dbm: Cascaded input IP3 - oip3_dbm: Cascaded output IP3 - sfdr_db: Spurious-free dynamic range - mds_dbm: Minimum detectable signal - stage_levels_dbm: Signal level at each stage output - stage_names: Names of each stage</p> Source code in <code>src/phased_array_systems/models/rf/cascade.py</code> <pre><code>def cascade_analysis(\n    stages: list[RFStage],\n    bandwidth_hz: float = 1e6,\n    input_power_dbm: float = -60.0,\n) -&gt; dict[str, float | list]:\n    \"\"\"Perform complete cascaded analysis of an RF chain.\n\n    This is the main function for analyzing a complete receiver or\n    transmitter chain, computing noise figure, gain, linearity, and\n    dynamic range.\n\n    Args:\n        stages: List of RFStage objects in signal flow order\n        bandwidth_hz: Analysis bandwidth in Hz\n        input_power_dbm: Reference input power for level tracking\n\n    Returns:\n        Dictionary with comprehensive cascade results:\n            - total_gain_db: Cascaded gain\n            - total_nf_db: Cascaded noise figure\n            - noise_temp_k: Equivalent noise temperature\n            - iip3_dbm: Cascaded input IP3\n            - oip3_dbm: Cascaded output IP3\n            - sfdr_db: Spurious-free dynamic range\n            - mds_dbm: Minimum detectable signal\n            - stage_levels_dbm: Signal level at each stage output\n            - stage_names: Names of each stage\n    \"\"\"\n    if not stages:\n        return {}\n\n    # Build tuples for existing functions\n    nf_stages = [(s.gain_db, s.noise_figure_db) for s in stages]\n    iip3_stages = [(s.gain_db, s.iip3_dbm) for s in stages]\n\n    # Cascade calculations\n    nf_result = friis_noise_figure(nf_stages)\n    iip3_result = cascade_iip3(iip3_stages)\n\n    # MDS\n    mds_result = mds_from_noise_figure(\n        nf_result[\"total_nf_db\"],\n        bandwidth_hz,\n        snr_required_db=0,\n    )\n\n    # SFDR\n    sfdr_result = sfdr_from_iip3(\n        iip3_result[\"iip3_dbm\"],\n        mds_result[\"kt_dbm_hz\"] + nf_result[\"total_nf_db\"],\n        bandwidth_hz,\n    )\n\n    # Track signal level through chain\n    level = input_power_dbm\n    levels = [level]\n    for stage in stages:\n        level += stage.gain_db\n        levels.append(level)\n\n    return {\n        # Gain\n        \"total_gain_db\": nf_result[\"total_gain_db\"],\n        # Noise\n        \"total_nf_db\": nf_result[\"total_nf_db\"],\n        \"noise_temp_k\": nf_result[\"noise_temp_k\"],\n        \"stage_nf_contributions_db\": nf_result[\"stage_contributions_db\"],\n        # Linearity\n        \"iip3_dbm\": iip3_result[\"iip3_dbm\"],\n        \"oip3_dbm\": iip3_result[\"oip3_dbm\"],\n        # Dynamic range\n        \"sfdr_db\": sfdr_result[\"sfdr_db\"],\n        \"mds_dbm\": mds_result[\"mds_dbm\"],\n        \"noise_floor_dbm\": mds_result[\"noise_floor_dbm\"],\n        # Signal tracking\n        \"input_power_dbm\": input_power_dbm,\n        \"output_power_dbm\": levels[-1],\n        \"stage_levels_dbm\": levels,\n        \"stage_names\": [\"Input\"] + [s.name for s in stages],\n        # Metadata\n        \"bandwidth_hz\": bandwidth_hz,\n        \"n_stages\": len(stages),\n    }\n</code></pre>"},{"location":"api/models/rf/#output-metrics","title":"Output Metrics","text":"Metric Units Description <code>total_gain_db</code> dB Cascaded system gain <code>total_nf_db</code> dB Cascaded noise figure <code>noise_temp_k</code> K Equivalent noise temperature <code>iip3_dbm</code> dBm Input third-order intercept point <code>oip3_dbm</code> dBm Output third-order intercept point <code>sfdr_db</code> dB Spurious-free dynamic range <code>mds_dbm</code> dBm Minimum detectable signal <code>noise_floor_dbm</code> dBm Integrated noise floor"},{"location":"api/models/rf/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/rf/#friis-noise-figure-cascade","title":"Friis Noise Figure Cascade","text":"<pre><code>from phased_array_systems.models.rf import friis_noise_figure\n\n# LNA -&gt; Mixer -&gt; IF Amp chain\nresult = friis_noise_figure([\n    (20, 1.5),   # LNA: 20 dB gain, 1.5 dB NF\n    (-8, 8),     # Mixer: -8 dB gain (loss), 8 dB NF\n    (30, 4),     # IF Amp: 30 dB gain, 4 dB NF\n])\n\nprint(f\"System NF: {result['total_nf_db']:.2f} dB\")\nprint(f\"System Gain: {result['total_gain_db']:.1f} dB\")\nprint(f\"Noise Temperature: {result['noise_temp_k']:.1f} K\")\n</code></pre>"},{"location":"api/models/rf/#system-noise-temperature","title":"System Noise Temperature","text":"<pre><code>from phased_array_systems.models.rf import system_noise_temperature\n\n# Satellite receiver with cold sky\nresult = system_noise_temperature(\n    antenna_temp_k=50,       # Cold sky\n    receiver_nf_db=2.0,      # Low-noise receiver\n    line_loss_db=0.5,        # Cable/waveguide loss\n)\n\nprint(f\"System Temperature: {result['system_temp_k']:.1f} K\")\nprint(f\"Antenna contribution: {result['antenna_contribution_k']:.1f} K\")\nprint(f\"Receiver contribution: {result['receiver_contribution_k']:.1f} K\")\n</code></pre>"},{"location":"api/models/rf/#cascaded-iip3-and-sfdr","title":"Cascaded IIP3 and SFDR","text":"<pre><code>from phased_array_systems.models.rf import cascade_iip3, sfdr_from_iip3\n\n# Calculate cascaded linearity\niip3_result = cascade_iip3([\n    (20, -5),    # LNA: 20 dB gain, -5 dBm IIP3\n    (-8, 15),    # Mixer: -8 dB gain, +15 dBm IIP3\n    (30, 10),    # IF Amp: 30 dB gain, +10 dBm IIP3\n])\n\nprint(f\"Cascaded IIP3: {iip3_result['iip3_dbm']:.1f} dBm\")\nprint(f\"Cascaded OIP3: {iip3_result['oip3_dbm']:.1f} dBm\")\n\n# Calculate SFDR\nsfdr_result = sfdr_from_iip3(\n    iip3_dbm=iip3_result['iip3_dbm'],\n    noise_floor_dbm_hz=-170,  # -174 dBm/Hz + 4 dB NF\n    bandwidth_hz=10e6,\n)\n\nprint(f\"SFDR: {sfdr_result['sfdr_db']:.1f} dB\")\n</code></pre>"},{"location":"api/models/rf/#minimum-detectable-signal","title":"Minimum Detectable Signal","text":"<pre><code>from phased_array_systems.models.rf import mds_from_noise_figure\n\nresult = mds_from_noise_figure(\n    noise_figure_db=3,\n    bandwidth_hz=1e6,\n    snr_required_db=10,\n)\n\nprint(f\"MDS: {result['mds_dbm']:.1f} dBm\")\nprint(f\"Noise Floor: {result['noise_floor_dbm']:.1f} dBm\")\nprint(f\"kTB: {result['ktb_dbm']:.1f} dBm\")\n</code></pre>"},{"location":"api/models/rf/#complete-rf-chain-analysis","title":"Complete RF Chain Analysis","text":"<pre><code>from phased_array_systems.models.rf import RFStage, cascade_analysis\n\n# Define receiver chain\nstages = [\n    RFStage(\"LNA\", gain_db=20, noise_figure_db=1.5, iip3_dbm=-5),\n    RFStage(\"BPF\", gain_db=-2, noise_figure_db=2, iip3_dbm=30),\n    RFStage(\"Mixer\", gain_db=-8, noise_figure_db=8, iip3_dbm=15),\n    RFStage(\"IF Amp\", gain_db=30, noise_figure_db=4, iip3_dbm=10),\n    RFStage(\"ADC Driver\", gain_db=10, noise_figure_db=6, iip3_dbm=20),\n]\n\nresult = cascade_analysis(\n    stages=stages,\n    bandwidth_hz=10e6,\n    input_power_dbm=-60,\n)\n\nprint(f\"System NF: {result['total_nf_db']:.2f} dB\")\nprint(f\"System Gain: {result['total_gain_db']:.1f} dB\")\nprint(f\"IIP3: {result['iip3_dbm']:.1f} dBm\")\nprint(f\"SFDR: {result['sfdr_db']:.1f} dB\")\nprint(f\"MDS: {result['mds_dbm']:.1f} dBm\")\nprint(f\"Output Power: {result['output_power_dbm']:.1f} dBm\")\n</code></pre>"},{"location":"api/models/rf/#key-equations","title":"Key Equations","text":""},{"location":"api/models/rf/#friis-noise-figure","title":"Friis Noise Figure","text":"\\[ F_{total} = F_1 + \\frac{F_2 - 1}{G_1} + \\frac{F_3 - 1}{G_1 G_2} + \\cdots \\]"},{"location":"api/models/rf/#noise-figure-to-temperature","title":"Noise Figure to Temperature","text":"\\[ T_e = T_0 (F - 1) \\] <p>Where \\(T_0 = 290\\) K (reference temperature).</p>"},{"location":"api/models/rf/#cascaded-iip3","title":"Cascaded IIP3","text":"\\[ \\frac{1}{IIP3_{total}} = \\frac{1}{IIP3_1} + \\frac{G_1}{IIP3_2} + \\frac{G_1 G_2}{IIP3_3} + \\cdots \\]"},{"location":"api/models/rf/#spurious-free-dynamic-range","title":"Spurious-Free Dynamic Range","text":"\\[ SFDR = \\frac{2}{3} (IIP3 - N_{floor}) \\]"},{"location":"api/models/rf/#minimum-detectable-signal_1","title":"Minimum Detectable Signal","text":"\\[ MDS = kTB + NF + SNR_{required} \\] <p>Where \\(kT = -174\\) dBm/Hz at 290 K.</p>"},{"location":"api/models/rf/#design-guidelines","title":"Design Guidelines","text":""},{"location":"api/models/rf/#lna-placement","title":"LNA Placement","text":"<p>The Friis equation shows why low-noise amplifiers (LNAs) must be placed first:</p> <ul> <li>First stage dominates system noise figure</li> <li>High gain in first stage reduces impact of subsequent stages</li> <li>Trade-off: high-gain LNA can degrade linearity</li> </ul>"},{"location":"api/models/rf/#typical-nf-budget","title":"Typical NF Budget","text":"Stage Typical NF Typical Gain LNA 1-3 dB 15-25 dB Filter 1-3 dB -1 to -3 dB Mixer 6-10 dB -6 to -10 dB IF Amp 3-6 dB 20-40 dB"},{"location":"api/models/rf/#dynamic-range-considerations","title":"Dynamic Range Considerations","text":"<ul> <li>IIP3 limited by early high-gain stages</li> <li>SFDR balances noise and linearity</li> <li>Back-off from P1dB typically 10-12 dB below IIP3</li> </ul>"},{"location":"api/models/rf/#see-also","title":"See Also","text":"<ul> <li>Digital Models - ADC/DAC and digital beamforming</li> <li>Communications Models - Link budget calculations</li> <li>Theory: Link Budget Equations</li> </ul>"},{"location":"api/models/swapc/","title":"SWaP-C Models API","text":"<p>Size, Weight, Power, and Cost models.</p>"},{"location":"api/models/swapc/#overview","title":"Overview","text":"<pre><code>from phased_array_systems.models.swapc import PowerModel, CostModel\n</code></pre>"},{"location":"api/models/swapc/#classes","title":"Classes","text":""},{"location":"api/models/swapc/#phased_array_systems.models.swapc.power.PowerModel","title":"PowerModel","text":"<pre><code>PowerModel(overhead_factor: float = 0.2)\n</code></pre> <p>Power consumption calculator for phased array systems.</p> <p>Computes DC power, RF power, and prime power based on architecture parameters and efficiency factors.</p> Power Equations <p>RF_power = n_elements * tx_power_per_elem DC_power = RF_power / pa_efficiency Prime_power = DC_power * (1 + overhead_factor)</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Model block name for identification</p> <p> TYPE: <code>str</code> </p> <code>overhead_factor</code> <p>Additional power overhead (cooling, control, etc.)</p> <p> </p> <p>Initialize power model.</p> PARAMETER DESCRIPTION <code>overhead_factor</code> <p>Fraction of DC power for overhead (default 20%)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.2</code> </p> Source code in <code>src/phased_array_systems/models/swapc/power.py</code> <pre><code>def __init__(self, overhead_factor: float = 0.2):\n    \"\"\"Initialize power model.\n\n    Args:\n        overhead_factor: Fraction of DC power for overhead (default 20%)\n    \"\"\"\n    self.overhead_factor = overhead_factor\n</code></pre>"},{"location":"api/models/swapc/#phased_array_systems.models.swapc.power.PowerModel.evaluate","title":"evaluate","text":"<pre><code>evaluate(arch: Architecture, scenario: Scenario, context: dict[str, Any]) -&gt; MetricsDict\n</code></pre> <p>Evaluate power metrics.</p> PARAMETER DESCRIPTION <code>arch</code> <p>Architecture configuration</p> <p> TYPE: <code>Architecture</code> </p> <code>scenario</code> <p>Scenario (may influence duty cycle)</p> <p> TYPE: <code>Scenario</code> </p> <code>context</code> <p>Additional context (unused)</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>MetricsDict</code> <p>Dictionary with power metrics: - rf_power_w: Total RF output power (W) - dc_power_w: DC power consumption (W) - prime_power_w: Prime/wall power (W) - pa_efficiency: Power amplifier efficiency - n_elements: Number of array elements</p> Source code in <code>src/phased_array_systems/models/swapc/power.py</code> <pre><code>def evaluate(\n    self,\n    arch: Architecture,\n    scenario: Scenario,\n    context: dict[str, Any],\n) -&gt; MetricsDict:\n    \"\"\"Evaluate power metrics.\n\n    Args:\n        arch: Architecture configuration\n        scenario: Scenario (may influence duty cycle)\n        context: Additional context (unused)\n\n    Returns:\n        Dictionary with power metrics:\n            - rf_power_w: Total RF output power (W)\n            - dc_power_w: DC power consumption (W)\n            - prime_power_w: Prime/wall power (W)\n            - pa_efficiency: Power amplifier efficiency\n            - n_elements: Number of array elements\n    \"\"\"\n    n_elements = arch.array.n_elements\n    tx_power_per_elem = arch.rf.tx_power_w_per_elem\n    pa_efficiency = arch.rf.pa_efficiency\n\n    # RF power\n    rf_power_w = n_elements * tx_power_per_elem\n\n    # DC power (accounting for PA efficiency)\n    dc_power_w = rf_power_w / pa_efficiency\n\n    # Prime power (including overhead)\n    prime_power_w = dc_power_w * (1 + self.overhead_factor)\n\n    return {\n        \"rf_power_w\": rf_power_w,\n        \"dc_power_w\": dc_power_w,\n        \"prime_power_w\": prime_power_w,\n        \"pa_efficiency\": pa_efficiency,\n        \"n_elements\": n_elements,\n    }\n</code></pre>"},{"location":"api/models/swapc/#phased_array_systems.models.swapc.cost.CostModel","title":"CostModel","text":"<p>Parametric cost model for phased array systems.</p> <p>Computes recurring and non-recurring costs based on array size and cost parameters.</p> Cost Equations <p>Recurring_cost = n_elements * cost_per_element Total_cost = Recurring_cost + NRE + Integration</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Model block name for identification</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/models/swapc/#phased_array_systems.models.swapc.cost.CostModel.evaluate","title":"evaluate","text":"<pre><code>evaluate(arch: Architecture, scenario: Scenario, context: dict[str, Any]) -&gt; MetricsDict\n</code></pre> <p>Evaluate cost metrics.</p> PARAMETER DESCRIPTION <code>arch</code> <p>Architecture configuration</p> <p> TYPE: <code>Architecture</code> </p> <code>scenario</code> <p>Scenario (unused for basic cost model)</p> <p> TYPE: <code>Scenario</code> </p> <code>context</code> <p>Additional context (unused)</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>MetricsDict</code> <p>Dictionary with cost metrics: - recurring_cost_usd: Element-based recurring cost (USD) - nre_usd: Non-recurring engineering cost (USD) - integration_cost_usd: System integration cost (USD) - total_cost_usd: Total system cost (USD) - cost_per_element_usd: Cost per element (USD) - n_elements: Number of elements</p> Source code in <code>src/phased_array_systems/models/swapc/cost.py</code> <pre><code>def evaluate(\n    self,\n    arch: Architecture,\n    scenario: Scenario,\n    context: dict[str, Any],\n) -&gt; MetricsDict:\n    \"\"\"Evaluate cost metrics.\n\n    Args:\n        arch: Architecture configuration\n        scenario: Scenario (unused for basic cost model)\n        context: Additional context (unused)\n\n    Returns:\n        Dictionary with cost metrics:\n            - recurring_cost_usd: Element-based recurring cost (USD)\n            - nre_usd: Non-recurring engineering cost (USD)\n            - integration_cost_usd: System integration cost (USD)\n            - total_cost_usd: Total system cost (USD)\n            - cost_per_element_usd: Cost per element (USD)\n            - n_elements: Number of elements\n    \"\"\"\n    n_elements = arch.array.n_elements\n    cost_per_elem = arch.cost.cost_per_elem_usd\n    nre = arch.cost.nre_usd\n    integration = arch.cost.integration_cost_usd\n\n    # Recurring cost (scales with elements)\n    recurring_cost = n_elements * cost_per_elem\n\n    # Total cost\n    total_cost = recurring_cost + nre + integration\n\n    return {\n        \"recurring_cost_usd\": recurring_cost,\n        \"nre_usd\": nre,\n        \"integration_cost_usd\": integration,\n        \"total_cost_usd\": total_cost,\n        \"cost_per_element_usd\": cost_per_elem,\n        \"cost_usd\": total_cost,  # Canonical metric name\n        \"n_elements\": n_elements,\n    }\n</code></pre>"},{"location":"api/models/swapc/#functions","title":"Functions","text":""},{"location":"api/models/swapc/#phased_array_systems.models.swapc.power.compute_thermal_load","title":"compute_thermal_load","text":"<pre><code>compute_thermal_load(dc_power_w: float, rf_power_w: float, additional_dissipation_w: float = 0.0) -&gt; dict[str, float]\n</code></pre> <p>Compute thermal dissipation for heat management.</p> PARAMETER DESCRIPTION <code>dc_power_w</code> <p>Total DC power consumption (W)</p> <p> TYPE: <code>float</code> </p> <code>rf_power_w</code> <p>RF power radiated (W)</p> <p> TYPE: <code>float</code> </p> <code>additional_dissipation_w</code> <p>Other heat sources (W)</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary with thermal metrics: - heat_dissipation_w: Total heat to remove (W) - rf_efficiency: Fraction of DC converted to RF</p> Source code in <code>src/phased_array_systems/models/swapc/power.py</code> <pre><code>def compute_thermal_load(\n    dc_power_w: float,\n    rf_power_w: float,\n    additional_dissipation_w: float = 0.0,\n) -&gt; dict[str, float]:\n    \"\"\"Compute thermal dissipation for heat management.\n\n    Args:\n        dc_power_w: Total DC power consumption (W)\n        rf_power_w: RF power radiated (W)\n        additional_dissipation_w: Other heat sources (W)\n\n    Returns:\n        Dictionary with thermal metrics:\n            - heat_dissipation_w: Total heat to remove (W)\n            - rf_efficiency: Fraction of DC converted to RF\n    \"\"\"\n    # Heat = DC input - RF output + additional sources\n    heat_dissipation_w = dc_power_w - rf_power_w + additional_dissipation_w\n    rf_efficiency = rf_power_w / dc_power_w if dc_power_w &gt; 0 else 0.0\n\n    return {\n        \"heat_dissipation_w\": heat_dissipation_w,\n        \"rf_efficiency\": rf_efficiency,\n    }\n</code></pre>"},{"location":"api/models/swapc/#phased_array_systems.models.swapc.cost.compute_cost_per_watt","title":"compute_cost_per_watt","text":"<pre><code>compute_cost_per_watt(total_cost_usd: float, rf_power_w: float) -&gt; float\n</code></pre> <p>Compute cost per Watt of RF power.</p> PARAMETER DESCRIPTION <code>total_cost_usd</code> <p>Total system cost (USD)</p> <p> TYPE: <code>float</code> </p> <code>rf_power_w</code> <p>RF output power (W)</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Cost per Watt (USD/W)</p> Source code in <code>src/phased_array_systems/models/swapc/cost.py</code> <pre><code>def compute_cost_per_watt(total_cost_usd: float, rf_power_w: float) -&gt; float:\n    \"\"\"Compute cost per Watt of RF power.\n\n    Args:\n        total_cost_usd: Total system cost (USD)\n        rf_power_w: RF output power (W)\n\n    Returns:\n        Cost per Watt (USD/W)\n    \"\"\"\n    if rf_power_w &lt;= 0:\n        return float(\"inf\")\n    return total_cost_usd / rf_power_w\n</code></pre>"},{"location":"api/models/swapc/#phased_array_systems.models.swapc.cost.compute_cost_per_db","title":"compute_cost_per_db","text":"<pre><code>compute_cost_per_db(total_cost_usd: float, eirp_dbw: float) -&gt; float\n</code></pre> <p>Compute cost per dBW of EIRP.</p> <p>Useful for comparing cost-effectiveness of different architectures.</p> PARAMETER DESCRIPTION <code>total_cost_usd</code> <p>Total system cost (USD)</p> <p> TYPE: <code>float</code> </p> <code>eirp_dbw</code> <p>Effective Isotropic Radiated Power (dBW)</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Cost per dBW (USD/dBW)</p> Source code in <code>src/phased_array_systems/models/swapc/cost.py</code> <pre><code>def compute_cost_per_db(total_cost_usd: float, eirp_dbw: float) -&gt; float:\n    \"\"\"Compute cost per dBW of EIRP.\n\n    Useful for comparing cost-effectiveness of different architectures.\n\n    Args:\n        total_cost_usd: Total system cost (USD)\n        eirp_dbw: Effective Isotropic Radiated Power (dBW)\n\n    Returns:\n        Cost per dBW (USD/dBW)\n    \"\"\"\n    if eirp_dbw &lt;= 0:\n        return float(\"inf\")\n    return total_cost_usd / eirp_dbw\n</code></pre>"},{"location":"api/models/swapc/#output-metrics","title":"Output Metrics","text":""},{"location":"api/models/swapc/#power-metrics","title":"Power Metrics","text":"Metric Units Description <code>rf_power_w</code> W Total RF power (all elements) <code>dc_power_w</code> W DC power (RF / PA efficiency) <code>prime_power_w</code> W Total prime power"},{"location":"api/models/swapc/#cost-metrics","title":"Cost Metrics","text":"Metric Units Description <code>recurring_cost_usd</code> USD Element cost \u00d7 count <code>nre_cost_usd</code> USD Non-recurring engineering <code>integration_cost_usd</code> USD System integration <code>cost_usd</code> USD Total cost"},{"location":"api/models/swapc/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/swapc/#power-calculation","title":"Power Calculation","text":"<pre><code>from phased_array_systems.models.swapc import PowerModel\n\n# Using PowerModel\nmodel = PowerModel()\nmetrics = model.evaluate(arch, scenario, context={})\nprint(f\"Prime Power: {metrics['prime_power_w']:.0f} W\")\nprint(f\"RF Power: {metrics['rf_power_w']:.0f} W\")\nprint(f\"DC Power: {metrics['dc_power_w']:.0f} W\")\n</code></pre>"},{"location":"api/models/swapc/#cost-calculation","title":"Cost Calculation","text":"<pre><code>from phased_array_systems.models.swapc import CostModel\n\n# Using CostModel\nmodel = CostModel()\nmetrics = model.evaluate(arch, scenario, context={})\nprint(f\"Total Cost: ${metrics['cost_usd']:,.0f}\")\nprint(f\"Recurring: ${metrics['recurring_cost_usd']:,.0f}\")\nprint(f\"NRE: ${metrics['nre_cost_usd']:,.0f}\")\n</code></pre>"},{"location":"api/models/swapc/#cost-analysis-utilities","title":"Cost Analysis Utilities","text":"<pre><code>from phased_array_systems.models.swapc.cost import compute_cost_per_watt, compute_cost_per_db\n\n# Cost efficiency metrics\ncost_per_watt = compute_cost_per_watt(total_cost_usd=50000, rf_power_w=100)\ncost_per_db = compute_cost_per_db(total_cost_usd=50000, eirp_dbw=45)\n\nprint(f\"Cost per Watt: ${cost_per_watt:.0f}/W\")\nprint(f\"Cost per dB EIRP: ${cost_per_db:.0f}/dB\")\n</code></pre>"},{"location":"api/models/swapc/#power-equations","title":"Power Equations","text":""},{"location":"api/models/swapc/#rf-power","title":"RF Power","text":"\\[ P_{RF} = P_{elem} \\times N \\]"},{"location":"api/models/swapc/#dc-power","title":"DC Power","text":"\\[ P_{DC} = \\frac{P_{RF}}{\\eta_{PA}} \\]"},{"location":"api/models/swapc/#prime-power","title":"Prime Power","text":"<p>Prime power includes additional overhead (typically DC power plus auxiliaries):</p> \\[ P_{prime} = P_{DC} \\times (1 + overhead) \\]"},{"location":"api/models/swapc/#cost-equations","title":"Cost Equations","text":""},{"location":"api/models/swapc/#recurring-cost","title":"Recurring Cost","text":"\\[ C_{recurring} = C_{elem} \\times N \\]"},{"location":"api/models/swapc/#total-cost","title":"Total Cost","text":"\\[ C_{total} = C_{recurring} + C_{NRE} + C_{integration} \\]"},{"location":"api/models/swapc/#trade-offs","title":"Trade-offs","text":""},{"location":"api/models/swapc/#power-vs-array-size","title":"Power vs. Array Size","text":"<pre><code># Power scales linearly with element count\n# For constant EIRP, larger arrays need less power per element\n\n# 8x8 at 1W each: P = 64W RF\n# 16x16 at 0.25W each: P = 64W RF, but 6dB more gain from aperture\n</code></pre>"},{"location":"api/models/swapc/#cost-vs-performance","title":"Cost vs. Performance","text":"<pre><code># Cost scaling factors:\n# - Element count: linear\n# - Power per element: typically superlinear\n# - Frequency: higher frequency = higher cost per element\n</code></pre>"},{"location":"api/models/swapc/#see-also","title":"See Also","text":"<ul> <li>Architecture API - CostConfig definition</li> <li>User Guide: Trade Studies</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>The <code>pasys</code> command-line interface provides quick access to common operations.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>The CLI is installed automatically with the package:</p> <pre><code>pip install phased-array-systems\n</code></pre> <p>Verify installation:</p> <pre><code>pasys --version\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":"Command Description <code>pasys run</code> Single-case evaluation <code>pasys doe</code> DOE batch study <code>pasys report</code> Generate report <code>pasys pareto</code> Extract Pareto frontier"},{"location":"cli/#quick-reference","title":"Quick Reference","text":"<pre><code># Single case evaluation\npasys run config.yaml\npasys run config.yaml --format json\npasys run config.yaml -o results.json\n\n# DOE batch study\npasys doe config.yaml -n 100\npasys doe config.yaml -n 100 --method lhs --seed 42\npasys doe config.yaml -n 100 -j 4  # 4 parallel workers\n\n# Generate report\npasys report results.parquet\npasys report results.parquet --format html -o report.html\npasys report results.parquet --format markdown --title \"Q4 Study\"\n\n# Extract Pareto frontier\npasys pareto results.parquet -x cost_usd -y eirp_dbw\npasys pareto results.parquet -x cost_usd -y eirp_dbw --plot\npasys pareto results.parquet -x cost_usd -y eirp_dbw -o pareto.csv\n</code></pre>"},{"location":"cli/#global-options","title":"Global Options","text":"<pre><code>pasys --version      # Show version\npasys --help         # Show help\npasys &lt;command&gt; -h   # Command-specific help\n</code></pre>"},{"location":"cli/#configuration-file-format","title":"Configuration File Format","text":"<p>All commands accept YAML or JSON configuration files:</p> <pre><code># config.yaml\nname: \"My Trade Study\"\n\narchitecture:\n  array:\n    geometry: rectangular\n    nx: 8\n    ny: 8\n    dx_lambda: 0.5\n    dy_lambda: 0.5\n  rf:\n    tx_power_w_per_elem: 1.0\n    pa_efficiency: 0.3\n  cost:\n    cost_per_elem_usd: 100.0\n\nscenario:\n  type: comms\n  freq_hz: 10.0e9\n  bandwidth_hz: 10.0e6\n  range_m: 100.0e3\n  required_snr_db: 10.0\n\nrequirements:\n  - id: REQ-001\n    name: Minimum EIRP\n    metric_key: eirp_dbw\n    op: \"&gt;=\"\n    value: 40.0\n    severity: must\n\n# For DOE (pasys doe only)\ndesign_space:\n  variables:\n    - name: array.nx\n      type: categorical\n      values: [4, 8, 16]\n    - name: rf.tx_power_w_per_elem\n      type: float\n      low: 0.5\n      high: 3.0\n</code></pre>"},{"location":"cli/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success 1 Error (file not found, invalid config, etc.)"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#complete-workflow","title":"Complete Workflow","text":"<pre><code># 1. Run DOE study\npasys doe config.yaml -n 100 --seed 42 -o ./results\n\n# 2. Extract Pareto and plot\npasys pareto results/results.parquet -x cost_usd -y eirp_dbw --plot\n\n# 3. Generate report\npasys report results/results.parquet --title \"Trade Study\" -o report.html\n</code></pre>"},{"location":"cli/#quick-evaluation","title":"Quick Evaluation","text":"<pre><code># Evaluate single configuration\npasys run config.yaml --format table\n\n# Output as JSON for scripting\npasys run config.yaml --format json | jq '.link_margin_db'\n</code></pre>"},{"location":"cli/#see-also","title":"See Also","text":"<ul> <li>User Guide: Trade Studies</li> <li>I/O API - Configuration schema</li> </ul>"},{"location":"cli/doe/","title":"pasys doe","text":"<p>Run a Design of Experiments (DOE) batch study.</p>"},{"location":"cli/doe/#synopsis","title":"Synopsis","text":"<pre><code>pasys doe &lt;config&gt; [options]\n</code></pre>"},{"location":"cli/doe/#description","title":"Description","text":"<p>The <code>doe</code> command generates a design space sample and evaluates all cases. Results are saved as Parquet files for further analysis.</p>"},{"location":"cli/doe/#arguments","title":"Arguments","text":"Argument Required Description <code>config</code> Yes Path to configuration file (YAML or JSON)"},{"location":"cli/doe/#options","title":"Options","text":"Option Short Default Description <code>--output</code> <code>-o</code> <code>./results</code> Output directory <code>--samples</code> <code>-n</code> <code>50</code> Number of DOE samples <code>--method</code> <code>lhs</code> Sampling method: <code>lhs</code>, <code>random</code>, <code>grid</code> <code>--seed</code> <code>42</code> Random seed <code>--workers</code> <code>-j</code> <code>1</code> Parallel workers"},{"location":"cli/doe/#sampling-methods","title":"Sampling Methods","text":""},{"location":"cli/doe/#latin-hypercube-sampling-lhs","title":"Latin Hypercube Sampling (LHS)","text":"<p>Default and recommended. Space-filling design:</p> <pre><code>pasys doe config.yaml -n 100 --method lhs\n</code></pre>"},{"location":"cli/doe/#random-sampling","title":"Random Sampling","text":"<p>Uniform random:</p> <pre><code>pasys doe config.yaml -n 100 --method random\n</code></pre>"},{"location":"cli/doe/#grid-sampling","title":"Grid Sampling","text":"<p>Full factorial (use with small design spaces):</p> <pre><code>pasys doe config.yaml --method grid\n# Warning: Grid size grows exponentially!\n</code></pre>"},{"location":"cli/doe/#parallel-execution","title":"Parallel Execution","text":"<p>Use multiple workers for faster evaluation:</p> <pre><code># 4 parallel workers\npasys doe config.yaml -n 200 -j 4\n</code></pre>"},{"location":"cli/doe/#output","title":"Output","text":"<p>Results are saved to the output directory:</p> <pre><code>results/\n\u2514\u2500\u2500 results.parquet    # All case results\n</code></pre> <p>The Parquet file contains:</p> <ul> <li>Case ID and configuration parameters</li> <li>All computed metrics</li> <li>Requirement verification results</li> <li>Metadata (runtime, errors)</li> </ul>"},{"location":"cli/doe/#examples","title":"Examples","text":""},{"location":"cli/doe/#basic-doe","title":"Basic DOE","text":"<pre><code>pasys doe config.yaml -n 100\n</code></pre> <p>Output:</p> <pre><code>Design Space: 5 variables\nGenerating 100 samples using lhs...\nGenerated 100 cases using Latin Hypercube Sampling\nRunning batch evaluation...\n  Progress: 10/100 (10%)\n  Progress: 20/100 (20%)\n  ...\n  Progress: 100/100 (100%)\n\nCompleted: 100 cases\nFeasible: 73 (73.0%)\n\nResults saved to: ./results/results.parquet\n</code></pre>"},{"location":"cli/doe/#full-study-pipeline","title":"Full Study Pipeline","text":"<pre><code># Run DOE with custom settings\npasys doe study_config.yaml \\\n  -n 200 \\\n  --method lhs \\\n  --seed 12345 \\\n  -j 4 \\\n  -o ./study_results\n\n# Extract Pareto\npasys pareto study_results/results.parquet -x cost_usd -y eirp_dbw\n\n# Generate report\npasys report study_results/results.parquet -o report.html\n</code></pre>"},{"location":"cli/doe/#reproducibility","title":"Reproducibility","text":"<p>Use the same seed for reproducible results:</p> <pre><code># These produce identical results\npasys doe config.yaml -n 100 --seed 42\npasys doe config.yaml -n 100 --seed 42\n</code></pre>"},{"location":"cli/doe/#configuration-requirements","title":"Configuration Requirements","text":"<p>The configuration file must include a <code>design_space</code> section:</p> <pre><code># config.yaml\nname: \"Trade Study\"\n\narchitecture:\n  # ... baseline configuration\n\nscenario:\n  # ... scenario definition\n\nrequirements:\n  # ... requirements list\n\ndesign_space:\n  variables:\n    # Variable parameters\n    - name: array.nx\n      type: categorical\n      values: [4, 8, 16]\n\n    - name: array.ny\n      type: categorical\n      values: [4, 8, 16]\n\n    - name: rf.tx_power_w_per_elem\n      type: float\n      low: 0.5\n      high: 3.0\n\n    # Fixed parameters (low == high)\n    - name: array.geometry\n      type: categorical\n      values: [rectangular]\n\n    - name: rf.pa_efficiency\n      type: float\n      low: 0.3\n      high: 0.3\n</code></pre>"},{"location":"cli/doe/#loading-results","title":"Loading Results","text":"<pre><code>import pandas as pd\n\nresults = pd.read_parquet(\"results/results.parquet\")\n\n# Feasible designs\nfeasible = results[results[\"verification.passes\"] == 1.0]\n\n# Analyze\nprint(f\"Total: {len(results)}\")\nprint(f\"Feasible: {len(feasible)}\")\nprint(f\"Cost range: ${results['cost_usd'].min():,.0f} - ${results['cost_usd'].max():,.0f}\")\n</code></pre>"},{"location":"cli/doe/#error-handling","title":"Error Handling","text":"<pre><code># Missing design_space\npasys doe config_no_doe.yaml\n# Error: Config must define a design_space for DOE\n\n# Invalid variable specification\n# Error messages indicate which variable has issues\n</code></pre>"},{"location":"cli/doe/#see-also","title":"See Also","text":"<ul> <li>pasys run - Single case evaluation</li> <li>pasys pareto - Pareto extraction</li> <li>pasys report - Report generation</li> <li>User Guide: Trade Studies</li> </ul>"},{"location":"cli/pareto/","title":"pasys pareto","text":"<p>Extract and display the Pareto frontier.</p>"},{"location":"cli/pareto/#synopsis","title":"Synopsis","text":"<pre><code>pasys pareto &lt;results&gt; -x &lt;metric&gt; -y &lt;metric&gt; [options]\n</code></pre>"},{"location":"cli/pareto/#description","title":"Description","text":"<p>The <code>pareto</code> command extracts Pareto-optimal designs from results, displays the top designs, and optionally generates a plot.</p>"},{"location":"cli/pareto/#arguments","title":"Arguments","text":"Argument Required Description <code>results</code> Yes Path to results file (Parquet or CSV)"},{"location":"cli/pareto/#options","title":"Options","text":"Option Short Required Default Description <code>-x</code> Yes X-axis metric (minimized) <code>-y</code> Yes Y-axis metric (maximized) <code>--output</code> <code>-o</code> No None Save Pareto front to file <code>--plot</code> No False Generate plot"},{"location":"cli/pareto/#objective-directions","title":"Objective Directions","text":"<p>By default: - X-axis: Minimized (e.g., cost) - Y-axis: Maximized (e.g., performance)</p> <p>This covers the common \"minimize cost, maximize performance\" trade-off.</p>"},{"location":"cli/pareto/#examples","title":"Examples","text":""},{"location":"cli/pareto/#basic-extraction","title":"Basic Extraction","text":"<pre><code>pasys pareto results.parquet -x cost_usd -y eirp_dbw\n</code></pre> <p>Output:</p> <pre><code>Pareto Frontier: 12 designs\n======================================================================\n  case_00023: cost_usd=18234.50, eirp_dbw=38.21\n  case_00045: cost_usd=23567.00, eirp_dbw=42.15\n  case_00067: cost_usd=31245.00, eirp_dbw=45.67\n  case_00012: cost_usd=42890.00, eirp_dbw=48.23\n  case_00089: cost_usd=56123.00, eirp_dbw=51.45\n  ...\n</code></pre>"},{"location":"cli/pareto/#save-to-file","title":"Save to File","text":"<pre><code>pasys pareto results.parquet -x cost_usd -y eirp_dbw -o pareto.csv\n</code></pre> <p>Creates <code>pareto.csv</code> with all Pareto-optimal designs.</p>"},{"location":"cli/pareto/#generate-plot","title":"Generate Plot","text":"<pre><code>pasys pareto results.parquet -x cost_usd -y eirp_dbw --plot\n</code></pre> <p>Creates <code>pareto_plot.png</code> showing: - All designs as blue points - Pareto-optimal designs as red points - Pareto frontier line</p>"},{"location":"cli/pareto/#save-plot-with-custom-name","title":"Save Plot with Custom Name","text":"<pre><code>pasys pareto results.parquet -x cost_usd -y eirp_dbw -o pareto.csv --plot\n# Creates: pareto.csv and pareto.png\n</code></pre>"},{"location":"cli/pareto/#common-metric-combinations","title":"Common Metric Combinations","text":""},{"location":"cli/pareto/#cost-vs-performance","title":"Cost vs. Performance","text":"<pre><code># Cost vs. EIRP (communications)\npasys pareto results.parquet -x cost_usd -y eirp_dbw\n\n# Cost vs. SNR margin\npasys pareto results.parquet -x cost_usd -y link_margin_db\n\n# Cost vs. detection range (radar)\npasys pareto results.parquet -x cost_usd -y snr_margin_db\n</code></pre>"},{"location":"cli/pareto/#power-vs-performance","title":"Power vs. Performance","text":"<pre><code># Power vs. EIRP\npasys pareto results.parquet -x prime_power_w -y eirp_dbw\n</code></pre>"},{"location":"cli/pareto/#size-vs-performance","title":"Size vs. Performance","text":"<pre><code># Element count vs. EIRP\npasys pareto results.parquet -x n_elements -y eirp_dbw\n</code></pre>"},{"location":"cli/pareto/#output-format","title":"Output Format","text":""},{"location":"cli/pareto/#display","title":"Display","text":"<p>Shows top 10 Pareto designs with: - Case ID - X metric value - Y metric value</p>"},{"location":"cli/pareto/#csv-export","title":"CSV Export","text":"<p>Full DataFrame with all columns for Pareto-optimal designs: - All input parameters - All computed metrics - Verification results - Pareto rank and score</p>"},{"location":"cli/pareto/#plot","title":"Plot","text":"<p>PNG image with: - All designs (blue circles) - Pareto-optimal designs (red circles) - Connecting line through Pareto front - Axis labels - Grid</p>"},{"location":"cli/pareto/#workflow-example","title":"Workflow Example","text":"<pre><code># 1. Run DOE\npasys doe config.yaml -n 200 -o ./study\n\n# 2. Extract Pareto frontier\npasys pareto study/results.parquet -x cost_usd -y eirp_dbw --plot -o study/pareto.csv\n\n# 3. View results\ncat study/pareto.csv | head -20\nopen study/pareto.png  # macOS\n\n# 4. Alternative trade-offs\npasys pareto study/results.parquet -x prime_power_w -y eirp_dbw --plot\n</code></pre>"},{"location":"cli/pareto/#filtering","title":"Filtering","text":"<p>The Pareto extraction uses the <code>verification.passes</code> column to filter feasible designs before extracting the frontier. Only designs that pass all \"must\" requirements are considered.</p>"},{"location":"cli/pareto/#error-handling","title":"Error Handling","text":"<pre><code># File not found\npasys pareto missing.parquet -x cost_usd -y eirp_dbw\n# Error: Results file not found: missing.parquet\n\n# Column not found\npasys pareto results.parquet -x invalid_metric -y eirp_dbw\n# Error: Column 'invalid_metric' not found in results\n</code></pre>"},{"location":"cli/pareto/#see-also","title":"See Also","text":"<ul> <li>pasys doe - Generate results</li> <li>pasys report - Full reports</li> <li>User Guide: Pareto Analysis</li> <li>Trades API - Programmatic Pareto analysis</li> </ul>"},{"location":"cli/report/","title":"pasys report","text":"<p>Generate HTML or Markdown reports from results.</p>"},{"location":"cli/report/#synopsis","title":"Synopsis","text":"<pre><code>pasys report &lt;results&gt; [options]\n</code></pre>"},{"location":"cli/report/#description","title":"Description","text":"<p>The <code>report</code> command generates formatted reports summarizing trade study results, including statistics, requirement verification, and top designs.</p>"},{"location":"cli/report/#arguments","title":"Arguments","text":"Argument Required Description <code>results</code> Yes Path to results file (Parquet or CSV)"},{"location":"cli/report/#options","title":"Options","text":"Option Short Default Description <code>--output</code> <code>-o</code> Auto Output file path <code>--format</code> <code>html</code> Report format: <code>html</code>, <code>markdown</code>, <code>md</code> <code>--title</code> Auto Report title"},{"location":"cli/report/#report-formats","title":"Report Formats","text":""},{"location":"cli/report/#html","title":"HTML","text":"<p>Standalone HTML with embedded styling:</p> <pre><code>pasys report results.parquet --format html -o report.html\n</code></pre>"},{"location":"cli/report/#markdown","title":"Markdown","text":"<p>Plain Markdown for documentation:</p> <pre><code>pasys report results.parquet --format markdown -o report.md\n# or\npasys report results.parquet --format md -o report.md\n</code></pre>"},{"location":"cli/report/#report-contents","title":"Report Contents","text":"<p>Generated reports include:</p> <ol> <li>Executive Summary</li> <li>Total cases evaluated</li> <li>Feasible design count</li> <li> <p>Pareto-optimal count</p> </li> <li> <p>Requirements Verification</p> </li> <li>Pass/fail by requirement</li> <li> <p>Overall compliance rate</p> </li> <li> <p>Statistics</p> </li> <li>Metric distributions</li> <li> <p>Variable ranges</p> </li> <li> <p>Top Designs</p> </li> <li>Ranked recommendations</li> <li>Key metrics</li> </ol>"},{"location":"cli/report/#examples","title":"Examples","text":""},{"location":"cli/report/#basic-report","title":"Basic Report","text":"<pre><code>pasys report results.parquet\n# Creates results.html (HTML by default)\n</code></pre>"},{"location":"cli/report/#custom-output","title":"Custom Output","text":"<pre><code>pasys report results.parquet -o analysis_report.html --title \"Q4 Array Analysis\"\n</code></pre>"},{"location":"cli/report/#markdown-for-documentation","title":"Markdown for Documentation","text":"<pre><code>pasys report results.parquet --format md -o RESULTS.md\n</code></pre>"},{"location":"cli/report/#from-csv","title":"From CSV","text":"<pre><code>pasys report results.csv --format html\n</code></pre>"},{"location":"cli/report/#auto-generated-output-path","title":"Auto-Generated Output Path","text":"<p>If <code>--output</code> is not specified:</p> <pre><code>pasys report results.parquet\n# Creates: results.html\n\npasys report results.parquet --format md\n# Creates: results.md\n</code></pre>"},{"location":"cli/report/#example-output","title":"Example Output","text":""},{"location":"cli/report/#html-report-structure","title":"HTML Report Structure","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Trade Study Report&lt;/title&gt;\n    &lt;style&gt;/* Embedded CSS */&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;header&gt;\n        &lt;h1&gt;Trade Study Report: results&lt;/h1&gt;\n        &lt;p&gt;Generated: 2024-01-15 10:30:00&lt;/p&gt;\n    &lt;/header&gt;\n\n    &lt;section id=\"summary\"&gt;\n        &lt;h2&gt;Executive Summary&lt;/h2&gt;\n        &lt;ul&gt;\n            &lt;li&gt;Total Cases: 100&lt;/li&gt;\n            &lt;li&gt;Feasible: 73 (73.0%)&lt;/li&gt;\n            &lt;li&gt;Pareto-optimal: 12&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/section&gt;\n\n    &lt;section id=\"requirements\"&gt;\n        &lt;h2&gt;Requirements Verification&lt;/h2&gt;\n        &lt;table&gt;...&lt;/table&gt;\n    &lt;/section&gt;\n\n    &lt;section id=\"statistics\"&gt;\n        &lt;h2&gt;Statistics&lt;/h2&gt;\n        &lt;table&gt;...&lt;/table&gt;\n    &lt;/section&gt;\n\n    &lt;footer&gt;\n        &lt;p&gt;Generated by phased-array-systems&lt;/p&gt;\n    &lt;/footer&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"cli/report/#markdown-report-structure","title":"Markdown Report Structure","text":"<pre><code># Trade Study Report: results\n\nGenerated: 2024-01-15 10:30:00\n\n## Executive Summary\n\n- Total Cases: 100\n- Feasible: 73 (73.0%)\n- Pareto-optimal: 12\n\n## Requirements Verification\n\n| ID | Name | Pass Rate |\n|----|------|-----------|\n| REQ-001 | Min EIRP | 85% |\n| REQ-002 | Max Cost | 92% |\n\n## Statistics\n\n| Metric | Min | Max | Mean |\n|--------|-----|-----|------|\n| cost_usd | 15,000 | 85,000 | 45,000 |\n| eirp_dbw | 32.1 | 52.3 | 42.5 |\n\n---\n*Generated by phased-array-systems*\n</code></pre>"},{"location":"cli/report/#workflow-example","title":"Workflow Example","text":"<pre><code># Complete workflow\npasys doe config.yaml -n 100 -o ./study\n\n# Extract Pareto\npasys pareto study/results.parquet -x cost_usd -y eirp_dbw -o study/pareto.csv\n\n# Generate report\npasys report study/results.parquet --title \"Array Trade Study\" -o study/report.html\n\n# Open report (macOS)\nopen study/report.html\n</code></pre>"},{"location":"cli/report/#error-handling","title":"Error Handling","text":"<pre><code># File not found\npasys report missing.parquet\n# Error: Results file not found: missing.parquet\n\n# Unsupported format\npasys report results.xlsx\n# Error: Unsupported format: .xlsx\n</code></pre>"},{"location":"cli/report/#see-also","title":"See Also","text":"<ul> <li>pasys doe - Generate results</li> <li>pasys pareto - Pareto extraction</li> <li>Reports API - Programmatic reports</li> </ul>"},{"location":"cli/run/","title":"pasys run","text":"<p>Evaluate a single configuration case.</p>"},{"location":"cli/run/#synopsis","title":"Synopsis","text":"<pre><code>pasys run &lt;config&gt; [options]\n</code></pre>"},{"location":"cli/run/#description","title":"Description","text":"<p>The <code>run</code> command evaluates a single architecture/scenario configuration and displays the resulting metrics. This is useful for quick checks and debugging configurations.</p>"},{"location":"cli/run/#arguments","title":"Arguments","text":"Argument Required Description <code>config</code> Yes Path to configuration file (YAML or JSON)"},{"location":"cli/run/#options","title":"Options","text":"Option Short Default Description <code>--output</code> <code>-o</code> None Save results to file <code>--format</code> <code>table</code> Output format: <code>table</code>, <code>json</code>, <code>yaml</code>"},{"location":"cli/run/#output-formats","title":"Output Formats","text":""},{"location":"cli/run/#table-default","title":"Table (default)","text":"<p>Human-readable grouped output:</p> <pre><code>pasys run config.yaml\n</code></pre> <pre><code>Results for config.yaml\n============================================================\n\nAntenna:\n  g_peak_db: 24.0821\n  beamwidth_az_deg: 12.5000\n  beamwidth_el_deg: 12.5000\n\nLink Budget:\n  eirp_dbw: 45.0821\n  path_loss_db: 152.4426\n  snr_rx_db: 17.0395\n  link_margin_db: 7.0395\n\nCost:\n  cost_usd: 21,400.0\n  recurring_cost_usd: 6,400.0\n\nPower:\n  rf_power_w: 64.0000\n  dc_power_w: 213.3333\n  prime_power_w: 213.3333\n\nMetadata:\n  meta.case_id: single_case\n  meta.runtime_s: 0.0123\n</code></pre>"},{"location":"cli/run/#json","title":"JSON","text":"<p>Machine-readable JSON:</p> <pre><code>pasys run config.yaml --format json\n</code></pre> <pre><code>{\n  \"g_peak_db\": 24.082,\n  \"eirp_dbw\": 45.082,\n  \"path_loss_db\": 152.443,\n  \"link_margin_db\": 7.040,\n  \"cost_usd\": 21400.0,\n  \"meta.case_id\": \"single_case\"\n}\n</code></pre>"},{"location":"cli/run/#yaml","title":"YAML","text":"<p>YAML output:</p> <pre><code>pasys run config.yaml --format yaml\n</code></pre> <pre><code>g_peak_db: 24.082\neirp_dbw: 45.082\npath_loss_db: 152.443\nlink_margin_db: 7.040\ncost_usd: 21400.0\n</code></pre>"},{"location":"cli/run/#saving-results","title":"Saving Results","text":"<pre><code># Save to JSON file\npasys run config.yaml -o results.json\n\n# Results are always saved as JSON\n</code></pre>"},{"location":"cli/run/#examples","title":"Examples","text":""},{"location":"cli/run/#basic-evaluation","title":"Basic Evaluation","text":"<pre><code>pasys run config.yaml\n</code></pre>"},{"location":"cli/run/#json-output-for-scripting","title":"JSON Output for Scripting","text":"<pre><code># Extract specific metric\npasys run config.yaml --format json | jq '.link_margin_db'\n\n# Check if passes threshold\nMARGIN=$(pasys run config.yaml --format json | jq '.link_margin_db')\nif (( $(echo \"$MARGIN &gt; 0\" | bc -l) )); then\n  echo \"Link closes!\"\nfi\n</code></pre>"},{"location":"cli/run/#save-and-display","title":"Save and Display","text":"<pre><code>pasys run config.yaml --format table -o results.json\n# Displays table AND saves JSON\n</code></pre>"},{"location":"cli/run/#configuration-requirements","title":"Configuration Requirements","text":"<p>The configuration file must include:</p> <ul> <li><code>architecture</code> section with <code>array</code> and <code>rf</code></li> <li><code>scenario</code> section with scenario parameters</li> </ul> <p>Optional: - <code>requirements</code> section for verification</p> <pre><code># Minimal config.yaml\narchitecture:\n  array:\n    nx: 8\n    ny: 8\n  rf:\n    tx_power_w_per_elem: 1.0\n\nscenario:\n  type: comms\n  freq_hz: 10.0e9\n  bandwidth_hz: 10.0e6\n  range_m: 100.0e3\n  required_snr_db: 10.0\n</code></pre>"},{"location":"cli/run/#error-handling","title":"Error Handling","text":"<pre><code># File not found\npasys run missing.yaml\n# Error: Config file not found: missing.yaml\n\n# Invalid configuration\npasys run invalid.yaml\n# Error: validation error for ArrayConfig\n#   nx: Input should be greater than or equal to 1\n</code></pre>"},{"location":"cli/run/#see-also","title":"See Also","text":"<ul> <li>pasys doe - Batch DOE evaluation</li> <li>I/O API - Configuration schema</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to phased-array-systems! This section will help you get up and running quickly.</p>"},{"location":"getting-started/#overview","title":"Overview","text":"<p>phased-array-systems is a Python package for phased array antenna system design and optimization. It provides:</p> <ul> <li>Architecture Configuration: Define array geometry, RF chain parameters, and cost models</li> <li>Scenario Definition: Configure communications links or radar detection scenarios</li> <li>Requirements Management: Define and verify system requirements</li> <li>Trade Studies: Run Design of Experiments (DOE) with batch evaluation</li> <li>Pareto Analysis: Extract optimal designs from multi-objective trade spaces</li> <li>Visualization: Generate plots and reports</li> </ul>"},{"location":"getting-started/#quick-navigation","title":"Quick Navigation","text":"Section Description Installation How to install the package and dependencies Quickstart Run your first analysis in 5 minutes Core Concepts Key terminology and design patterns"},{"location":"getting-started/#typical-workflow","title":"Typical Workflow","text":"<pre><code>graph TD\n    A[Define Architecture] --&gt; B[Define Scenario]\n    B --&gt; C[Set Requirements]\n    C --&gt; D{Single Case?}\n    D --&gt;|Yes| E[evaluate_case]\n    D --&gt;|No| F[Define Design Space]\n    F --&gt; G[Generate DOE]\n    G --&gt; H[Batch Evaluation]\n    H --&gt; I[Filter Feasible]\n    I --&gt; J[Extract Pareto]\n    J --&gt; K[Visualize &amp; Report]\n    E --&gt; L[Check Results]</code></pre>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or later</li> <li><code>phased-array-modeling&gt;=1.2.0</code> (installed automatically)</li> <li>Basic familiarity with:<ul> <li>Antenna arrays and phased array concepts</li> <li>Communications link budgets or radar equations</li> <li>Python and NumPy/Pandas</li> </ul> </li> </ul>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ol> <li>Install the package</li> <li>Run the quickstart example</li> <li>Learn the core concepts</li> <li>Explore the User Guide for detailed documentation</li> </ol>"},{"location":"getting-started/concepts/","title":"Core Concepts","text":"<p>This page explains the key concepts and design patterns in phased-array-systems.</p>"},{"location":"getting-started/concepts/#architecture-overview","title":"Architecture Overview","text":"<p>The package is organized around a model-based systems engineering (MBSE) workflow:</p> <pre><code>graph TB\n    subgraph Configuration\n        A[Architecture] --&gt; A1[ArrayConfig]\n        A --&gt; A2[RFChainConfig]\n        A --&gt; A3[CostConfig]\n        B[Scenario] --&gt; B1[CommsLinkScenario]\n        B --&gt; B2[RadarDetectionScenario]\n    end\n\n    subgraph Models\n        C[ModelBlock] --&gt; C1[AntennaModel]\n        C --&gt; C2[CommsLinkModel]\n        C --&gt; C3[RadarModel]\n        C --&gt; C4[SWaPCModel]\n    end\n\n    subgraph Evaluation\n        D[evaluate_case] --&gt; E[MetricsDict]\n        E --&gt; F[RequirementSet.verify]\n        F --&gt; G[VerificationReport]\n    end\n\n    A1 &amp; A2 &amp; A3 --&gt; D\n    B1 --&gt; D\n    C1 &amp; C2 &amp; C3 &amp; C4 --&gt; D</code></pre>"},{"location":"getting-started/concepts/#key-abstractions","title":"Key Abstractions","text":""},{"location":"getting-started/concepts/#architecture","title":"Architecture","text":"<p>The <code>Architecture</code> class is the top-level configuration container. It holds all parameters describing a phased array system design.</p> <pre><code>from phased_array_systems.architecture import Architecture, ArrayConfig, RFChainConfig\n\narch = Architecture(\n    array=ArrayConfig(nx=8, ny=8, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(tx_power_w_per_elem=1.0),\n    name=\"My Design\",\n)\n</code></pre> <p>Components:</p> Component Description <code>ArrayConfig</code> Array geometry: dimensions, spacing, scan limits <code>RFChainConfig</code> RF parameters: TX power, efficiency, noise figure <code>CostConfig</code> Cost model: per-element cost, NRE, integration"},{"location":"getting-started/concepts/#scenario","title":"Scenario","text":"<p>A <code>Scenario</code> defines the operating conditions for analysis. Different scenario types exist for different applications.</p> <pre><code>from phased_array_systems.scenarios import CommsLinkScenario\n\nscenario = CommsLinkScenario(\n    freq_hz=10e9,\n    bandwidth_hz=10e6,\n    range_m=100e3,\n    required_snr_db=10.0,\n)\n</code></pre> <p>Scenario Types:</p> Scenario Use Case <code>CommsLinkScenario</code> Communications link budget analysis <code>RadarDetectionScenario</code> Radar detection performance"},{"location":"getting-started/concepts/#metricsdict","title":"MetricsDict","text":"<p>All model outputs use a flat dictionary format for consistency and interoperability:</p> <pre><code>metrics = {\n    # Antenna metrics\n    \"g_peak_db\": 25.0,\n    \"beamwidth_az_deg\": 12.5,\n    \"sll_db\": -13.0,\n\n    # Link budget metrics\n    \"eirp_dbw\": 45.0,\n    \"path_loss_db\": 152.0,\n    \"snr_rx_db\": 17.0,\n    \"link_margin_db\": 7.0,\n\n    # SWaP-C metrics\n    \"cost_usd\": 21400.0,\n    \"prime_power_w\": 213.0,\n\n    # Metadata\n    \"meta.case_id\": \"case_00001\",\n    \"meta.runtime_s\": 0.05,\n}\n</code></pre> <p>Metric Categories:</p> Prefix Description (none) Core performance metrics <code>meta.</code> Case metadata (ID, runtime, errors) <code>verification.</code> Requirement verification results <code>array.</code> Array configuration parameters <code>rf.</code> RF chain parameters <code>cost.</code> Cost parameters"},{"location":"getting-started/concepts/#modelblock-protocol","title":"ModelBlock Protocol","text":"<p>All computational models follow the <code>ModelBlock</code> protocol:</p> <pre><code>from typing import Protocol\n\nclass ModelBlock(Protocol):\n    name: str\n\n    def evaluate(\n        self,\n        arch: Architecture,\n        scenario: Scenario,\n        context: dict,\n    ) -&gt; dict[str, float]:\n        \"\"\"Evaluate the model and return metrics.\"\"\"\n        ...\n</code></pre> <p>This uniform interface allows models to be composed and chained.</p>"},{"location":"getting-started/concepts/#requirements","title":"Requirements","text":"<p>Requirements are first-class objects with verification capabilities:</p> <pre><code>from phased_array_systems.requirements import Requirement, RequirementSet\n\nreq = Requirement(\n    id=\"REQ-001\",\n    name=\"Minimum EIRP\",\n    metric_key=\"eirp_dbw\",\n    op=\"&gt;=\",\n    value=40.0,\n    severity=\"must\",  # \"must\", \"should\", or \"nice\"\n)\n</code></pre> <p>Operators:</p> Operator Meaning <code>&gt;=</code> Greater than or equal <code>&lt;=</code> Less than or equal <code>&gt;</code> Greater than <code>&lt;</code> Less than <code>==</code> Equal to <p>Severities:</p> Severity Meaning <code>must</code> Required - design fails without this <code>should</code> Desired - important but not mandatory <code>nice</code> Optional - nice to have"},{"location":"getting-started/concepts/#verificationreport","title":"VerificationReport","text":"<p>The result of checking requirements against metrics:</p> <pre><code>report = requirements.verify(metrics)\n\nprint(f\"Overall: {'PASS' if report.passes else 'FAIL'}\")\nprint(f\"Must: {report.must_pass_count}/{report.must_total_count}\")\nprint(f\"Should: {report.should_pass_count}/{report.should_total_count}\")\n\nfor result in report.results:\n    print(f\"{result.requirement.id}: margin = {result.margin:.1f}\")\n</code></pre>"},{"location":"getting-started/concepts/#trade-study-concepts","title":"Trade Study Concepts","text":""},{"location":"getting-started/concepts/#design-space","title":"Design Space","text":"<p>A <code>DesignSpace</code> defines which parameters can vary and their bounds:</p> <pre><code>from phased_array_systems.trades import DesignSpace\n\nspace = (\n    DesignSpace(name=\"My Study\")\n    .add_variable(\"array.nx\", type=\"int\", low=4, high=16)\n    .add_variable(\"array.ny\", type=\"int\", low=4, high=16)\n    .add_variable(\"rf.tx_power_w_per_elem\", type=\"float\", low=0.5, high=3.0)\n    .add_variable(\"array.geometry\", type=\"categorical\", values=[\"rectangular\", \"triangular\"])\n)\n</code></pre> <p>Variable Types:</p> Type Description Example <code>int</code> Discrete integer <code>low=4, high=16</code> <code>float</code> Continuous float <code>low=0.5, high=3.0</code> <code>categorical</code> Enumerated values <code>values=[\"a\", \"b\", \"c\"]</code>"},{"location":"getting-started/concepts/#doe-design-of-experiments","title":"DOE (Design of Experiments)","text":"<p>DOE generation creates a set of cases to evaluate:</p> <pre><code>from phased_array_systems.trades import generate_doe\n\ndoe = generate_doe(space, method=\"lhs\", n_samples=100, seed=42)\n</code></pre> <p>Methods:</p> Method Description Use Case <code>lhs</code> Latin Hypercube Sampling Space-filling, efficient <code>random</code> Uniform random Quick exploration <code>grid</code> Full factorial Complete coverage (small spaces)"},{"location":"getting-started/concepts/#pareto-optimality","title":"Pareto Optimality","text":"<p>A design is Pareto-optimal if no other design is better in all objectives. The Pareto frontier represents the best trade-offs.</p> <pre><code>from phased_array_systems.trades import extract_pareto\n\nobjectives = [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n]\n\npareto = extract_pareto(results, objectives)\n</code></pre> <pre><code>graph LR\n    subgraph \"Objective Space\"\n        A[(\"Low Cost&lt;br&gt;Low EIRP\")]\n        B[(\"High Cost&lt;br&gt;High EIRP\")]\n        C[(\"Pareto&lt;br&gt;Frontier\")]\n    end\n    A --&gt; C\n    B --&gt; C</code></pre>"},{"location":"getting-started/concepts/#data-flow","title":"Data Flow","text":""},{"location":"getting-started/concepts/#single-case","title":"Single Case","text":"<pre><code>sequenceDiagram\n    participant User\n    participant evaluate_case\n    participant AntennaModel\n    participant LinkModel\n    participant CostModel\n    participant RequirementSet\n\n    User-&gt;&gt;evaluate_case: arch, scenario\n    evaluate_case-&gt;&gt;AntennaModel: evaluate()\n    AntennaModel--&gt;&gt;evaluate_case: antenna metrics\n    evaluate_case-&gt;&gt;LinkModel: evaluate(context=antenna)\n    LinkModel--&gt;&gt;evaluate_case: link metrics\n    evaluate_case-&gt;&gt;CostModel: evaluate()\n    CostModel--&gt;&gt;evaluate_case: cost metrics\n    evaluate_case--&gt;&gt;User: merged MetricsDict\n    User-&gt;&gt;RequirementSet: verify(metrics)\n    RequirementSet--&gt;&gt;User: VerificationReport</code></pre>"},{"location":"getting-started/concepts/#batch-evaluation","title":"Batch Evaluation","text":"<pre><code>sequenceDiagram\n    participant User\n    participant BatchRunner\n    participant DOE\n    participant Workers\n    participant Results\n\n    User-&gt;&gt;BatchRunner: run(doe)\n    BatchRunner-&gt;&gt;DOE: iterate cases\n    loop Each Case\n        DOE-&gt;&gt;Workers: case parameters\n        Workers-&gt;&gt;Workers: evaluate_case\n        Workers-&gt;&gt;Results: metrics\n    end\n    Results--&gt;&gt;User: DataFrame</code></pre>"},{"location":"getting-started/concepts/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"getting-started/concepts/#yaml-configuration","title":"YAML Configuration","text":"<p>Architectures and scenarios can be defined in YAML:</p> <pre><code># config.yaml\nname: \"Trade Study Config\"\n\narchitecture:\n  array:\n    geometry: rectangular\n    nx: 8\n    ny: 8\n    dx_lambda: 0.5\n    dy_lambda: 0.5\n  rf:\n    tx_power_w_per_elem: 1.0\n    pa_efficiency: 0.3\n  cost:\n    cost_per_elem_usd: 100.0\n\nscenario:\n  type: comms\n  freq_hz: 10.0e9\n  bandwidth_hz: 10.0e6\n  range_m: 100.0e3\n  required_snr_db: 10.0\n\nrequirements:\n  - id: REQ-001\n    name: Minimum EIRP\n    metric_key: eirp_dbw\n    op: \"&gt;=\"\n    value: 40.0\n</code></pre> <p>Load with:</p> <pre><code>from phased_array_systems.io import load_config\n\nconfig = load_config(\"config.yaml\")\narch = config.get_architecture()\nscenario = config.get_scenario()\n</code></pre>"},{"location":"getting-started/concepts/#flattened-parameters","title":"Flattened Parameters","text":"<p>For DOE, architectures use flattened parameter names:</p> <pre><code># Flattened dict\nflat = {\n    \"array.nx\": 8,\n    \"array.ny\": 8,\n    \"array.dx_lambda\": 0.5,\n    \"rf.tx_power_w_per_elem\": 1.0,\n    \"cost.cost_per_elem_usd\": 100.0,\n}\n\n# Convert to Architecture\narch = Architecture.from_flat(flat)\n\n# Convert back to flat\nflat = arch.model_dump_flat()\n</code></pre>"},{"location":"getting-started/concepts/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/concepts/#1-use-requirements-for-all-studies","title":"1. Use Requirements for All Studies","text":"<p>Even for exploratory work, define requirements to track feasibility:</p> <pre><code>requirements = RequirementSet(requirements=[\n    Requirement(\"FEAS-001\", \"Positive Margin\", \"link_margin_db\", \"&gt;=\", 0.0),\n])\n</code></pre>"},{"location":"getting-started/concepts/#2-set-random-seeds","title":"2. Set Random Seeds","text":"<p>For reproducibility, always set seeds:</p> <pre><code>doe = generate_doe(space, method=\"lhs\", n_samples=100, seed=42)\n</code></pre>"},{"location":"getting-started/concepts/#3-export-results","title":"3. Export Results","text":"<p>Save results for later analysis:</p> <pre><code>from phased_array_systems.io import export_results\n\nexport_results(results, \"results.parquet\")\nexport_results(pareto, \"pareto.csv\", format=\"csv\")\n</code></pre>"},{"location":"getting-started/concepts/#4-use-meaningful-case-ids","title":"4. Use Meaningful Case IDs","text":"<p>When tracking designs, use descriptive IDs:</p> <pre><code>metrics[\"meta.case_id\"] = f\"nx{arch.array.nx}_ny{arch.array.ny}_pwr{arch.rf.tx_power_w_per_elem}\"\n</code></pre>"},{"location":"getting-started/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture configuration - Detailed configuration options</li> <li>Scenarios - Communications and radar scenarios</li> <li>Requirements - Requirements management</li> <li>Trade studies - DOE and batch evaluation</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers different installation methods for phased-array-systems.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python: 3.10 or later</li> <li>Operating System: Windows, macOS, or Linux</li> <li>Dependencies: Automatically installed with the package</li> </ul>"},{"location":"getting-started/installation/#quick-install","title":"Quick Install","text":"<p>Install from PyPI using pip:</p> <pre><code>pip install phased-array-systems\n</code></pre>"},{"location":"getting-started/installation/#installation-options","title":"Installation Options","text":""},{"location":"getting-started/installation/#standard-installation","title":"Standard Installation","text":"<p>For basic usage with core dependencies:</p> <pre><code>pip install phased-array-systems\n</code></pre> <p>This installs:</p> <ul> <li><code>phased-array-modeling&gt;=1.2.0</code> - Array pattern computations</li> <li><code>numpy&gt;=1.24.0</code> - Numerical computations</li> <li><code>scipy&gt;=1.10.0</code> - Scientific computing</li> <li><code>pydantic&gt;=2.0</code> - Data validation</li> <li><code>matplotlib&gt;=3.7.0</code> - Plotting</li> <li><code>pandas&gt;=2.0.0</code> - Data manipulation</li> <li><code>pyyaml&gt;=6.0</code> - Configuration loading</li> </ul>"},{"location":"getting-started/installation/#with-plotting-extras","title":"With Plotting Extras","text":"<p>For interactive Plotly visualizations:</p> <pre><code>pip install phased-array-systems[plotting]\n</code></pre> <p>Additional packages:</p> <ul> <li><code>plotly&gt;=5.0</code> - Interactive plots</li> <li><code>kaleido&gt;=0.2</code> - Static image export</li> </ul>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For contributing or running tests:</p> <pre><code>pip install phased-array-systems[dev]\n</code></pre> <p>Additional packages:</p> <ul> <li><code>pytest&gt;=7.0</code> - Testing framework</li> <li><code>pytest-cov&gt;=4.0</code> - Coverage reporting</li> <li><code>ruff&gt;=0.1.0</code> - Linting and formatting</li> <li><code>mypy&gt;=1.0</code> - Type checking</li> <li><code>pandas-stubs&gt;=2.0</code> - Pandas type stubs</li> </ul>"},{"location":"getting-started/installation/#documentation-build","title":"Documentation Build","text":"<p>For building documentation locally:</p> <pre><code>pip install phased-array-systems[docs]\n</code></pre> <p>Additional packages:</p> <ul> <li><code>mkdocs&gt;=1.5</code> - Documentation generator</li> <li><code>mkdocs-material&gt;=9.4</code> - Material theme</li> <li><code>mkdocstrings[python]&gt;=0.24</code> - API docs from docstrings</li> <li><code>mkdocs-jupyter&gt;=0.24</code> - Jupyter notebook support</li> </ul>"},{"location":"getting-started/installation/#full-installation","title":"Full Installation","text":"<p>Install everything:</p> <pre><code>pip install phased-array-systems[dev,plotting,docs]\n</code></pre>"},{"location":"getting-started/installation/#installing-from-source","title":"Installing from Source","text":""},{"location":"getting-started/installation/#clone-and-install","title":"Clone and Install","text":"<pre><code># Clone the repository\ngit clone https://github.com/jman4162/phased-array-systems.git\ncd phased-array-systems\n\n# Create a virtual environment (recommended)\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in editable mode with all extras\npip install -e \".[dev,plotting,docs]\"\n</code></pre>"},{"location":"getting-started/installation/#using-a-virtual-environment","title":"Using a Virtual Environment","text":"<p>We recommend using a virtual environment to avoid conflicts:</p> venv (Built-in)condauv <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install phased-array-systems\n</code></pre> <pre><code>conda create -n pasys python=3.11\nconda activate pasys\npip install phased-array-systems\n</code></pre> <pre><code>uv venv\nsource .venv/bin/activate\nuv pip install phased-array-systems\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify everything works:</p> <pre><code>import phased_array_systems\nprint(phased_array_systems.__version__)\n</code></pre> <p>Or run a quick test:</p> <pre><code>from phased_array_systems.architecture import ArrayConfig\n\n# Create a simple array configuration\narray = ArrayConfig(nx=8, ny=8, dx_lambda=0.5, dy_lambda=0.5)\nprint(f\"Array has {array.n_elements} elements\")\n</code></pre> <p>Expected output:</p> <pre><code>Array has 64 elements\n</code></pre>"},{"location":"getting-started/installation/#cli-verification","title":"CLI Verification","text":"<p>The package includes a command-line interface:</p> <pre><code>pasys --version\n</code></pre> <pre><code>pasys --help\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#phased-array-modeling-not-found","title":"phased-array-modeling Not Found","text":"<p>If you see an error about <code>phased-array-modeling</code>:</p> <pre><code>pip install phased-array-modeling&gt;=1.2.0\n</code></pre>"},{"location":"getting-started/installation/#import-errors","title":"Import Errors","text":"<p>Ensure you're using the correct Python environment:</p> <pre><code>which python  # On Windows: where python\npython -c \"import phased_array_systems; print('OK')\"\n</code></pre>"},{"location":"getting-started/installation/#permission-errors","title":"Permission Errors","text":"<p>On some systems, you may need to use <code>--user</code>:</p> <pre><code>pip install --user phased-array-systems\n</code></pre> <p>Or use a virtual environment (recommended).</p>"},{"location":"getting-started/installation/#version-conflicts","title":"Version Conflicts","text":"<p>If you have conflicting packages, try a fresh environment:</p> <pre><code>python -m venv fresh_env\nsource fresh_env/bin/activate\npip install phased-array-systems\n</code></pre>"},{"location":"getting-started/installation/#upgrading","title":"Upgrading","text":"<p>To upgrade to the latest version:</p> <pre><code>pip install --upgrade phased-array-systems\n</code></pre>"},{"location":"getting-started/installation/#uninstalling","title":"Uninstalling","text":"<p>To remove the package:</p> <pre><code>pip uninstall phased-array-systems\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Run the quickstart example</li> <li>Learn core concepts</li> <li>Explore the user guide</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Get started with phased-array-systems in 5 minutes. This guide covers the essential workflow from defining an architecture to visualizing trade-offs.</p>"},{"location":"getting-started/quickstart/#single-case-evaluation","title":"Single Case Evaluation","text":"<p>The simplest use case is evaluating a single array design.</p>"},{"location":"getting-started/quickstart/#step-1-define-the-architecture","title":"Step 1: Define the Architecture","text":"<pre><code>from phased_array_systems.architecture import (\n    Architecture,\n    ArrayConfig,\n    RFChainConfig,\n    CostConfig,\n)\n\n# Define the antenna array\narray = ArrayConfig(\n    geometry=\"rectangular\",\n    nx=8,                    # 8 elements in x\n    ny=8,                    # 8 elements in y\n    dx_lambda=0.5,           # Half-wavelength spacing\n    dy_lambda=0.5,\n    scan_limit_deg=60.0,     # Max scan angle\n)\n\n# Define the RF chain\nrf = RFChainConfig(\n    tx_power_w_per_elem=1.0,  # 1 Watt per element\n    pa_efficiency=0.3,        # 30% PA efficiency\n    noise_figure_db=3.0,      # 3 dB noise figure\n)\n\n# Define cost parameters\ncost = CostConfig(\n    cost_per_elem_usd=100.0,  # $100 per element\n    nre_usd=10000.0,          # $10k NRE\n)\n\n# Combine into architecture\narch = Architecture(array=array, rf=rf, cost=cost, name=\"8x8 Baseline\")\nprint(f\"Array: {arch.array.nx}x{arch.array.ny} = {arch.n_elements} elements\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-2-define-the-scenario","title":"Step 2: Define the Scenario","text":"<pre><code>from phased_array_systems.scenarios import CommsLinkScenario\n\nscenario = CommsLinkScenario(\n    freq_hz=10e9,           # 10 GHz (X-band)\n    bandwidth_hz=10e6,      # 10 MHz bandwidth\n    range_m=100e3,          # 100 km range\n    required_snr_db=10.0,   # 10 dB required SNR\n    scan_angle_deg=0.0,     # Boresight\n    rx_antenna_gain_db=0.0, # Isotropic receiver\n    rx_noise_temp_k=290.0,  # Room temperature\n)\n</code></pre>"},{"location":"getting-started/quickstart/#step-3-evaluate","title":"Step 3: Evaluate","text":"<pre><code>from phased_array_systems.evaluate import evaluate_case\n\nmetrics = evaluate_case(arch, scenario)\n\n# Print key results\nprint(f\"EIRP: {metrics['eirp_dbw']:.1f} dBW\")\nprint(f\"Path Loss: {metrics['path_loss_db']:.1f} dB\")\nprint(f\"Received SNR: {metrics['snr_rx_db']:.1f} dB\")\nprint(f\"Link Margin: {metrics['link_margin_db']:.1f} dB\")\nprint(f\"Total Cost: ${metrics['cost_usd']:,.0f}\")\n</code></pre> <p>Expected output:</p> <pre><code>EIRP: 45.1 dBW\nPath Loss: 152.4 dB\nReceived SNR: 17.1 dB\nLink Margin: 7.1 dB\nTotal Cost: $21,400\n</code></pre>"},{"location":"getting-started/quickstart/#adding-requirements","title":"Adding Requirements","text":"<p>Verify your design meets requirements:</p> <pre><code>from phased_array_systems.requirements import Requirement, RequirementSet\n\nrequirements = RequirementSet(\n    requirements=[\n        Requirement(\n            id=\"REQ-001\",\n            name=\"Minimum EIRP\",\n            metric_key=\"eirp_dbw\",\n            op=\"&gt;=\",\n            value=40.0,\n            severity=\"must\",\n        ),\n        Requirement(\n            id=\"REQ-002\",\n            name=\"Positive Link Margin\",\n            metric_key=\"link_margin_db\",\n            op=\"&gt;=\",\n            value=0.0,\n            severity=\"must\",\n        ),\n        Requirement(\n            id=\"REQ-003\",\n            name=\"Maximum Cost\",\n            metric_key=\"cost_usd\",\n            op=\"&lt;=\",\n            value=50000.0,\n            severity=\"must\",\n        ),\n    ]\n)\n\n# Verify requirements\nreport = requirements.verify(metrics)\nprint(f\"\\nRequirements: {'PASS' if report.passes else 'FAIL'}\")\nprint(f\"  Must: {report.must_pass_count}/{report.must_total_count}\")\n\nfor result in report.results:\n    status = \"PASS\" if result.passes else \"FAIL\"\n    print(f\"  {result.requirement.id}: {status} (margin: {result.margin:.1f})\")\n</code></pre>"},{"location":"getting-started/quickstart/#trade-study-workflow","title":"Trade Study Workflow","text":"<p>For more complex analysis, run a Design of Experiments (DOE):</p>"},{"location":"getting-started/quickstart/#step-1-define-the-design-space","title":"Step 1: Define the Design Space","text":"<pre><code>from phased_array_systems.trades import DesignSpace, generate_doe\n\n# Define what parameters to vary\ndesign_space = (\n    DesignSpace(name=\"Array Trade Study\")\n    .add_variable(\"array.nx\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"array.ny\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"rf.tx_power_w_per_elem\", type=\"float\", low=0.5, high=3.0)\n    .add_variable(\"cost.cost_per_elem_usd\", type=\"float\", low=75.0, high=150.0)\n    # Fixed parameters\n    .add_variable(\"array.geometry\", type=\"categorical\", values=[\"rectangular\"])\n    .add_variable(\"array.dx_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.dy_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.enforce_subarray_constraint\", type=\"categorical\", values=[True])\n    .add_variable(\"rf.pa_efficiency\", type=\"float\", low=0.3, high=0.3)\n    .add_variable(\"rf.noise_figure_db\", type=\"float\", low=3.0, high=3.0)\n    .add_variable(\"cost.nre_usd\", type=\"float\", low=10000.0, high=10000.0)\n)\n</code></pre>"},{"location":"getting-started/quickstart/#step-2-generate-doe-and-evaluate","title":"Step 2: Generate DOE and Evaluate","text":"<pre><code>from phased_array_systems.trades import BatchRunner\n\n# Generate 50 samples using Latin Hypercube Sampling\ndoe = generate_doe(design_space, method=\"lhs\", n_samples=50, seed=42)\nprint(f\"Generated {len(doe)} cases\")\n\n# Run batch evaluation\nrunner = BatchRunner(scenario, requirements)\nresults = runner.run(doe, n_workers=1)\n\nprint(f\"Completed: {len(results)} cases\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-3-extract-pareto-frontier","title":"Step 3: Extract Pareto Frontier","text":"<pre><code>from phased_array_systems.trades import extract_pareto, filter_feasible, rank_pareto\n\n# Filter to feasible designs only\nfeasible = filter_feasible(results, requirements)\nprint(f\"Feasible: {len(feasible)} / {len(results)}\")\n\n# Extract Pareto-optimal designs (minimize cost, maximize EIRP)\nobjectives = [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n]\npareto = extract_pareto(feasible, objectives)\nprint(f\"Pareto-optimal: {len(pareto)} designs\")\n\n# Rank Pareto designs\nranked = rank_pareto(pareto, objectives, weights=[0.5, 0.5])\n\n# Show top 3\nprint(\"\\nTop 3 designs:\")\nfor _, row in ranked.head(3).iterrows():\n    print(f\"  {row['case_id']}: ${row['cost_usd']:,.0f}, {row['eirp_dbw']:.1f} dBW\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-4-visualize","title":"Step 4: Visualize","text":"<pre><code>from phased_array_systems.viz import pareto_plot\nimport matplotlib.pyplot as plt\n\n# Create feasibility mask\nfeasible_mask = results[\"verification.passes\"] == 1.0\n\n# Generate Pareto plot\nfig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    pareto_front=pareto,\n    feasible_mask=feasible_mask,\n    title=\"Cost vs EIRP Trade Space\",\n    x_label=\"Total Cost (USD)\",\n    y_label=\"EIRP (dBW)\",\n)\nplt.savefig(\"pareto_plot.png\", dpi=150, bbox_inches=\"tight\")\nplt.show()\n</code></pre>"},{"location":"getting-started/quickstart/#using-the-cli","title":"Using the CLI","text":"<p>The <code>pasys</code> command provides a quick way to run analyses:</p> <pre><code># Run a single case from config file\npasys run config.yaml\n\n# Run DOE with 100 samples\npasys doe config.yaml -n 100 --method lhs\n\n# Generate report\npasys report results.parquet --format html\n\n# Extract Pareto frontier\npasys pareto results.parquet -x cost_usd -y eirp_dbw --plot\n</code></pre>"},{"location":"getting-started/quickstart/#complete-example","title":"Complete Example","text":"<p>Here's the complete quickstart code in one block:</p> <pre><code>\"\"\"Quickstart example for phased-array-systems.\"\"\"\n\nfrom phased_array_systems.architecture import (\n    Architecture, ArrayConfig, RFChainConfig, CostConfig\n)\nfrom phased_array_systems.scenarios import CommsLinkScenario\nfrom phased_array_systems.requirements import Requirement, RequirementSet\nfrom phased_array_systems.evaluate import evaluate_case\n\n# 1. Define architecture\narch = Architecture(\n    array=ArrayConfig(nx=8, ny=8, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(tx_power_w_per_elem=1.0, pa_efficiency=0.3),\n    cost=CostConfig(cost_per_elem_usd=100.0, nre_usd=10000.0),\n)\n\n# 2. Define scenario\nscenario = CommsLinkScenario(\n    freq_hz=10e9,\n    bandwidth_hz=10e6,\n    range_m=100e3,\n    required_snr_db=10.0,\n)\n\n# 3. Define requirements\nrequirements = RequirementSet(requirements=[\n    Requirement(\"REQ-001\", \"Min EIRP\", \"eirp_dbw\", \"&gt;=\", 40.0),\n    Requirement(\"REQ-002\", \"Positive Margin\", \"link_margin_db\", \"&gt;=\", 0.0),\n    Requirement(\"REQ-003\", \"Max Cost\", \"cost_usd\", \"&lt;=\", 50000.0),\n])\n\n# 4. Evaluate\nmetrics = evaluate_case(arch, scenario)\n\n# 5. Verify requirements\nreport = requirements.verify(metrics)\n\n# 6. Print results\nprint(f\"EIRP: {metrics['eirp_dbw']:.1f} dBW\")\nprint(f\"Link Margin: {metrics['link_margin_db']:.1f} dB\")\nprint(f\"Cost: ${metrics['cost_usd']:,.0f}\")\nprint(f\"Requirements: {'PASS' if report.passes else 'FAIL'}\")\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn core concepts - Understand the architecture and design patterns</li> <li>Architecture configuration - Deep dive into configuration options</li> <li>Trade studies - Advanced DOE and optimization</li> <li>Tutorials - Step-by-step guides for common workflows</li> </ul>"},{"location":"theory/","title":"Theory","text":"<p>Background theory and equations for phased array systems.</p>"},{"location":"theory/#contents","title":"Contents","text":"Topic Description Phased Array Fundamentals Array factor, gain, beamwidth Link Budget Equations Communications link analysis Radar Equation Radar range and detection Pareto Optimization Multi-objective trade-offs"},{"location":"theory/#quick-reference","title":"Quick Reference","text":""},{"location":"theory/#antenna-gain","title":"Antenna Gain","text":"<p>For a uniform rectangular array with \\(N = n_x \\times n_y\\) elements:</p> \\[ G \\approx \\eta_a \\cdot 4\\pi \\cdot n_x d_x \\cdot n_y d_y \\] <p>Where \\(\\eta_a\\) is aperture efficiency (~0.6-0.7) and \\(d_x, d_y\\) are spacings in wavelengths.</p>"},{"location":"theory/#free-space-path-loss","title":"Free Space Path Loss","text":"\\[ L_{FSPL} = 20 \\log_{10}\\left(\\frac{4\\pi d f}{c}\\right) = 32.45 + 20\\log_{10}(f_{MHz}) + 20\\log_{10}(d_{km}) \\]"},{"location":"theory/#link-budget","title":"Link Budget","text":"\\[ \\begin{aligned} EIRP &amp;= P_{tx} + G_{tx} - L_{tx} \\\\ P_{rx} &amp;= EIRP - L_{path} + G_{rx} \\\\ SNR &amp;= P_{rx} - N \\\\ Margin &amp;= SNR - SNR_{required} \\end{aligned} \\]"},{"location":"theory/#radar-range-equation","title":"Radar Range Equation","text":"\\[ SNR = \\frac{P_t G^2 \\lambda^2 \\sigma}{(4\\pi)^3 R^4 k T_s B L} \\]"},{"location":"theory/#pareto-optimality","title":"Pareto Optimality","text":"<p>Design \\(A\\) dominates design \\(B\\) if:</p> <ul> <li>\\(f_i(A) \\leq f_i(B)\\) for all objectives (minimization)</li> <li>\\(f_j(A) &lt; f_j(B)\\) for at least one objective</li> </ul>"},{"location":"theory/#key-constants","title":"Key Constants","text":"Constant Symbol Value Speed of light \\(c\\) 299,792,458 m/s Boltzmann constant \\(k\\) 1.38\u00d710\u207b\u00b2\u00b3 J/K Reference temperature \\(T_0\\) 290 K"},{"location":"theory/#further-reading","title":"Further Reading","text":"<ul> <li>Skolnik, M.I., \"Introduction to Radar Systems\"</li> <li>Balanis, C.A., \"Antenna Theory: Analysis and Design\"</li> <li>Mailloux, R.J., \"Phased Array Antenna Handbook\"</li> </ul>"},{"location":"theory/link-budget-equations/","title":"Link Budget Equations","text":"<p>Complete derivation of communications link budget calculations.</p>"},{"location":"theory/link-budget-equations/#overview","title":"Overview","text":"<p>A link budget accounts for all gains and losses in a communications link, from transmitter to receiver.</p>"},{"location":"theory/link-budget-equations/#link-budget-equation","title":"Link Budget Equation","text":"<p>The fundamental equation:</p> \\[ P_{rx} = P_{tx} + G_{tx} - L_{tx} - L_{path} + G_{rx} - L_{rx} \\] <p>All quantities in dB.</p>"},{"location":"theory/link-budget-equations/#eirp-effective-isotropic-radiated-power","title":"EIRP (Effective Isotropic Radiated Power)","text":"<p>EIRP is the power that would be radiated by an isotropic antenna to produce the same field intensity:</p> \\[ EIRP = P_{tx} + G_{tx} - L_{tx} \\] <p>Where:</p> <ul> <li>\\(P_{tx}\\) = Transmitter power output (dBW)</li> <li>\\(G_{tx}\\) = Transmit antenna gain (dBi)</li> <li>\\(L_{tx}\\) = Transmit losses (feed, radome, etc.) (dB)</li> </ul>"},{"location":"theory/link-budget-equations/#for-phased-arrays","title":"For Phased Arrays","text":"\\[ P_{tx} = 10\\log_{10}(N \\cdot P_{elem}) \\] <p>Where \\(N\\) is element count and \\(P_{elem}\\) is power per element in watts.</p>"},{"location":"theory/link-budget-equations/#path-loss","title":"Path Loss","text":""},{"location":"theory/link-budget-equations/#free-space-path-loss-fspl","title":"Free Space Path Loss (FSPL)","text":"\\[ L_{FSPL} = 20\\log_{10}\\left(\\frac{4\\pi d f}{c}\\right) \\] <p>Or equivalently:</p> \\[ L_{FSPL} = 32.45 + 20\\log_{10}(f_{MHz}) + 20\\log_{10}(d_{km}) \\] <p>Or:</p> \\[ L_{FSPL} = 92.45 + 20\\log_{10}(f_{GHz}) + 20\\log_{10}(d_{km}) \\]"},{"location":"theory/link-budget-equations/#example-10-ghz-100-km","title":"Example: 10 GHz, 100 km","text":"\\[ L_{FSPL} = 92.45 + 20\\log_{10}(10) + 20\\log_{10}(100) = 92.45 + 20 + 40 = 152.45 \\text{ dB} \\]"},{"location":"theory/link-budget-equations/#additional-losses","title":"Additional Losses","text":"<p>Total path loss:</p> \\[ L_{path} = L_{FSPL} + L_{atm} + L_{rain} + L_{pol} + L_{misc} \\] Loss Type Typical Range Atmospheric 0.1-2 dB (depends on f, elevation) Rain fade 0-20 dB (depends on f, availability) Polarization 0-3 dB (mismatch)"},{"location":"theory/link-budget-equations/#received-power","title":"Received Power","text":"\\[ P_{rx} = EIRP - L_{path} + G_{rx} \\]"},{"location":"theory/link-budget-equations/#noise-power","title":"Noise Power","text":""},{"location":"theory/link-budget-equations/#thermal-noise","title":"Thermal Noise","text":"\\[ N = kTB \\] <p>Where:</p> <ul> <li>\\(k\\) = Boltzmann constant = 1.38\u00d710\u207b\u00b2\u00b3 J/K</li> <li>\\(T\\) = System noise temperature (K)</li> <li>\\(B\\) = Bandwidth (Hz)</li> </ul> <p>In dB:</p> \\[ N_{dBW} = 10\\log_{10}(kTB) = -228.6 + 10\\log_{10}(T) + 10\\log_{10}(B) \\]"},{"location":"theory/link-budget-equations/#system-noise-temperature","title":"System Noise Temperature","text":"\\[ T_{sys} = T_{ant} + T_{rx} \\] <p>Where:</p> \\[ T_{rx} = T_0(F - 1) \\] <ul> <li>\\(T_0\\) = Reference temperature (290 K)</li> <li>\\(F\\) = Noise figure (linear)</li> </ul>"},{"location":"theory/link-budget-equations/#noise-figure","title":"Noise Figure","text":"\\[ F_{dB} = 10\\log_{10}(F) = 10\\log_{10}\\left(1 + \\frac{T_{rx}}{T_0}\\right) \\] <p>Total noise power including noise figure:</p> \\[ N_{dBW} = 10\\log_{10}(kT_0B) + NF_{dB} \\]"},{"location":"theory/link-budget-equations/#signal-to-noise-ratio","title":"Signal-to-Noise Ratio","text":"\\[ SNR = P_{rx} - N \\] <p>Expanding:</p> \\[ SNR = EIRP - L_{path} + G_{rx} - 10\\log_{10}(kT_0B) - NF \\]"},{"location":"theory/link-budget-equations/#link-margin","title":"Link Margin","text":"\\[ M = SNR - SNR_{required} \\] <p>Positive margin indicates the link closes with room to spare.</p>"},{"location":"theory/link-budget-equations/#gt-figure-of-merit","title":"G/T Figure of Merit","text":"<p>For receive systems, G/T characterizes sensitivity:</p> \\[ \\frac{G}{T} = G_{rx} - 10\\log_{10}(T_{sys}) \\] <p>Units: dB/K</p>"},{"location":"theory/link-budget-equations/#complete-link-budget-example","title":"Complete Link Budget Example","text":"<p>Given: - Frequency: 10 GHz - Range: 100 km - TX array: 8\u00d78, 1 W/element, 65% efficiency - TX losses: 1.5 dB - RX antenna gain: 30 dBi - RX noise figure: 3 dB - RX noise temp: 290 K - Bandwidth: 10 MHz - Required SNR: 10 dB - Atmospheric loss: 0.5 dB</p> <p>Calculation:</p> <ol> <li> <p>TX Power: $$ P_{tx} = 10\\log_{10}(64 \\times 1) = 18.1 \\text{ dBW} $$</p> </li> <li> <p>TX Gain: $$ G_{tx} = 10\\log_{10}(0.65 \\times \\pi \\times 64) = 21.2 \\text{ dB} $$</p> </li> <li> <p>EIRP: $$ EIRP = 18.1 + 21.2 - 1.5 = 37.8 \\text{ dBW} $$</p> </li> <li> <p>Path Loss: $$ L_{path} = 152.4 + 0.5 = 152.9 \\text{ dB} $$</p> </li> <li> <p>Received Power: $$ P_{rx} = 37.8 - 152.9 + 30 = -85.1 \\text{ dBW} $$</p> </li> <li> <p>Noise Power: $$ N = 10\\log_{10}(1.38 \\times 10^{-23} \\times 290 \\times 10^7) + 3 = -131.0 \\text{ dBW} $$</p> </li> <li> <p>SNR: $$ SNR = -85.1 - (-131.0) = 45.9 \\text{ dB} $$</p> </li> <li> <p>Link Margin: $$ M = 45.9 - 10 = 35.9 \\text{ dB} $$</p> </li> </ol>"},{"location":"theory/link-budget-equations/#trade-offs","title":"Trade-offs","text":""},{"location":"theory/link-budget-equations/#eirp-improvements","title":"EIRP Improvements","text":"Change EIRP Gain Double TX power +3 dB Double elements (2\u00d7) +6 dB (gain + power) Double aperture +6 dB"},{"location":"theory/link-budget-equations/#reducing-path-loss","title":"Reducing Path Loss","text":"<ul> <li>Lower frequency (but larger antenna for same gain)</li> <li>Shorter range (\\(L \\propto d^2\\))</li> </ul>"},{"location":"theory/link-budget-equations/#improving-receiver","title":"Improving Receiver","text":"Change Effect Higher G/T Better sensitivity Lower NF +1 dB NF reduction = +1 dB SNR Narrower BW Lower noise (but also signal BW)"},{"location":"theory/link-budget-equations/#see-also","title":"See Also","text":"<ul> <li>Phased Array Fundamentals</li> <li>Radar Equation</li> <li>User Guide: Link Budget</li> </ul>"},{"location":"theory/pareto-optimization/","title":"Pareto Optimization","text":"<p>Theory of multi-objective optimization and Pareto analysis.</p>"},{"location":"theory/pareto-optimization/#overview","title":"Overview","text":"<p>In engineering design, we often face conflicting objectives (e.g., minimize cost while maximizing performance). Pareto optimization provides a framework for understanding these trade-offs.</p>"},{"location":"theory/pareto-optimization/#multi-objective-optimization","title":"Multi-Objective Optimization","text":""},{"location":"theory/pareto-optimization/#problem-formulation","title":"Problem Formulation","text":"<p>A multi-objective optimization problem:</p> \\[ \\begin{aligned} \\text{minimize} \\quad &amp; \\mathbf{f}(\\mathbf{x}) = [f_1(\\mathbf{x}), f_2(\\mathbf{x}), ..., f_k(\\mathbf{x})] \\\\ \\text{subject to} \\quad &amp; \\mathbf{g}(\\mathbf{x}) \\leq 0 \\\\ &amp; \\mathbf{x} \\in \\mathcal{X} \\end{aligned} \\] <p>Where:</p> <ul> <li>\\(\\mathbf{x}\\) = design variables</li> <li>\\(\\mathbf{f}\\) = objective functions</li> <li>\\(\\mathbf{g}\\) = constraints</li> <li>\\(\\mathcal{X}\\) = feasible design space</li> </ul>"},{"location":"theory/pareto-optimization/#single-vs-multi-objective","title":"Single vs. Multi-Objective","text":"Single Objective Multi-Objective One best solution Set of trade-off solutions Global optimum Pareto frontier Unique Non-unique"},{"location":"theory/pareto-optimization/#dominance","title":"Dominance","text":""},{"location":"theory/pareto-optimization/#definition","title":"Definition","text":"<p>Design \\(\\mathbf{a}\\) dominates design \\(\\mathbf{b}\\) (written \\(\\mathbf{a} \\prec \\mathbf{b}\\)) if:</p> <ol> <li>\\(f_i(\\mathbf{a}) \\leq f_i(\\mathbf{b})\\) for all objectives \\(i\\) (at least as good)</li> <li>\\(f_j(\\mathbf{a}) &lt; f_j(\\mathbf{b})\\) for at least one objective \\(j\\) (strictly better)</li> </ol>"},{"location":"theory/pareto-optimization/#example","title":"Example","text":"<p>Consider cost minimization and EIRP maximization (converted to minimization as -EIRP):</p> Design Cost -EIRP Dominated By A 20k -42 None (Pareto) B 30k -48 None (Pareto) C 25k -40 A D 35k -46 B <p>Design A dominates C because: cost(A) &lt; cost(C) and -EIRP(A) &lt; -EIRP(C).</p>"},{"location":"theory/pareto-optimization/#pareto-optimality","title":"Pareto Optimality","text":""},{"location":"theory/pareto-optimization/#definition_1","title":"Definition","text":"<p>A design \\(\\mathbf{x}^*\\) is Pareto optimal (or non-dominated) if there exists no other feasible design that dominates it.</p> <p>The set of all Pareto optimal designs forms the Pareto frontier (or Pareto front).</p>"},{"location":"theory/pareto-optimization/#properties","title":"Properties","text":"<ol> <li>Non-unique: Multiple Pareto-optimal solutions</li> <li>Trade-off: Improving one objective requires sacrificing another</li> <li>Incomparable: No Pareto solution is better than another in all objectives</li> </ol>"},{"location":"theory/pareto-optimization/#mathematical-definition","title":"Mathematical Definition","text":"\\[ \\mathcal{P} = \\{\\mathbf{x}^* \\in \\mathcal{X} : \\nexists \\mathbf{x} \\in \\mathcal{X} \\text{ such that } \\mathbf{x} \\prec \\mathbf{x}^*\\} \\]"},{"location":"theory/pareto-optimization/#pareto-frontier","title":"Pareto Frontier","text":""},{"location":"theory/pareto-optimization/#characteristics","title":"Characteristics","text":"<ul> <li>Boundary of achievable objective space</li> <li>Shape depends on problem (convex, concave, or non-convex)</li> <li>All points represent valid optimal trade-offs</li> </ul>"},{"location":"theory/pareto-optimization/#visualization-2-objectives","title":"Visualization (2 objectives)","text":"<pre><code>Performance \u2191\n    \u2502    \u25cf  \u2190 Pareto frontier\n    \u2502   \u25cf\n    \u2502  \u25cf   \u25cb \u2190 Dominated\n    \u2502 \u25cf   \u25cb\n    \u2502\u25cf   \u25cb \u25cb\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Cost\n</code></pre>"},{"location":"theory/pareto-optimization/#ranking-methods","title":"Ranking Methods","text":"<p>Since all Pareto solutions are optimal, additional criteria are needed to rank them.</p>"},{"location":"theory/pareto-optimization/#weighted-sum","title":"Weighted Sum","text":"\\[ \\min_{\\mathbf{x}} \\sum_{i=1}^{k} w_i f_i(\\mathbf{x}) \\] <p>Where \\(\\sum w_i = 1\\).</p> <p>Advantages:</p> <ul> <li>Simple</li> <li>Single-objective problem</li> </ul> <p>Limitations:</p> <ul> <li>Cannot find solutions on non-convex regions</li> <li>Sensitive to weight choice</li> </ul>"},{"location":"theory/pareto-optimization/#topsis","title":"TOPSIS","text":"<p>Technique for Order Preference by Similarity to Ideal Solution.</p> <ol> <li>Normalize objectives</li> <li>Define ideal point: \\(\\mathbf{f}^+\\) (best of each)</li> <li>Define anti-ideal: \\(\\mathbf{f}^-\\) (worst of each)</li> <li>Calculate distances:    $$    d^+ = \\sqrt{\\sum_i w_i (f_i - f_i^+)^2}    $$    $$    d^- = \\sqrt{\\sum_i w_i (f_i - f_i^-)^2}    $$</li> <li>Rank by relative closeness:    $$    C = \\frac{d^-}{d^+ + d^-}    $$</li> </ol> <p>Higher \\(C\\) is better (closer to ideal, farther from anti-ideal).</p>"},{"location":"theory/pareto-optimization/#hypervolume","title":"Hypervolume","text":"<p>The hypervolume indicator measures Pareto front quality.</p>"},{"location":"theory/pareto-optimization/#definition_2","title":"Definition","text":"<p>Volume of objective space dominated by the Pareto front, bounded by a reference point:</p> \\[ HV = \\text{Vol}\\left(\\bigcup_{i=1}^{|\\mathcal{P}|} \\{\\mathbf{f} : \\mathbf{f}_i \\prec \\mathbf{f} \\prec \\mathbf{r}\\}\\right) \\] <p>Where \\(\\mathbf{r}\\) is the reference point.</p>"},{"location":"theory/pareto-optimization/#properties_1","title":"Properties","text":"<ul> <li>Larger hypervolume = better Pareto front</li> <li>Accounts for both convergence and diversity</li> <li>Computationally expensive for many objectives</li> </ul>"},{"location":"theory/pareto-optimization/#2d-example","title":"2D Example","text":"<pre><code>Performance \u2191\n    \u2502    \u25cf r (reference)\n    \u2502   \u2588\u2502\n    \u2502  \u2588\u2588\u2502 \u2190 Hypervolume\n    \u2502 \u2588\u2588\u2588\u2502\n    \u2502\u2588\u2588\u2588\u2588\u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Cost\n</code></pre>"},{"location":"theory/pareto-optimization/#knee-points","title":"Knee Points","text":"<p>The \"knee\" of the Pareto front represents designs with the best trade-off ratio.</p>"},{"location":"theory/pareto-optimization/#detection","title":"Detection","text":"<p>For normalized objectives, the knee minimizes:</p> \\[ d = \\sqrt{f_1^2 + f_2^2 + ... + f_k^2} \\]"},{"location":"theory/pareto-optimization/#significance","title":"Significance","text":"<ul> <li>Maximum \"bang for buck\"</li> <li>Often a good compromise solution</li> <li>Insensitive to small weight changes</li> </ul>"},{"location":"theory/pareto-optimization/#algorithm-considerations","title":"Algorithm Considerations","text":""},{"location":"theory/pareto-optimization/#pareto-extraction-complexity","title":"Pareto Extraction Complexity","text":"<p>For \\(n\\) designs and \\(k\\) objectives:</p> <ul> <li>Naive: \\(O(n^2 k)\\)</li> <li>Efficient algorithms: \\(O(n \\log^{k-1} n)\\)</li> </ul>"},{"location":"theory/pareto-optimization/#epsilon-dominance","title":"Epsilon-Dominance","text":"<p>Relaxed dominance for diversity:</p> <p>\\(\\mathbf{a}\\) \\(\\varepsilon\\)-dominates \\(\\mathbf{b}\\) if:</p> \\[ f_i(\\mathbf{a}) \\leq (1 + \\varepsilon) f_i(\\mathbf{b}) \\quad \\forall i \\] <p>Reduces Pareto set size while maintaining coverage.</p>"},{"location":"theory/pareto-optimization/#application-to-phased-arrays","title":"Application to Phased Arrays","text":""},{"location":"theory/pareto-optimization/#common-objectives","title":"Common Objectives","text":"Objective Direction Metric Cost Minimize <code>cost_usd</code> EIRP Maximize <code>eirp_dbw</code> Power Minimize <code>prime_power_w</code> Mass Minimize <code>weight_kg</code> Link Margin Maximize <code>link_margin_db</code>"},{"location":"theory/pareto-optimization/#typical-trade-offs","title":"Typical Trade-offs","text":"<ol> <li>Cost vs. Performance: More elements = higher cost, better performance</li> <li>Power vs. Performance: Higher TX power = better performance, more cooling</li> <li>Size vs. Performance: Larger aperture = better gain, larger platform</li> </ol>"},{"location":"theory/pareto-optimization/#example-analysis","title":"Example Analysis","text":"<pre><code>from phased_array_systems.trades import extract_pareto, rank_pareto\n\nobjectives = [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n]\n\npareto = extract_pareto(feasible, objectives)\n\n# Rank with different weight scenarios\nscenarios = {\n    \"Cost-focused\": [0.8, 0.2],\n    \"Balanced\": [0.5, 0.5],\n    \"Performance-focused\": [0.2, 0.8],\n}\n\nfor name, weights in scenarios.items():\n    ranked = rank_pareto(pareto, objectives, weights=weights)\n    best = ranked.iloc[0]\n    print(f\"{name}: {best['case_id']}, ${best['cost_usd']:,.0f}, {best['eirp_dbw']:.1f} dBW\")\n</code></pre>"},{"location":"theory/pareto-optimization/#best-practices","title":"Best Practices","text":"<ol> <li>Verify feasibility first: Filter infeasible designs before Pareto extraction</li> <li>Choose meaningful objectives: Avoid redundant or correlated objectives</li> <li>Consider stakeholders: Different weights for different decision-makers</li> <li>Present the frontier: Show trade-offs, not just one solution</li> <li>Document decisions: Record rationale for final selection</li> </ol>"},{"location":"theory/pareto-optimization/#see-also","title":"See Also","text":"<ul> <li>User Guide: Pareto Analysis</li> <li>User Guide: Trade Studies</li> <li>API Reference: Trades</li> </ul>"},{"location":"theory/phased-arrays/","title":"Phased Array Fundamentals","text":"<p>Theory of phased array antenna operation.</p>"},{"location":"theory/phased-arrays/#overview","title":"Overview","text":"<p>A phased array is an antenna system that uses multiple radiating elements with controlled phase and amplitude to electronically steer the beam without mechanical movement.</p>"},{"location":"theory/phased-arrays/#array-factor","title":"Array Factor","text":"<p>The array factor describes the radiation pattern contribution from element positioning:</p> \\[ AF(\\theta, \\phi) = \\sum_{n=1}^{N} a_n e^{j(k \\mathbf{r}_n \\cdot \\hat{\\mathbf{r}} + \\alpha_n)} \\] <p>Where:</p> <ul> <li>\\(a_n\\) = amplitude weight of element \\(n\\)</li> <li>\\(k = 2\\pi/\\lambda\\) = wavenumber</li> <li>\\(\\mathbf{r}_n\\) = position of element \\(n\\)</li> <li>\\(\\hat{\\mathbf{r}}\\) = unit vector in observation direction</li> <li>\\(\\alpha_n\\) = phase of element \\(n\\)</li> </ul>"},{"location":"theory/phased-arrays/#linear-array","title":"Linear Array","text":"<p>For a uniform linear array along the z-axis with spacing \\(d\\):</p> \\[ AF(\\theta) = \\sum_{n=0}^{N-1} e^{jn(kd\\cos\\theta + \\beta)} \\] <p>Where \\(\\beta\\) is the progressive phase shift.</p> <p>Closed form:</p> \\[ AF(\\theta) = \\frac{\\sin(N\\psi/2)}{\\sin(\\psi/2)}, \\quad \\psi = kd\\cos\\theta + \\beta \\]"},{"location":"theory/phased-arrays/#rectangular-planar-array","title":"Rectangular Planar Array","text":"<p>For an \\(N_x \\times N_y\\) array:</p> \\[ AF(\\theta, \\phi) = AF_x(\\theta, \\phi) \\cdot AF_y(\\theta, \\phi) \\] \\[ AF_x = \\frac{\\sin(N_x \\psi_x / 2)}{\\sin(\\psi_x / 2)}, \\quad \\psi_x = kd_x \\sin\\theta\\cos\\phi + \\beta_x \\] \\[ AF_y = \\frac{\\sin(N_y \\psi_y / 2)}{\\sin(\\psi_y / 2)}, \\quad \\psi_y = kd_y \\sin\\theta\\sin\\phi + \\beta_y \\]"},{"location":"theory/phased-arrays/#antenna-gain","title":"Antenna Gain","text":""},{"location":"theory/phased-arrays/#directivity","title":"Directivity","text":"<p>The directivity is the ratio of radiation intensity in a given direction to the average:</p> \\[ D = \\frac{4\\pi U(\\theta, \\phi)}{P_{rad}} \\] <p>Peak directivity for a uniform array (boresight):</p> \\[ D_0 \\approx \\frac{4\\pi A_{eff}}{\\lambda^2} = \\frac{4\\pi}{\\lambda^2} \\cdot N_x d_x \\cdot N_y d_y \\cdot \\lambda^2 = 4\\pi N_x d_x N_y d_y \\]"},{"location":"theory/phased-arrays/#gain","title":"Gain","text":"<p>Gain includes efficiency:</p> \\[ G = \\eta_a \\cdot D \\] <p>Where aperture efficiency \\(\\eta_a\\) typically ranges from 0.5 to 0.8.</p> <p>For uniform amplitude and half-wavelength spacing (\\(d = 0.5\\lambda\\)):</p> \\[ G \\approx \\eta_a \\cdot \\pi \\cdot N_x \\cdot N_y \\] <p>In dB:</p> \\[ G_{dB} = 10\\log_{10}(\\eta_a \\cdot \\pi \\cdot N) \\] <p>For \\(\\eta_a = 0.65\\) and \\(N = 64\\) elements:</p> \\[ G_{dB} = 10\\log_{10}(0.65 \\cdot \\pi \\cdot 64) \\approx 22.1 \\text{ dB} \\]"},{"location":"theory/phased-arrays/#beamwidth","title":"Beamwidth","text":""},{"location":"theory/phased-arrays/#half-power-beamwidth-hpbw","title":"Half-Power Beamwidth (HPBW)","text":"<p>For a uniform linear array:</p> \\[ \\theta_{3dB} \\approx \\frac{0.886 \\lambda}{N d \\cos\\theta_0} \\] <p>At boresight (\\(\\theta_0 = 0\\)) with \\(d = 0.5\\lambda\\):</p> \\[ \\theta_{3dB} \\approx \\frac{1.77}{N} \\text{ radians} = \\frac{101\u00b0}{N} \\] <p>For a rectangular array:</p> \\[ \\theta_{3dB,x} \\approx \\frac{101\u00b0}{N_x}, \\quad \\theta_{3dB,y} \\approx \\frac{101\u00b0}{N_y} \\]"},{"location":"theory/phased-arrays/#examples","title":"Examples","text":"Array Elements HPBW 8\u00d78 64 12.6\u00b0 \u00d7 12.6\u00b0 16\u00d716 256 6.3\u00b0 \u00d7 6.3\u00b0 32\u00d732 1024 3.2\u00b0 \u00d7 3.2\u00b0"},{"location":"theory/phased-arrays/#beam-steering","title":"Beam Steering","text":"<p>Electronic beam steering is achieved by applying a progressive phase shift:</p> \\[ \\beta_x = -kd_x \\sin\\theta_0 \\cos\\phi_0 $$ $$ \\beta_y = -kd_y \\sin\\theta_0 \\sin\\phi_0 \\] <p>Where \\((\\theta_0, \\phi_0)\\) is the desired beam direction.</p>"},{"location":"theory/phased-arrays/#scan-loss","title":"Scan Loss","text":"<p>When scanning off boresight, gain is reduced:</p> \\[ G(\\theta) \\approx G_0 \\cos^p(\\theta) \\] <p>Where \\(p\\) depends on element pattern (typically \\(p \\approx 1.2-1.5\\)).</p> <p>Approximate scan loss:</p> Scan Angle Approximate Loss 0\u00b0 0 dB 30\u00b0 1-2 dB 45\u00b0 2-3 dB 60\u00b0 3-5 dB"},{"location":"theory/phased-arrays/#grating-lobes","title":"Grating Lobes","text":"<p>Grating lobes appear when element spacing exceeds \\(\\lambda\\). To avoid grating lobes when scanning to angle \\(\\theta_0\\):</p> \\[ d &lt; \\frac{\\lambda}{1 + |\\sin\\theta_0|} \\] <p>For \\(\\theta_0 = 60\u00b0\\):</p> \\[ d &lt; \\frac{\\lambda}{1 + \\sin(60\u00b0)} = \\frac{\\lambda}{1.866} \\approx 0.54\\lambda \\] <p>This is why half-wavelength spacing (\\(d = 0.5\\lambda\\)) is common.</p>"},{"location":"theory/phased-arrays/#sidelobe-level","title":"Sidelobe Level","text":"<p>For a uniform amplitude array, the first sidelobe is approximately -13.2 dB below the main lobe.</p>"},{"location":"theory/phased-arrays/#tapering","title":"Tapering","text":"<p>Amplitude tapering reduces sidelobes at the cost of beamwidth and gain:</p> Taper First SLL Beamwidth Factor Efficiency Uniform -13.2 dB 1.0 1.0 Hamming -42 dB 1.36 0.73 Taylor -25 dB -25 dB 1.1 0.95 Taylor -35 dB -35 dB 1.2 0.87"},{"location":"theory/phased-arrays/#power-and-eirp","title":"Power and EIRP","text":""},{"location":"theory/phased-arrays/#total-radiated-power","title":"Total Radiated Power","text":"\\[ P_{rad} = N \\cdot P_{elem} \\cdot \\eta_{feed} \\] <p>Where:</p> <ul> <li>\\(N\\) = number of elements</li> <li>\\(P_{elem}\\) = power per element</li> <li>\\(\\eta_{feed}\\) = feed network efficiency</li> </ul>"},{"location":"theory/phased-arrays/#eirp","title":"EIRP","text":"<p>Effective Isotropic Radiated Power:</p> \\[ EIRP = P_{rad} \\cdot G = N \\cdot P_{elem} \\cdot \\eta_{feed} \\cdot G \\] <p>In dB:</p> \\[ EIRP_{dBW} = P_{rad,dBW} + G_{dB} \\]"},{"location":"theory/phased-arrays/#example-calculation","title":"Example Calculation","text":"<p>For an 8\u00d78 array with:</p> <ul> <li>\\(d_x = d_y = 0.5\\lambda\\)</li> <li>\\(P_{elem} = 1\\) W</li> <li>\\(\\eta_a = 0.65\\)</li> <li>\\(\\eta_{feed} = 0.8\\)</li> </ul> <p>Gain: $$ G = 0.65 \\cdot \\pi \\cdot 64 = 130.7 = 21.2 \\text{ dB} $$</p> <p>Radiated Power: $$ P_{rad} = 64 \\cdot 1 \\cdot 0.8 = 51.2 \\text{ W} = 17.1 \\text{ dBW} $$</p> <p>EIRP: $$ EIRP = 17.1 + 21.2 = 38.3 \\text{ dBW} $$</p> <p>Beamwidth: $$ \\theta_{3dB} \\approx \\frac{101\u00b0}{8} = 12.6\u00b0 $$</p>"},{"location":"theory/phased-arrays/#see-also","title":"See Also","text":"<ul> <li>Link Budget Equations</li> <li>Radar Equation</li> <li>User Guide: Architecture</li> </ul>"},{"location":"theory/radar-equation/","title":"Radar Equation","text":"<p>Derivation and application of the radar range equation.</p>"},{"location":"theory/radar-equation/#overview","title":"Overview","text":"<p>The radar equation relates transmitter power, antenna gain, target characteristics, and receiver sensitivity to determine detection capability.</p>"},{"location":"theory/radar-equation/#basic-radar-equation","title":"Basic Radar Equation","text":""},{"location":"theory/radar-equation/#power-density-at-target","title":"Power Density at Target","text":"<p>Power density at range \\(R\\) from an isotropic radiator:</p> \\[ S_i = \\frac{P_t}{4\\pi R^2} \\] <p>With transmit antenna gain \\(G_t\\):</p> \\[ S_t = \\frac{P_t G_t}{4\\pi R^2} \\]"},{"location":"theory/radar-equation/#power-reflected-by-target","title":"Power Reflected by Target","text":"<p>The target intercepts and re-radiates power proportional to its radar cross section (RCS) \\(\\sigma\\):</p> \\[ P_{reflected} = S_t \\cdot \\sigma = \\frac{P_t G_t \\sigma}{4\\pi R^2} \\]"},{"location":"theory/radar-equation/#power-density-at-receiver","title":"Power Density at Receiver","text":"<p>The reflected power spreads again over \\(4\\pi R^2\\):</p> \\[ S_r = \\frac{P_t G_t \\sigma}{(4\\pi)^2 R^4} \\]"},{"location":"theory/radar-equation/#received-power","title":"Received Power","text":"<p>The receiver antenna with effective area \\(A_e\\) captures:</p> \\[ P_r = S_r \\cdot A_e = \\frac{P_t G_t \\sigma A_e}{(4\\pi)^2 R^4} \\] <p>Using \\(A_e = G_r \\lambda^2 / 4\\pi\\):</p> \\[ P_r = \\frac{P_t G_t G_r \\lambda^2 \\sigma}{(4\\pi)^3 R^4} \\] <p>For monostatic radar (\\(G_t = G_r = G\\)):</p> \\[ P_r = \\frac{P_t G^2 \\lambda^2 \\sigma}{(4\\pi)^3 R^4} \\]"},{"location":"theory/radar-equation/#snr-form","title":"SNR Form","text":"<p>Including noise and losses:</p> \\[ SNR = \\frac{P_t G^2 \\lambda^2 \\sigma}{(4\\pi)^3 R^4 k T_s B_n L_s} \\] <p>Where:</p> <ul> <li>\\(P_t\\) = Peak transmit power (W)</li> <li>\\(G\\) = Antenna gain (linear)</li> <li>\\(\\lambda\\) = Wavelength (m)</li> <li>\\(\\sigma\\) = Target RCS (m\u00b2)</li> <li>\\(R\\) = Range (m)</li> <li>\\(k\\) = Boltzmann constant = 1.38\u00d710\u207b\u00b2\u00b3 J/K</li> <li>\\(T_s\\) = System noise temperature (K)</li> <li>\\(B_n\\) = Noise bandwidth (Hz)</li> <li>\\(L_s\\) = System losses (linear)</li> </ul>"},{"location":"theory/radar-equation/#range-form","title":"Range Form","text":"<p>Solving for range at minimum detectable SNR:</p> \\[ R_{max} = \\left[\\frac{P_t G^2 \\lambda^2 \\sigma}{(4\\pi)^3 k T_s B_n L_s \\cdot SNR_{min}}\\right]^{1/4} \\]"},{"location":"theory/radar-equation/#pulse-integration","title":"Pulse Integration","text":""},{"location":"theory/radar-equation/#coherent-integration","title":"Coherent Integration","text":"<p>For \\(N\\) coherently integrated pulses:</p> \\[ SNR_N = N \\cdot SNR_1 \\] <p>The integration gain is \\(N\\) (linear) or \\(10\\log_{10}(N)\\) dB.</p>"},{"location":"theory/radar-equation/#non-coherent-integration","title":"Non-Coherent Integration","text":"<p>For non-coherent integration:</p> \\[ SNR_N \\approx \\sqrt{N} \\cdot SNR_1 \\] <p>More precisely, the integration gain depends on the required \\(P_d\\) and \\(P_{fa}\\).</p>"},{"location":"theory/radar-equation/#detection-theory","title":"Detection Theory","text":""},{"location":"theory/radar-equation/#single-pulse-detection","title":"Single-Pulse Detection","text":"<p>For a Gaussian noise background and non-fluctuating target (Swerling 0), the detection probability relates to SNR through:</p> \\[ P_d = \\frac{1}{2}\\text{erfc}\\left[\\text{erfc}^{-1}(2P_{fa}) - \\sqrt{SNR}\\right] \\]"},{"location":"theory/radar-equation/#required-snr","title":"Required SNR","text":"<p>For given \\(P_d\\) and \\(P_{fa}\\):</p> \\[ SNR_{req} \\approx \\ln\\left(\\frac{1}{P_{fa}}\\right) + \\ln\\left(\\frac{1}{1-P_d}\\right) \\] <p>More accurate:</p> \\(P_d\\) \\(P_{fa} = 10^{-6}\\) \\(P_{fa} = 10^{-9}\\) 0.5 10.8 dB 12.6 dB 0.9 13.1 dB 14.9 dB 0.99 16.4 dB 18.2 dB"},{"location":"theory/radar-equation/#swerling-target-models","title":"Swerling Target Models","text":"Model PDF Decorrelation 0 Constant (non-fluctuating) - 1 Exponential (Rayleigh amplitude) Scan-to-scan 2 Exponential Pulse-to-pulse 3 Chi-squared, 4 DOF Scan-to-scan 4 Chi-squared, 4 DOF Pulse-to-pulse"},{"location":"theory/radar-equation/#snr-penalty","title":"SNR Penalty","text":"<p>Fluctuating targets require additional SNR:</p> Model Typical Penalty vs. SW0 SW1 +3 to +8 dB (depends on \\(P_d\\)) SW2 +2 to +5 dB SW3 +1 to +3 dB SW4 +1 to +2 dB"},{"location":"theory/radar-equation/#power-aperture-product","title":"Power-Aperture Product","text":"<p>Radar performance fundamentally scales with:</p> \\[ PA = P_t \\cdot A = P_t \\cdot \\frac{G\\lambda^2}{4\\pi} \\] <p>For a given target and detection requirement:</p> \\[ R_{max}^4 \\propto PA \\] <p>Trade-off: Higher power OR larger aperture.</p>"},{"location":"theory/radar-equation/#example-calculation","title":"Example Calculation","text":"<p>Given: - Frequency: 10 GHz (\\(\\lambda\\) = 0.03 m) - Array: 16\u00d716 elements, G = 30 dBi - TX power: 10 W/element, 256 elements \u2192 2560 W peak - Target RCS: 1 m\u00b2 - Range: 100 km - Noise temp: 400 K - Losses: 4 dB (\\(L_s\\) = 2.51) - Pulse width: 10 \u03bcs \u2192 \\(B_n\\) \u2248 100 kHz</p> <p>Calculate:</p> <ol> <li> <p>Wavelength: \\(\\lambda\\) = 0.03 m</p> </li> <li> <p>Gain (linear): \\(G\\) = 10^(30/10) = 1000</p> </li> <li> <p>Numerator: $$ P_t G^2 \\lambda^2 \\sigma = 2560 \\times 1000^2 \\times 0.03^2 \\times 1 = 2.3 \\times 10^6 $$</p> </li> <li> <p>Denominator: $$ (4\\pi)^3 R^4 k T_s B_n L_s = 1984 \\times 10^{20} \\times 1.38 \\times 10^{-23} \\times 400 \\times 10^5 \\times 2.51 $$ $$ = 2.74 \\times 10^6 $$</p> </li> <li> <p>SNR (single pulse): $$ SNR = \\frac{2.3 \\times 10^6}{2.74 \\times 10^6} = 0.84 = -0.75 \\text{ dB} $$</p> </li> <li> <p>With 10-pulse coherent integration: $$ SNR_{10} = -0.75 + 10 = 9.25 \\text{ dB} $$</p> </li> <li> <p>Required SNR for \\(P_d\\) = 0.9, \\(P_{fa}\\) = 10\u207b\u2076, SW1 \u2248 17 dB</p> </li> <li> <p>SNR Margin: $$ M = 9.25 - 17 = -7.75 \\text{ dB} \\quad \\text{(insufficient)} $$</p> </li> </ol> <p>Need more power, more elements, or shorter range.</p>"},{"location":"theory/radar-equation/#range-dependencies","title":"Range Dependencies","text":"Quantity Range Dependence \\(P_r\\) \\(R^{-4}\\) \\(SNR\\) \\(R^{-4}\\) Double range -12 dB SNR Half range +12 dB SNR"},{"location":"theory/radar-equation/#see-also","title":"See Also","text":"<ul> <li>Phased Array Fundamentals</li> <li>Link Budget Equations</li> <li>User Guide: Radar Detection</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step guides for common workflows with phased-array-systems.</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":"Tutorial Description Level Communications Trade Study Complete DOE workflow for comms links Beginner Radar Detection Trade Radar system trade study Intermediate Config-Driven Workflow YAML-based analysis Beginner Sensitivity Analysis Parameter sensitivity studies Intermediate"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ol> <li>Installed phased-array-systems: <code>pip install phased-array-systems[plotting]</code></li> <li>Basic Python familiarity</li> <li>Understanding of phased arrays (see Core Concepts)</li> </ol>"},{"location":"tutorials/#tutorial-structure","title":"Tutorial Structure","text":"<p>Each tutorial includes:</p> <ul> <li>Objective: What you'll learn</li> <li>Setup: Required imports and data</li> <li>Steps: Detailed walkthrough</li> <li>Complete Code: Full working example</li> <li>Next Steps: Related topics</li> </ul>"},{"location":"tutorials/#quick-start-path","title":"Quick Start Path","text":"<p>For new users, we recommend:</p> <ol> <li>Start with Communications Trade Study</li> <li>Try the Config-Driven Workflow</li> <li>Explore Sensitivity Analysis</li> </ol> <p>For radar applications:</p> <ol> <li>Start with Radar Detection Trade</li> </ol>"},{"location":"tutorials/#jupyter-notebooks","title":"Jupyter Notebooks","text":"<p>Interactive versions are available:</p> <p></p>"},{"location":"tutorials/#example-files","title":"Example Files","text":"<p>The tutorials reference example files in the repository:</p> <pre><code>examples/\n\u251c\u2500\u2500 01_comms_single_case.py      # Single evaluation\n\u251c\u2500\u2500 02_comms_doe_trade.py        # DOE workflow\n\u2514\u2500\u2500 03_radar_detection_trade.py  # Radar analysis\n</code></pre> <p>Run them locally:</p> <pre><code>cd examples\npython 01_comms_single_case.py\npython 02_comms_doe_trade.py\n</code></pre>"},{"location":"tutorials/comms-trade-study/","title":"Tutorial: Communications Trade Study","text":"<p>A complete walkthrough of designing a phased array for a communications link using DOE and Pareto analysis.</p>"},{"location":"tutorials/comms-trade-study/#objective","title":"Objective","text":"<p>By the end of this tutorial, you will:</p> <ul> <li>Define a communications scenario with requirements</li> <li>Create a design space for trade study</li> <li>Run a DOE batch evaluation</li> <li>Extract and rank Pareto-optimal designs</li> <li>Visualize trade-offs</li> <li>Export results</li> </ul>"},{"location":"tutorials/comms-trade-study/#scenario","title":"Scenario","text":"<p>Design a phased array for a 100 km X-band communications link with:</p> <ul> <li>Minimum 35 dBW EIRP</li> <li>Positive link margin</li> <li>Budget constraint of $100,000</li> </ul>"},{"location":"tutorials/comms-trade-study/#step-1-setup","title":"Step 1: Setup","text":"<pre><code>\"\"\"Communications array trade study tutorial.\"\"\"\n\nimport matplotlib\nmatplotlib.use(\"Agg\")  # For non-interactive environments\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\nfrom phased_array_systems.architecture import Architecture, ArrayConfig, RFChainConfig, CostConfig\nfrom phased_array_systems.scenarios import CommsLinkScenario\nfrom phased_array_systems.requirements import Requirement, RequirementSet\nfrom phased_array_systems.evaluate import evaluate_case\nfrom phased_array_systems.trades import (\n    DesignSpace,\n    generate_doe,\n    BatchRunner,\n    filter_feasible,\n    extract_pareto,\n    rank_pareto,\n)\nfrom phased_array_systems.viz import pareto_plot, scatter_matrix\nfrom phased_array_systems.io import export_results\n</code></pre>"},{"location":"tutorials/comms-trade-study/#step-2-define-the-scenario","title":"Step 2: Define the Scenario","text":"<pre><code># Fixed operating conditions\nscenario = CommsLinkScenario(\n    freq_hz=10e9,              # 10 GHz (X-band)\n    bandwidth_hz=10e6,         # 10 MHz bandwidth\n    range_m=100e3,             # 100 km range\n    required_snr_db=10.0,      # Required for demodulation\n    scan_angle_deg=0.0,        # Boresight\n    rx_antenna_gain_db=0.0,    # Isotropic receiver (worst case)\n    rx_noise_temp_k=290.0,     # Room temperature\n)\n\nprint(f\"Scenario: {scenario.freq_hz/1e9:.1f} GHz, {scenario.range_m/1e3:.0f} km\")\n</code></pre>"},{"location":"tutorials/comms-trade-study/#step-3-define-requirements","title":"Step 3: Define Requirements","text":"<pre><code>requirements = RequirementSet(\n    requirements=[\n        Requirement(\n            id=\"REQ-001\",\n            name=\"Minimum EIRP\",\n            metric_key=\"eirp_dbw\",\n            op=\"&gt;=\",\n            value=35.0,\n            units=\"dBW\",\n            severity=\"must\",\n        ),\n        Requirement(\n            id=\"REQ-002\",\n            name=\"Positive Link Margin\",\n            metric_key=\"link_margin_db\",\n            op=\"&gt;=\",\n            value=0.0,\n            units=\"dB\",\n            severity=\"must\",\n        ),\n        Requirement(\n            id=\"REQ-003\",\n            name=\"Maximum Cost\",\n            metric_key=\"cost_usd\",\n            op=\"&lt;=\",\n            value=100000.0,\n            units=\"USD\",\n            severity=\"must\",\n        ),\n    ],\n    name=\"Comms Link Requirements\",\n)\n\nprint(f\"Requirements: {len(requirements)} defined\")\nfor req in requirements:\n    print(f\"  {req.id}: {req.name} ({req.metric_key} {req.op} {req.value})\")\n</code></pre>"},{"location":"tutorials/comms-trade-study/#step-4-define-the-design-space","title":"Step 4: Define the Design Space","text":"<pre><code>design_space = (\n    DesignSpace(name=\"Comms Array Trade Study\")\n    # Variable parameters (what we're exploring)\n    .add_variable(\"array.nx\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"array.ny\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"rf.tx_power_w_per_elem\", type=\"float\", low=0.5, high=3.0)\n    .add_variable(\"rf.pa_efficiency\", type=\"float\", low=0.2, high=0.5)\n    .add_variable(\"cost.cost_per_elem_usd\", type=\"float\", low=75.0, high=150.0)\n    # Fixed parameters (constants across all cases)\n    .add_variable(\"array.geometry\", type=\"categorical\", values=[\"rectangular\"])\n    .add_variable(\"array.dx_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.dy_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.scan_limit_deg\", type=\"float\", low=60.0, high=60.0)\n    .add_variable(\"array.enforce_subarray_constraint\", type=\"categorical\", values=[True])\n    .add_variable(\"rf.noise_figure_db\", type=\"float\", low=3.0, high=3.0)\n    .add_variable(\"rf.n_tx_beams\", type=\"int\", low=1, high=1)\n    .add_variable(\"rf.feed_loss_db\", type=\"float\", low=1.0, high=1.0)\n    .add_variable(\"rf.system_loss_db\", type=\"float\", low=0.0, high=0.0)\n    .add_variable(\"cost.nre_usd\", type=\"float\", low=10000.0, high=10000.0)\n    .add_variable(\"cost.integration_cost_usd\", type=\"float\", low=5000.0, high=5000.0)\n)\n\nprint(f\"\\nDesign Space: {design_space.n_dims} dimensions\")\nprint(\"Variable ranges:\")\nfor var in design_space.variables:\n    if var.type == \"categorical\" and len(var.values) &gt; 1:\n        print(f\"  {var.name}: {var.values}\")\n    elif hasattr(var, 'low') and hasattr(var, 'high') and var.low != var.high:\n        print(f\"  {var.name}: [{var.low}, {var.high}]\")\n</code></pre>"},{"location":"tutorials/comms-trade-study/#step-5-generate-doe","title":"Step 5: Generate DOE","text":"<pre><code>n_samples = 100\nseed = 42\n\ndoe = generate_doe(\n    design_space,\n    method=\"lhs\",  # Latin Hypercube Sampling\n    n_samples=n_samples,\n    seed=seed,\n)\n\nprint(f\"\\nGenerated {len(doe)} cases using LHS (seed={seed})\")\nprint(f\"Columns: {list(doe.columns)[:5]}...\")\n</code></pre>"},{"location":"tutorials/comms-trade-study/#step-6-run-batch-evaluation","title":"Step 6: Run Batch Evaluation","text":"<pre><code>runner = BatchRunner(scenario, requirements)\n\ndef progress_callback(completed, total):\n    if completed % 20 == 0 or completed == total:\n        pct = completed / total * 100\n        print(f\"  Progress: {completed}/{total} ({pct:.0f}%)\")\n\nprint(\"\\nRunning batch evaluation...\")\nresults = runner.run(doe, n_workers=1, progress_callback=progress_callback)\n\n# Check for errors\nn_errors = results[\"meta.error\"].notna().sum()\nif n_errors &gt; 0:\n    print(f\"Warning: {n_errors} cases had errors\")\n\nprint(f\"\\nCompleted: {len(results)} cases\")\n</code></pre>"},{"location":"tutorials/comms-trade-study/#step-7-analyze-results","title":"Step 7: Analyze Results","text":"<pre><code># Create feasibility mask\nfeasible_mask = results[\"verification.passes\"] == 1.0\n\n# Filter to feasible\nfeasible = filter_feasible(results, requirements)\n\nn_total = len(results)\nn_feasible = len(feasible)\nfeasible_pct = n_feasible / n_total * 100\n\nprint(f\"\\nFeasibility Analysis:\")\nprint(f\"  Total cases: {n_total}\")\nprint(f\"  Feasible: {n_feasible} ({feasible_pct:.1f}%)\")\nprint(f\"  Infeasible: {n_total - n_feasible} ({100 - feasible_pct:.1f}%)\")\n\n# Metric ranges\nprint(f\"\\nMetric Ranges (all cases):\")\nprint(f\"  EIRP: {results['eirp_dbw'].min():.1f} to {results['eirp_dbw'].max():.1f} dBW\")\nprint(f\"  Cost: ${results['cost_usd'].min():,.0f} to ${results['cost_usd'].max():,.0f}\")\nprint(f\"  Margin: {results['link_margin_db'].min():.1f} to {results['link_margin_db'].max():.1f} dB\")\n</code></pre>"},{"location":"tutorials/comms-trade-study/#step-8-extract-pareto-frontier","title":"Step 8: Extract Pareto Frontier","text":"<pre><code># Define objectives\nobjectives = [\n    (\"cost_usd\", \"minimize\"),    # Lower cost is better\n    (\"eirp_dbw\", \"maximize\"),    # Higher EIRP is better\n]\n\n# Extract Pareto-optimal designs\npareto = extract_pareto(feasible, objectives)\nprint(f\"\\nPareto-optimal designs: {len(pareto)}\")\n\n# Rank by weighted objectives\nranked = rank_pareto(pareto, objectives, weights=[0.5, 0.5])\n\nprint(\"\\nTop 5 Pareto-optimal designs (balanced weights):\")\nprint(\"-\" * 70)\nfor i, (_, row) in enumerate(ranked.head(5).iterrows()):\n    print(f\"  #{i+1}: {row['case_id']}\")\n    print(f\"      Array: {int(row['array.nx'])}\u00d7{int(row['array.ny'])} ({int(row['n_elements'])} elements)\")\n    print(f\"      TX Power: {row['rf.tx_power_w_per_elem']:.2f} W/elem\")\n    print(f\"      EIRP: {row['eirp_dbw']:.1f} dBW\")\n    print(f\"      Cost: ${row['cost_usd']:,.0f}\")\n    print(f\"      Margin: {row['link_margin_db']:.1f} dB\")\n</code></pre>"},{"location":"tutorials/comms-trade-study/#step-9-visualize-results","title":"Step 9: Visualize Results","text":"<pre><code># Create output directory\noutput_dir = Path(\"./tutorial_results\")\noutput_dir.mkdir(exist_ok=True)\n\n# Pareto plot: Cost vs EIRP\nfig1 = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    pareto_front=pareto,\n    feasible_mask=feasible_mask,\n    color_by=\"link_margin_db\",\n    title=\"Cost vs EIRP Trade Space\",\n    x_label=\"Total Cost (USD)\",\n    y_label=\"EIRP (dBW)\",\n    figsize=(10, 8),\n)\nfig1.savefig(output_dir / \"pareto_cost_eirp.png\", dpi=150, bbox_inches=\"tight\")\nprint(f\"Saved: {output_dir / 'pareto_cost_eirp.png'}\")\n\n# Scatter matrix of key metrics\nfig2 = scatter_matrix(\n    feasible,\n    columns=[\"cost_usd\", \"eirp_dbw\", \"link_margin_db\", \"n_elements\"],\n    color_by=\"rf.tx_power_w_per_elem\",\n    diagonal=\"hist\",\n    title=\"Trade Space Correlations (Feasible Designs)\",\n    figsize=(12, 12),\n)\nfig2.savefig(output_dir / \"scatter_matrix.png\", dpi=150, bbox_inches=\"tight\")\nprint(f\"Saved: {output_dir / 'scatter_matrix.png'}\")\n\nplt.close(\"all\")\n</code></pre>"},{"location":"tutorials/comms-trade-study/#step-10-export-results","title":"Step 10: Export Results","text":"<pre><code># Export all results\nexport_results(results, output_dir / \"all_results.parquet\")\nprint(f\"Saved: {output_dir / 'all_results.parquet'}\")\n\n# Export feasible results\nexport_results(feasible, output_dir / \"feasible_results.parquet\")\nprint(f\"Saved: {output_dir / 'feasible_results.parquet'}\")\n\n# Export Pareto front to CSV for easy viewing\nexport_results(ranked, output_dir / \"pareto_ranked.csv\", format=\"csv\")\nprint(f\"Saved: {output_dir / 'pareto_ranked.csv'}\")\n</code></pre>"},{"location":"tutorials/comms-trade-study/#step-11-summary","title":"Step 11: Summary","text":"<pre><code>print(\"\\n\" + \"=\" * 70)\nprint(\"TRADE STUDY SUMMARY\")\nprint(\"=\" * 70)\nprint(f\"Scenario: {scenario.freq_hz/1e9:.1f} GHz, {scenario.range_m/1e3:.0f} km\")\nprint(f\"Cases evaluated: {n_total}\")\nprint(f\"Feasible designs: {n_feasible} ({feasible_pct:.1f}%)\")\nprint(f\"Pareto-optimal: {len(pareto)}\")\n\nif len(ranked) &gt; 0:\n    best = ranked.iloc[0]\n    print(f\"\\nBest Compromise Design: {best['case_id']}\")\n    print(f\"  Array: {int(best['array.nx'])}\u00d7{int(best['array.ny'])}\")\n    print(f\"  TX Power: {best['rf.tx_power_w_per_elem']:.2f} W/elem\")\n    print(f\"  EIRP: {best['eirp_dbw']:.1f} dBW\")\n    print(f\"  Link Margin: {best['link_margin_db']:.1f} dB\")\n    print(f\"  Cost: ${best['cost_usd']:,.0f}\")\n    print(f\"  Prime Power: {best['prime_power_w']:.0f} W\")\n\nprint(f\"\\nResults saved to: {output_dir.absolute()}\")\n</code></pre>"},{"location":"tutorials/comms-trade-study/#complete-code","title":"Complete Code","text":"<p>The complete script is available at: <code>examples/02_comms_doe_trade.py</code></p>"},{"location":"tutorials/comms-trade-study/#next-steps","title":"Next Steps","text":"<ul> <li>Radar Detection Trade - Similar workflow for radar</li> <li>Sensitivity Analysis - Deep dive into parameter effects</li> <li>User Guide: Pareto Analysis - Advanced Pareto techniques</li> </ul>"},{"location":"tutorials/config-driven-workflow/","title":"Tutorial: Config-Driven Workflow","text":"<p>Use YAML configuration files for reproducible analysis.</p>"},{"location":"tutorials/config-driven-workflow/#objective","title":"Objective","text":"<p>Learn to:</p> <ul> <li>Define studies in YAML configuration files</li> <li>Run analyses from the command line</li> <li>Maintain reproducible, version-controlled studies</li> </ul>"},{"location":"tutorials/config-driven-workflow/#why-config-driven","title":"Why Config-Driven?","text":"<ul> <li>Reproducibility: Track changes with git</li> <li>Documentation: Self-documenting study parameters</li> <li>Automation: Easy to script and batch</li> <li>Collaboration: Share configs with team</li> </ul>"},{"location":"tutorials/config-driven-workflow/#step-1-create-configuration-file","title":"Step 1: Create Configuration File","text":"<p>Create <code>study_config.yaml</code>:</p> <pre><code># study_config.yaml\n# Communications array trade study configuration\n\nname: \"X-Band Comms Trade Study\"\n\n# System architecture (baseline values)\narchitecture:\n  array:\n    geometry: rectangular\n    nx: 8\n    ny: 8\n    dx_lambda: 0.5\n    dy_lambda: 0.5\n    scan_limit_deg: 60.0\n    max_subarray_nx: 8\n    max_subarray_ny: 8\n    enforce_subarray_constraint: true\n\n  rf:\n    tx_power_w_per_elem: 1.0\n    pa_efficiency: 0.3\n    noise_figure_db: 3.0\n    n_tx_beams: 1\n    feed_loss_db: 1.0\n    system_loss_db: 0.0\n\n  cost:\n    cost_per_elem_usd: 100.0\n    nre_usd: 10000.0\n    integration_cost_usd: 5000.0\n\n# Operating scenario\nscenario:\n  type: comms\n  freq_hz: 10.0e9\n  bandwidth_hz: 10.0e6\n  range_m: 100.0e3\n  required_snr_db: 10.0\n  scan_angle_deg: 0.0\n  rx_antenna_gain_db: 0.0\n  rx_noise_temp_k: 290.0\n  atmospheric_loss_db: 0.0\n  rain_loss_db: 0.0\n\n# Requirements\nrequirements:\n  - id: REQ-001\n    name: Minimum EIRP\n    metric_key: eirp_dbw\n    op: \"&gt;=\"\n    value: 35.0\n    units: dBW\n    severity: must\n\n  - id: REQ-002\n    name: Positive Link Margin\n    metric_key: link_margin_db\n    op: \"&gt;=\"\n    value: 0.0\n    units: dB\n    severity: must\n\n  - id: REQ-003\n    name: Maximum Cost\n    metric_key: cost_usd\n    op: \"&lt;=\"\n    value: 100000.0\n    units: USD\n    severity: must\n\n# Design space for DOE\ndesign_space:\n  variables:\n    # Variable parameters\n    - name: array.nx\n      type: categorical\n      values: [4, 8, 16]\n\n    - name: array.ny\n      type: categorical\n      values: [4, 8, 16]\n\n    - name: rf.tx_power_w_per_elem\n      type: float\n      low: 0.5\n      high: 3.0\n\n    - name: rf.pa_efficiency\n      type: float\n      low: 0.2\n      high: 0.5\n\n    - name: cost.cost_per_elem_usd\n      type: float\n      low: 75.0\n      high: 150.0\n\n    # Fixed parameters (low == high)\n    - name: array.geometry\n      type: categorical\n      values: [rectangular]\n\n    - name: array.dx_lambda\n      type: float\n      low: 0.5\n      high: 0.5\n\n    - name: array.dy_lambda\n      type: float\n      low: 0.5\n      high: 0.5\n\n    - name: array.enforce_subarray_constraint\n      type: categorical\n      values: [true]\n\n    - name: rf.noise_figure_db\n      type: float\n      low: 3.0\n      high: 3.0\n\n    - name: rf.feed_loss_db\n      type: float\n      low: 1.0\n      high: 1.0\n\n    - name: cost.nre_usd\n      type: float\n      low: 10000.0\n      high: 10000.0\n\n    - name: cost.integration_cost_usd\n      type: float\n      low: 5000.0\n      high: 5000.0\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#step-2-single-case-evaluation-cli","title":"Step 2: Single Case Evaluation (CLI)","text":"<p>Test the baseline configuration:</p> <pre><code>pasys run study_config.yaml\n</code></pre> <p>Output:</p> <pre><code>Results for study_config.yaml\n============================================================\n\nAntenna:\n  g_peak_db: 24.0821\n  ...\n\nLink Budget:\n  eirp_dbw: 45.0821\n  link_margin_db: 7.0395\n  ...\n\nCost:\n  cost_usd: 21,400.0\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#step-3-run-doe-study-cli","title":"Step 3: Run DOE Study (CLI)","text":"<p>Execute the full trade study:</p> <pre><code>pasys doe study_config.yaml -n 100 --method lhs --seed 42 -o ./results\n</code></pre> <p>Output:</p> <pre><code>Design Space: 16 variables\nGenerating 100 samples using lhs...\nRunning batch evaluation...\n  Progress: 10/100 (10%)\n  ...\n  Progress: 100/100 (100%)\n\nCompleted: 100 cases\nFeasible: 73 (73.0%)\n\nResults saved to: ./results/results.parquet\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#step-4-extract-pareto-cli","title":"Step 4: Extract Pareto (CLI)","text":"<pre><code>pasys pareto results/results.parquet -x cost_usd -y eirp_dbw --plot\n</code></pre> <p>Output:</p> <pre><code>Pareto Frontier: 12 designs\n======================================================================\n  case_00023: cost_usd=18234.50, eirp_dbw=38.21\n  case_00045: cost_usd=23567.00, eirp_dbw=42.15\n  ...\n\nPlot saved to: pareto_plot.png\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#step-5-generate-report-cli","title":"Step 5: Generate Report (CLI)","text":"<pre><code>pasys report results/results.parquet --title \"X-Band Trade Study\" -o report.html\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#step-6-python-integration","title":"Step 6: Python Integration","text":"<p>Use configs in Python scripts:</p> <pre><code>from phased_array_systems.io import load_config\nfrom phased_array_systems.evaluate import evaluate_case\nfrom phased_array_systems.trades import generate_doe, BatchRunner\n\n# Load configuration\nconfig = load_config(\"study_config.yaml\")\n\n# Extract components\narch = config.get_architecture()\nscenario = config.get_scenario()\nrequirements = config.get_requirement_set()\n\n# Single case\nmetrics = evaluate_case(arch, scenario)\nreport = requirements.verify(metrics)\nprint(f\"Baseline passes: {report.passes}\")\n\n# DOE study\ndesign_space = config.get_design_space()  # If implemented\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#step-7-version-control","title":"Step 7: Version Control","text":"<p>Track your study with git:</p> <pre><code># Initialize repo\ngit init\ngit add study_config.yaml\ngit commit -m \"Initial trade study configuration\"\n\n# After running study\ngit add results/\ngit commit -m \"Trade study results: 100 cases, 73 feasible\"\n\n# Modify and re-run\n# Edit study_config.yaml\ngit add study_config.yaml\ngit commit -m \"Increase power range to 0.5-4.0 W\"\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#step-8-sensitivity-studies","title":"Step 8: Sensitivity Studies","text":"<p>Create variants for sensitivity analysis:</p> <pre><code># study_config_high_power.yaml\n# Copy and modify\nname: \"High Power Variant\"\n\narchitecture:\n  rf:\n    tx_power_w_per_elem: 2.0  # Changed from 1.0\n\n# ... rest same\n</code></pre> <p>Run both:</p> <pre><code>pasys doe study_config.yaml -n 100 -o ./results_baseline\npasys doe study_config_high_power.yaml -n 100 -o ./results_high_power\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#step-9-automation-script","title":"Step 9: Automation Script","text":"<p>Create a shell script for the complete workflow:</p> <pre><code>#!/bin/bash\n# run_study.sh\n\nCONFIG=$1\nOUTPUT_DIR=$2\nN_SAMPLES=${3:-100}\n\necho \"Running study: $CONFIG\"\necho \"Output: $OUTPUT_DIR\"\necho \"Samples: $N_SAMPLES\"\n\n# Run DOE\npasys doe $CONFIG -n $N_SAMPLES --seed 42 -o $OUTPUT_DIR\n\n# Extract Pareto\npasys pareto $OUTPUT_DIR/results.parquet -x cost_usd -y eirp_dbw \\\n    --plot -o $OUTPUT_DIR/pareto.csv\n\n# Generate report\npasys report $OUTPUT_DIR/results.parquet \\\n    --title \"Trade Study Report\" \\\n    -o $OUTPUT_DIR/report.html\n\necho \"Study complete: $OUTPUT_DIR\"\n</code></pre> <p>Usage:</p> <pre><code>chmod +x run_study.sh\n./run_study.sh study_config.yaml ./results 100\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/config-driven-workflow/#1-use-descriptive-names","title":"1. Use Descriptive Names","text":"<pre><code>name: \"Q4-2024 Array Redesign - 150km Range\"\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#2-comment-important-values","title":"2. Comment Important Values","text":"<pre><code>scenario:\n  freq_hz: 10.0e9       # X-band\n  range_m: 150.0e3      # Increased from 100 km (customer request)\n  required_snr_db: 12.0  # 16-QAM modulation\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#3-organize-configs-by-study","title":"3. Organize Configs by Study","text":"<pre><code>studies/\n\u251c\u2500\u2500 baseline/\n\u2502   \u251c\u2500\u2500 config.yaml\n\u2502   \u2514\u2500\u2500 results/\n\u251c\u2500\u2500 high_power/\n\u2502   \u251c\u2500\u2500 config.yaml\n\u2502   \u2514\u2500\u2500 results/\n\u2514\u2500\u2500 extended_range/\n    \u251c\u2500\u2500 config.yaml\n    \u2514\u2500\u2500 results/\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#4-include-metadata","title":"4. Include Metadata","text":"<pre><code># metadata (optional, for documentation)\nmetadata:\n  author: \"Engineering Team\"\n  date: \"2024-01-15\"\n  version: \"1.2\"\n  description: |\n    Trade study for next-generation comms array.\n    Explores 4x4 to 16x16 configurations.\n</code></pre>"},{"location":"tutorials/config-driven-workflow/#next-steps","title":"Next Steps","text":"<ul> <li>Communications Trade Study - Full Python workflow</li> <li>Sensitivity Analysis - Parameter studies</li> <li>CLI Reference - Command details</li> </ul>"},{"location":"tutorials/radar-detection-trade/","title":"Tutorial: Radar Detection Trade Study","text":"<p>Design and optimize a phased array radar for target detection.</p>"},{"location":"tutorials/radar-detection-trade/#objective","title":"Objective","text":"<p>By the end of this tutorial, you will:</p> <ul> <li>Configure a radar detection scenario</li> <li>Set radar-specific requirements</li> <li>Explore the power-aperture trade-off</li> <li>Analyze detection performance across designs</li> </ul>"},{"location":"tutorials/radar-detection-trade/#scenario","title":"Scenario","text":"<p>Design a search radar to detect a 1 m\u00b2 target at 100 km with:</p> <ul> <li>90% detection probability</li> <li>10\u207b\u2076 false alarm probability</li> <li>Budget constraint of $500,000</li> </ul>"},{"location":"tutorials/radar-detection-trade/#step-1-setup","title":"Step 1: Setup","text":"<pre><code>\"\"\"Radar detection trade study tutorial.\"\"\"\n\nimport matplotlib\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\nfrom phased_array_systems.architecture import Architecture, ArrayConfig, RFChainConfig, CostConfig\nfrom phased_array_systems.scenarios import RadarDetectionScenario\nfrom phased_array_systems.requirements import Requirement, RequirementSet\nfrom phased_array_systems.evaluate import evaluate_case\nfrom phased_array_systems.trades import (\n    DesignSpace,\n    generate_doe,\n    BatchRunner,\n    filter_feasible,\n    extract_pareto,\n    rank_pareto,\n)\nfrom phased_array_systems.viz import pareto_plot, scatter_matrix\nfrom phased_array_systems.io import export_results\n</code></pre>"},{"location":"tutorials/radar-detection-trade/#step-2-define-the-scenario","title":"Step 2: Define the Scenario","text":"<pre><code>scenario = RadarDetectionScenario(\n    # Operating frequency\n    freq_hz=10e9,              # X-band\n\n    # Target characteristics\n    target_rcs_m2=1.0,         # 1 m\u00b2 RCS\n    range_m=100e3,             # 100 km detection range\n\n    # Detection requirements\n    required_pd=0.9,           # 90% detection probability\n    pfa=1e-6,                  # 10\u207b\u2076 false alarm rate\n\n    # Waveform parameters\n    pulse_width_s=10e-6,       # 10 \u03bcs pulse\n    prf_hz=1000,               # 1 kHz PRF\n\n    # Integration\n    n_pulses=10,               # Integrate 10 pulses\n    integration_type=\"coherent\",  # Coherent integration\n\n    # Target model\n    swerling_model=1,          # Swerling 1 (slow fluctuation)\n\n    # Scan\n    scan_angle_deg=0.0,        # Boresight\n)\n\nprint(f\"Radar Scenario:\")\nprint(f\"  Frequency: {scenario.freq_hz/1e9:.1f} GHz\")\nprint(f\"  Target RCS: {scenario.target_rcs_m2} m\u00b2\")\nprint(f\"  Range: {scenario.range_m/1e3:.0f} km\")\nprint(f\"  Required Pd: {scenario.required_pd}\")\nprint(f\"  Pfa: {scenario.pfa}\")\nprint(f\"  Integration: {scenario.n_pulses} pulses ({scenario.integration_type})\")\n</code></pre>"},{"location":"tutorials/radar-detection-trade/#step-3-define-requirements","title":"Step 3: Define Requirements","text":"<pre><code>requirements = RequirementSet(\n    requirements=[\n        Requirement(\n            id=\"DET-001\",\n            name=\"Positive SNR Margin\",\n            metric_key=\"snr_margin_db\",\n            op=\"&gt;=\",\n            value=0.0,\n            units=\"dB\",\n            severity=\"must\",\n        ),\n        Requirement(\n            id=\"DET-002\",\n            name=\"5 dB SNR Margin\",\n            metric_key=\"snr_margin_db\",\n            op=\"&gt;=\",\n            value=5.0,\n            units=\"dB\",\n            severity=\"should\",\n        ),\n        Requirement(\n            id=\"COST-001\",\n            name=\"Maximum Cost\",\n            metric_key=\"cost_usd\",\n            op=\"&lt;=\",\n            value=500000.0,\n            units=\"USD\",\n            severity=\"must\",\n        ),\n        Requirement(\n            id=\"PWR-001\",\n            name=\"Maximum Power\",\n            metric_key=\"prime_power_w\",\n            op=\"&lt;=\",\n            value=10000.0,\n            units=\"W\",\n            severity=\"must\",\n        ),\n    ],\n    name=\"Radar Detection Requirements\",\n)\n\nprint(f\"\\nRequirements: {len(requirements)} defined\")\nfor req in requirements:\n    print(f\"  {req.id}: {req.name}\")\n</code></pre>"},{"location":"tutorials/radar-detection-trade/#step-4-define-the-design-space","title":"Step 4: Define the Design Space","text":"<pre><code>design_space = (\n    DesignSpace(name=\"Radar Array Trade Study\")\n    # Array size (power-of-2 for sub-array constraints)\n    .add_variable(\"array.nx\", type=\"categorical\", values=[8, 16, 32])\n    .add_variable(\"array.ny\", type=\"categorical\", values=[8, 16, 32])\n    # TX power per element (significant range for radar)\n    .add_variable(\"rf.tx_power_w_per_elem\", type=\"float\", low=5.0, high=30.0)\n    # PA efficiency\n    .add_variable(\"rf.pa_efficiency\", type=\"float\", low=0.15, high=0.35)\n    # Cost per element (radar modules more expensive)\n    .add_variable(\"cost.cost_per_elem_usd\", type=\"float\", low=200.0, high=500.0)\n    # Fixed parameters\n    .add_variable(\"array.geometry\", type=\"categorical\", values=[\"rectangular\"])\n    .add_variable(\"array.dx_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.dy_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.enforce_subarray_constraint\", type=\"categorical\", values=[True])\n    .add_variable(\"rf.noise_figure_db\", type=\"float\", low=4.0, high=4.0)\n    .add_variable(\"rf.n_tx_beams\", type=\"int\", low=1, high=1)\n    .add_variable(\"rf.feed_loss_db\", type=\"float\", low=1.5, high=1.5)\n    .add_variable(\"cost.nre_usd\", type=\"float\", low=50000.0, high=50000.0)\n    .add_variable(\"cost.integration_cost_usd\", type=\"float\", low=25000.0, high=25000.0)\n)\n\nprint(f\"\\nDesign Space: {design_space.n_dims} dimensions\")\n</code></pre>"},{"location":"tutorials/radar-detection-trade/#step-5-quick-baseline-check","title":"Step 5: Quick Baseline Check","text":"<pre><code># Evaluate a baseline design first\nbaseline = Architecture(\n    array=ArrayConfig(nx=16, ny=16, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(tx_power_w_per_elem=10.0, pa_efficiency=0.25, noise_figure_db=4.0),\n    cost=CostConfig(cost_per_elem_usd=300.0, nre_usd=50000.0, integration_cost_usd=25000.0),\n    name=\"Baseline 16x16\",\n)\n\nbaseline_metrics = evaluate_case(baseline, scenario)\n\nprint(f\"\\nBaseline Design: 16\u00d716 array, 10 W/elem\")\nprint(f\"  Single-Pulse SNR: {baseline_metrics['snr_single_pulse_db']:.1f} dB\")\nprint(f\"  Integrated SNR: {baseline_metrics['snr_integrated_db']:.1f} dB\")\nprint(f\"  Required SNR: {baseline_metrics['snr_required_db']:.1f} dB\")\nprint(f\"  SNR Margin: {baseline_metrics['snr_margin_db']:.1f} dB\")\nprint(f\"  Cost: ${baseline_metrics['cost_usd']:,.0f}\")\nprint(f\"  Prime Power: {baseline_metrics['prime_power_w']:.0f} W\")\n\n# Check requirements\nreport = requirements.verify(baseline_metrics)\nprint(f\"  Requirements: {'PASS' if report.passes else 'FAIL'}\")\n</code></pre>"},{"location":"tutorials/radar-detection-trade/#step-6-run-doe","title":"Step 6: Run DOE","text":"<pre><code>n_samples = 100\nseed = 42\n\ndoe = generate_doe(design_space, method=\"lhs\", n_samples=n_samples, seed=seed)\nprint(f\"\\nGenerated {len(doe)} DOE cases\")\n\nrunner = BatchRunner(scenario, requirements)\n\ndef progress(completed, total):\n    if completed % 25 == 0 or completed == total:\n        print(f\"  Progress: {completed}/{total}\")\n\nprint(\"\\nRunning batch evaluation...\")\nresults = runner.run(doe, n_workers=1, progress_callback=progress)\nprint(f\"Completed: {len(results)} cases\")\n</code></pre>"},{"location":"tutorials/radar-detection-trade/#step-7-analyze-results","title":"Step 7: Analyze Results","text":"<pre><code>feasible_mask = results[\"verification.passes\"] == 1.0\nfeasible = filter_feasible(results, requirements)\n\nprint(f\"\\nResults Summary:\")\nprint(f\"  Total cases: {len(results)}\")\nprint(f\"  Feasible: {len(feasible)} ({len(feasible)/len(results)*100:.1f}%)\")\n\nprint(f\"\\nSNR Margin Range:\")\nprint(f\"  All: {results['snr_margin_db'].min():.1f} to {results['snr_margin_db'].max():.1f} dB\")\nif len(feasible) &gt; 0:\n    print(f\"  Feasible: {feasible['snr_margin_db'].min():.1f} to {feasible['snr_margin_db'].max():.1f} dB\")\n\nprint(f\"\\nCost Range:\")\nprint(f\"  All: ${results['cost_usd'].min():,.0f} to ${results['cost_usd'].max():,.0f}\")\nif len(feasible) &gt; 0:\n    print(f\"  Feasible: ${feasible['cost_usd'].min():,.0f} to ${feasible['cost_usd'].max():,.0f}\")\n</code></pre>"},{"location":"tutorials/radar-detection-trade/#step-8-pareto-analysis","title":"Step 8: Pareto Analysis","text":"<pre><code>if len(feasible) &gt; 0:\n    objectives = [\n        (\"cost_usd\", \"minimize\"),\n        (\"snr_margin_db\", \"maximize\"),\n    ]\n\n    pareto = extract_pareto(feasible, objectives)\n    ranked = rank_pareto(pareto, objectives, weights=[0.5, 0.5])\n\n    print(f\"\\nPareto-optimal designs: {len(pareto)}\")\n    print(\"\\nTop 5 Designs:\")\n    print(\"-\" * 70)\n    for i, (_, row) in enumerate(ranked.head(5).iterrows()):\n        print(f\"  #{i+1}: {row['case_id']}\")\n        print(f\"      Array: {int(row['array.nx'])}\u00d7{int(row['array.ny'])} ({int(row['n_elements'])} elements)\")\n        print(f\"      TX Power: {row['rf.tx_power_w_per_elem']:.1f} W/elem\")\n        print(f\"      SNR Margin: {row['snr_margin_db']:.1f} dB\")\n        print(f\"      Cost: ${row['cost_usd']:,.0f}\")\n        print(f\"      Prime Power: {row['prime_power_w']:.0f} W\")\nelse:\n    print(\"\\nNo feasible designs found. Consider relaxing requirements.\")\n    pareto = None\n    ranked = None\n</code></pre>"},{"location":"tutorials/radar-detection-trade/#step-9-visualize","title":"Step 9: Visualize","text":"<pre><code>output_dir = Path(\"./radar_tutorial_results\")\noutput_dir.mkdir(exist_ok=True)\n\n# Cost vs SNR Margin\nfig1 = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"snr_margin_db\",\n    pareto_front=pareto,\n    feasible_mask=feasible_mask,\n    color_by=\"n_elements\",\n    title=\"Cost vs SNR Margin Trade Space\",\n    x_label=\"Total Cost (USD)\",\n    y_label=\"SNR Margin (dB)\",\n)\nfig1.savefig(output_dir / \"pareto_cost_snr.png\", dpi=150, bbox_inches=\"tight\")\n\n# Power vs Performance\nfig2 = pareto_plot(\n    results,\n    x=\"prime_power_w\",\n    y=\"snr_margin_db\",\n    feasible_mask=feasible_mask,\n    color_by=\"cost_usd\",\n    title=\"Power vs SNR Margin\",\n    x_label=\"Prime Power (W)\",\n    y_label=\"SNR Margin (dB)\",\n)\nfig2.savefig(output_dir / \"pareto_power_snr.png\", dpi=150, bbox_inches=\"tight\")\n\n# Scatter matrix\nif len(feasible) &gt; 5:\n    fig3 = scatter_matrix(\n        feasible,\n        columns=[\"cost_usd\", \"snr_margin_db\", \"prime_power_w\", \"n_elements\"],\n        color_by=\"snr_margin_db\",\n        title=\"Trade Space Correlations\",\n    )\n    fig3.savefig(output_dir / \"scatter_matrix.png\", dpi=150, bbox_inches=\"tight\")\n\nplt.close(\"all\")\nprint(f\"\\nFigures saved to: {output_dir}\")\n</code></pre>"},{"location":"tutorials/radar-detection-trade/#step-10-power-aperture-trade-off","title":"Step 10: Power-Aperture Trade-off","text":"<pre><code># Analyze power-aperture product\nif len(feasible) &gt; 0:\n    feasible[\"power_aperture\"] = feasible[\"prime_power_w\"] * feasible[\"n_elements\"]\n\n    print(\"\\nPower-Aperture Analysis:\")\n    print(f\"  PA Product Range: {feasible['power_aperture'].min():.0f} to {feasible['power_aperture'].max():.0f}\")\n\n    # Group by array size\n    for nx in [8, 16, 32]:\n        subset = feasible[feasible[\"array.nx\"] == nx]\n        if len(subset) &gt; 0:\n            print(f\"\\n  {nx}\u00d7{nx} arrays ({nx*nx} elements):\")\n            print(f\"    Count: {len(subset)}\")\n            print(f\"    Avg SNR Margin: {subset['snr_margin_db'].mean():.1f} dB\")\n            print(f\"    Avg Cost: ${subset['cost_usd'].mean():,.0f}\")\n</code></pre>"},{"location":"tutorials/radar-detection-trade/#step-11-export-results","title":"Step 11: Export Results","text":"<pre><code>export_results(results, output_dir / \"all_results.parquet\")\nexport_results(feasible, output_dir / \"feasible_results.parquet\")\nif ranked is not None:\n    export_results(ranked, output_dir / \"pareto_ranked.csv\", format=\"csv\")\n\nprint(f\"\\nResults exported to: {output_dir}\")\n</code></pre>"},{"location":"tutorials/radar-detection-trade/#key-insights","title":"Key Insights","text":""},{"location":"tutorials/radar-detection-trade/#power-aperture-trade-off","title":"Power-Aperture Trade-off","text":"<p>The radar equation shows that SNR scales with:</p> <p>\\[ SNR \\propto P_t \\cdot A^2 \\propto P_t \\cdot N^2 \\]</p> <p>Where \\(N\\) is element count. This means: - Doubling power \u2192 3 dB improvement - Doubling elements \u2192 6 dB improvement (but higher cost)</p>"},{"location":"tutorials/radar-detection-trade/#array-size-selection","title":"Array Size Selection","text":"Size Elements Typical Use 8\u00d78 64 Short range, low cost 16\u00d716 256 Medium range, balanced 32\u00d732 1024 Long range, high performance"},{"location":"tutorials/radar-detection-trade/#swerling-model-impact","title":"Swerling Model Impact","text":"<ul> <li>Swerling 0 (steady): Requires lowest SNR</li> <li>Swerling 1 (slow): Requires ~2-3 dB more</li> <li>Higher models: Additional SNR needed</li> </ul>"},{"location":"tutorials/radar-detection-trade/#next-steps","title":"Next Steps","text":"<ul> <li>Communications Trade Study - Compare with comms workflow</li> <li>Sensitivity Analysis - Parameter sensitivity</li> <li>Theory: Radar Equation - Detailed equations</li> </ul>"},{"location":"tutorials/sensitivity-analysis/","title":"Tutorial: Sensitivity Analysis","text":"<p>Understand how design parameters affect performance.</p>"},{"location":"tutorials/sensitivity-analysis/#objective","title":"Objective","text":"<p>Learn to:</p> <ul> <li>Identify sensitive parameters</li> <li>Visualize parameter effects</li> <li>Use scatter matrices for correlation analysis</li> <li>Perform one-at-a-time (OAT) sensitivity studies</li> </ul>"},{"location":"tutorials/sensitivity-analysis/#overview","title":"Overview","text":"<p>Sensitivity analysis answers: \"Which parameters matter most?\"</p> <p>This helps: - Focus design effort on critical parameters - Identify parameters that can be relaxed - Understand design robustness</p>"},{"location":"tutorials/sensitivity-analysis/#step-1-setup","title":"Step 1: Setup","text":"<pre><code>\"\"\"Sensitivity analysis tutorial.\"\"\"\n\nimport matplotlib\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\n\nfrom phased_array_systems.architecture import Architecture, ArrayConfig, RFChainConfig, CostConfig\nfrom phased_array_systems.scenarios import CommsLinkScenario\nfrom phased_array_systems.evaluate import evaluate_case\nfrom phased_array_systems.trades import DesignSpace, generate_doe, BatchRunner\nfrom phased_array_systems.viz import scatter_matrix\n</code></pre>"},{"location":"tutorials/sensitivity-analysis/#step-2-define-baseline","title":"Step 2: Define Baseline","text":"<pre><code># Baseline configuration\nbaseline_arch = Architecture(\n    array=ArrayConfig(nx=8, ny=8, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(tx_power_w_per_elem=1.0, pa_efficiency=0.3),\n    cost=CostConfig(cost_per_elem_usd=100.0, nre_usd=10000.0),\n)\n\nscenario = CommsLinkScenario(\n    freq_hz=10e9,\n    bandwidth_hz=10e6,\n    range_m=100e3,\n    required_snr_db=10.0,\n)\n\n# Baseline metrics\nbaseline_metrics = evaluate_case(baseline_arch, scenario)\nprint(f\"Baseline: 8\u00d78 array, 1.0 W/elem\")\nprint(f\"  EIRP: {baseline_metrics['eirp_dbw']:.1f} dBW\")\nprint(f\"  Link Margin: {baseline_metrics['link_margin_db']:.1f} dB\")\nprint(f\"  Cost: ${baseline_metrics['cost_usd']:,.0f}\")\n</code></pre>"},{"location":"tutorials/sensitivity-analysis/#step-3-one-at-a-time-oat-sensitivity","title":"Step 3: One-at-a-Time (OAT) Sensitivity","text":"<p>Vary one parameter while holding others constant:</p> <pre><code>def oat_sensitivity(param_name, values, baseline_flat, scenario):\n    \"\"\"Perform one-at-a-time sensitivity analysis.\"\"\"\n    results = []\n\n    for value in values:\n        # Copy baseline and modify one parameter\n        params = baseline_flat.copy()\n        params[param_name] = value\n\n        # Create architecture\n        arch = Architecture.from_flat(params)\n\n        # Evaluate\n        metrics = evaluate_case(arch, scenario)\n        metrics[param_name] = value\n        results.append(metrics)\n\n    return pd.DataFrame(results)\n\n# Get baseline as flat dict\nbaseline_flat = baseline_arch.model_dump_flat()\n\n# Define parameter ranges to sweep\nparam_sweeps = {\n    \"array.nx\": [4, 8, 12, 16],  # Note: some may violate sub-array constraint\n    \"rf.tx_power_w_per_elem\": [0.5, 1.0, 1.5, 2.0, 2.5, 3.0],\n    \"rf.pa_efficiency\": [0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5],\n    \"cost.cost_per_elem_usd\": [50, 75, 100, 125, 150, 175, 200],\n}\n</code></pre>"},{"location":"tutorials/sensitivity-analysis/#step-4-run-oat-analysis","title":"Step 4: Run OAT Analysis","text":"<pre><code># Disable sub-array constraint for continuous sweep\nbaseline_flat[\"array.enforce_subarray_constraint\"] = False\n\n# Sweep TX power (key driver of EIRP)\nprint(\"\\n=== TX Power Sensitivity ===\")\ntx_power_results = oat_sensitivity(\n    \"rf.tx_power_w_per_elem\",\n    [0.5, 1.0, 1.5, 2.0, 2.5, 3.0],\n    baseline_flat,\n    scenario,\n)\n\nprint(f\"TX Power (W) | EIRP (dBW) | Margin (dB) | Cost ($)\")\nprint(\"-\" * 55)\nfor _, row in tx_power_results.iterrows():\n    print(f\"{row['rf.tx_power_w_per_elem']:12.1f} | \"\n          f\"{row['eirp_dbw']:10.1f} | \"\n          f\"{row['link_margin_db']:10.1f} | \"\n          f\"{row['cost_usd']:,.0f}\")\n\n# Sweep PA efficiency (affects power consumption)\nprint(\"\\n=== PA Efficiency Sensitivity ===\")\npa_eff_results = oat_sensitivity(\n    \"rf.pa_efficiency\",\n    [0.2, 0.25, 0.3, 0.35, 0.4, 0.5],\n    baseline_flat,\n    scenario,\n)\n\nprint(f\"Efficiency | Prime Power (W) | DC Power (W)\")\nprint(\"-\" * 45)\nfor _, row in pa_eff_results.iterrows():\n    print(f\"{row['rf.pa_efficiency']:10.2f} | \"\n          f\"{row['prime_power_w']:15.0f} | \"\n          f\"{row['dc_power_w']:.0f}\")\n</code></pre>"},{"location":"tutorials/sensitivity-analysis/#step-5-visualize-oat-results","title":"Step 5: Visualize OAT Results","text":"<pre><code>output_dir = Path(\"./sensitivity_results\")\noutput_dir.mkdir(exist_ok=True)\n\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n# TX Power vs EIRP\nax = axes[0, 0]\nax.plot(tx_power_results[\"rf.tx_power_w_per_elem\"],\n        tx_power_results[\"eirp_dbw\"], 'bo-')\nax.set_xlabel(\"TX Power per Element (W)\")\nax.set_ylabel(\"EIRP (dBW)\")\nax.set_title(\"TX Power \u2192 EIRP\")\nax.grid(True, alpha=0.3)\n\n# TX Power vs Link Margin\nax = axes[0, 1]\nax.plot(tx_power_results[\"rf.tx_power_w_per_elem\"],\n        tx_power_results[\"link_margin_db\"], 'go-')\nax.axhline(y=0, color='r', linestyle='--', label='Min Margin')\nax.set_xlabel(\"TX Power per Element (W)\")\nax.set_ylabel(\"Link Margin (dB)\")\nax.set_title(\"TX Power \u2192 Link Margin\")\nax.grid(True, alpha=0.3)\nax.legend()\n\n# PA Efficiency vs Prime Power\nax = axes[1, 0]\nax.plot(pa_eff_results[\"rf.pa_efficiency\"],\n        pa_eff_results[\"prime_power_w\"], 'mo-')\nax.set_xlabel(\"PA Efficiency\")\nax.set_ylabel(\"Prime Power (W)\")\nax.set_title(\"PA Efficiency \u2192 Prime Power\")\nax.grid(True, alpha=0.3)\n\n# Cost per Element vs Total Cost\ncost_results = oat_sensitivity(\n    \"cost.cost_per_elem_usd\",\n    [50, 75, 100, 125, 150, 200],\n    baseline_flat,\n    scenario,\n)\nax = axes[1, 1]\nax.plot(cost_results[\"cost.cost_per_elem_usd\"],\n        cost_results[\"cost_usd\"], 'ro-')\nax.set_xlabel(\"Cost per Element (USD)\")\nax.set_ylabel(\"Total Cost (USD)\")\nax.set_title(\"Element Cost \u2192 Total Cost\")\nax.grid(True, alpha=0.3)\n\nfig.suptitle(\"One-at-a-Time Sensitivity Analysis\", fontsize=14)\nfig.tight_layout()\nfig.savefig(output_dir / \"oat_sensitivity.png\", dpi=150)\nplt.close()\n\nprint(f\"\\nSaved: {output_dir / 'oat_sensitivity.png'}\")\n</code></pre>"},{"location":"tutorials/sensitivity-analysis/#step-6-global-sensitivity-via-doe","title":"Step 6: Global Sensitivity via DOE","text":"<p>OAT misses interactions. Use DOE for global sensitivity:</p> <pre><code># Full DOE for global sensitivity\nspace = (\n    DesignSpace(name=\"Sensitivity Study\")\n    .add_variable(\"array.nx\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"array.ny\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"rf.tx_power_w_per_elem\", type=\"float\", low=0.5, high=3.0)\n    .add_variable(\"rf.pa_efficiency\", type=\"float\", low=0.2, high=0.5)\n    .add_variable(\"cost.cost_per_elem_usd\", type=\"float\", low=50.0, high=200.0)\n    # Fixed\n    .add_variable(\"array.geometry\", type=\"categorical\", values=[\"rectangular\"])\n    .add_variable(\"array.dx_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.dy_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.enforce_subarray_constraint\", type=\"categorical\", values=[True])\n    .add_variable(\"rf.noise_figure_db\", type=\"float\", low=3.0, high=3.0)\n    .add_variable(\"cost.nre_usd\", type=\"float\", low=10000.0, high=10000.0)\n)\n\ndoe = generate_doe(space, method=\"lhs\", n_samples=200, seed=42)\nrunner = BatchRunner(scenario)\nresults = runner.run(doe, n_workers=1)\n\nprint(f\"Evaluated {len(results)} cases for global sensitivity\")\n</code></pre>"},{"location":"tutorials/sensitivity-analysis/#step-7-correlation-analysis","title":"Step 7: Correlation Analysis","text":"<pre><code># Compute correlations\ninput_cols = [\"array.nx\", \"array.ny\", \"rf.tx_power_w_per_elem\",\n              \"rf.pa_efficiency\", \"cost.cost_per_elem_usd\"]\noutput_cols = [\"eirp_dbw\", \"link_margin_db\", \"cost_usd\", \"prime_power_w\"]\n\n# Input-output correlations\nprint(\"\\n=== Input-Output Correlations ===\")\nprint(f\"{'Input':&lt;30} | {'EIRP':&gt;8} | {'Margin':&gt;8} | {'Cost':&gt;8} | {'Power':&gt;8}\")\nprint(\"-\" * 80)\n\nfor inp in input_cols:\n    corrs = []\n    for out in output_cols:\n        corr = results[inp].corr(results[out])\n        corrs.append(corr)\n    print(f\"{inp:&lt;30} | {corrs[0]:&gt;8.3f} | {corrs[1]:&gt;8.3f} | {corrs[2]:&gt;8.3f} | {corrs[3]:&gt;8.3f}\")\n</code></pre>"},{"location":"tutorials/sensitivity-analysis/#step-8-scatter-matrix-visualization","title":"Step 8: Scatter Matrix Visualization","text":"<pre><code># Scatter matrix showing relationships\nfig = scatter_matrix(\n    results,\n    columns=[\"array.nx\", \"rf.tx_power_w_per_elem\", \"eirp_dbw\",\n             \"link_margin_db\", \"cost_usd\"],\n    color_by=\"prime_power_w\",\n    diagonal=\"hist\",\n    title=\"Design Space Correlations\",\n    figsize=(14, 14),\n)\nfig.savefig(output_dir / \"scatter_matrix.png\", dpi=150)\nplt.close()\nprint(f\"Saved: {output_dir / 'scatter_matrix.png'}\")\n</code></pre>"},{"location":"tutorials/sensitivity-analysis/#step-9-identify-key-drivers","title":"Step 9: Identify Key Drivers","text":"<pre><code># Rank parameters by correlation magnitude\nprint(\"\\n=== Parameter Importance (by |correlation| with EIRP) ===\")\nimportance = []\nfor inp in input_cols:\n    corr = abs(results[inp].corr(results[\"eirp_dbw\"]))\n    importance.append((inp, corr))\n\nimportance.sort(key=lambda x: x[1], reverse=True)\nfor param, corr in importance:\n    print(f\"  {param}: {corr:.3f}\")\n</code></pre>"},{"location":"tutorials/sensitivity-analysis/#step-10-robustness-analysis","title":"Step 10: Robustness Analysis","text":"<p>Evaluate performance variation around the baseline:</p> <pre><code># Add noise to baseline and evaluate\nnp.random.seed(42)\nn_monte_carlo = 100\n\n# Define parameter uncertainties (\u00b1%)\nuncertainties = {\n    \"rf.tx_power_w_per_elem\": 0.10,  # \u00b110%\n    \"rf.pa_efficiency\": 0.05,         # \u00b15%\n    \"cost.cost_per_elem_usd\": 0.15,   # \u00b115%\n}\n\nmc_results = []\nfor _ in range(n_monte_carlo):\n    params = baseline_flat.copy()\n\n    # Apply random perturbations\n    for param, pct in uncertainties.items():\n        nominal = baseline_flat[param]\n        perturbed = nominal * (1 + np.random.uniform(-pct, pct))\n        params[param] = perturbed\n\n    arch = Architecture.from_flat(params)\n    metrics = evaluate_case(arch, scenario)\n    mc_results.append(metrics)\n\nmc_df = pd.DataFrame(mc_results)\n\nprint(\"\\n=== Robustness Analysis (Monte Carlo) ===\")\nprint(f\"Based on {n_monte_carlo} samples with parameter uncertainties\")\nprint(f\"\\nEIRP (dBW):\")\nprint(f\"  Mean: {mc_df['eirp_dbw'].mean():.2f}\")\nprint(f\"  Std:  {mc_df['eirp_dbw'].std():.2f}\")\nprint(f\"  Range: [{mc_df['eirp_dbw'].min():.2f}, {mc_df['eirp_dbw'].max():.2f}]\")\n\nprint(f\"\\nLink Margin (dB):\")\nprint(f\"  Mean: {mc_df['link_margin_db'].mean():.2f}\")\nprint(f\"  Std:  {mc_df['link_margin_db'].std():.2f}\")\nprint(f\"  Min margin: {mc_df['link_margin_db'].min():.2f}\")\n</code></pre>"},{"location":"tutorials/sensitivity-analysis/#key-insights","title":"Key Insights","text":""},{"location":"tutorials/sensitivity-analysis/#high-impact-parameters","title":"High-Impact Parameters","text":"<p>From typical analyses:</p> <ol> <li>Array Size (nx, ny): Strongest driver of EIRP and cost</li> <li>TX Power: Linear effect on EIRP, major power driver</li> <li>Element Cost: Direct cost driver</li> <li>PA Efficiency: Power consumption driver</li> </ol>"},{"location":"tutorials/sensitivity-analysis/#low-impact-parameters","title":"Low-Impact Parameters","text":"<p>Parameters that can often be relaxed:</p> <ol> <li>Exact spacing: 0.45-0.55\u03bb typically similar performance</li> <li>Noise figure: Usually second-order effect on SNR</li> </ol>"},{"location":"tutorials/sensitivity-analysis/#interactions","title":"Interactions","text":"<ul> <li>Array size \u00d7 TX power: Can trade off (larger array, lower power)</li> <li>PA efficiency \u00d7 TX power: Both affect DC power</li> </ul>"},{"location":"tutorials/sensitivity-analysis/#best-practices","title":"Best Practices","text":"<ol> <li>Start with OAT: Quick understanding of individual effects</li> <li>Use DOE for interactions: Captures multi-parameter effects</li> <li>Focus on sensitivities: Concentrate design effort on sensitive parameters</li> <li>Validate with Monte Carlo: Understand robustness to uncertainties</li> </ol>"},{"location":"tutorials/sensitivity-analysis/#next-steps","title":"Next Steps","text":"<ul> <li>Communications Trade Study - Apply to full study</li> <li>Pareto Analysis - Multi-objective trade-offs</li> <li>Theory: Link Budget - Understand equations</li> </ul>"},{"location":"user-guide/","title":"User Guide","text":"<p>This guide provides detailed documentation for all features of phased-array-systems.</p>"},{"location":"user-guide/#overview","title":"Overview","text":"<p>The User Guide covers:</p> Section Description Architecture Array, RF chain, and cost configuration Scenarios Communications and radar scenarios Requirements Defining and verifying requirements Link Budget Communications link budget modeling Radar Detection Radar equation and detection analysis Trade Studies DOE generation and batch evaluation Pareto Analysis Multi-objective optimization Visualization Plotting functions and options Reports HTML and Markdown report generation"},{"location":"user-guide/#workflow-summary","title":"Workflow Summary","text":"<p>A typical analysis follows this workflow:</p> <pre><code>graph TD\n    A[Define Architecture] --&gt; B[Define Scenario]\n    B --&gt; C[Define Requirements]\n    C --&gt; D{Analysis Type}\n    D --&gt;|Single Case| E[evaluate_case]\n    D --&gt;|Trade Study| F[Define Design Space]\n    F --&gt; G[Generate DOE]\n    G --&gt; H[BatchRunner.run]\n    H --&gt; I[filter_feasible]\n    I --&gt; J[extract_pareto]\n    J --&gt; K[rank_pareto]\n    E --&gt; L[Visualize &amp; Report]\n    K --&gt; L</code></pre>"},{"location":"user-guide/#quick-reference","title":"Quick Reference","text":""},{"location":"user-guide/#architecture-configuration","title":"Architecture Configuration","text":"<pre><code>from phased_array_systems.architecture import (\n    Architecture,\n    ArrayConfig,\n    RFChainConfig,\n    CostConfig,\n)\n\narch = Architecture(\n    array=ArrayConfig(nx=8, ny=8, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(tx_power_w_per_elem=1.0, pa_efficiency=0.3),\n    cost=CostConfig(cost_per_elem_usd=100.0),\n)\n</code></pre>"},{"location":"user-guide/#scenario-definition","title":"Scenario Definition","text":"<pre><code>from phased_array_systems.scenarios import CommsLinkScenario\n\nscenario = CommsLinkScenario(\n    freq_hz=10e9,\n    bandwidth_hz=10e6,\n    range_m=100e3,\n    required_snr_db=10.0,\n)\n</code></pre>"},{"location":"user-guide/#requirements","title":"Requirements","text":"<pre><code>from phased_array_systems.requirements import Requirement, RequirementSet\n\nrequirements = RequirementSet(requirements=[\n    Requirement(\"REQ-001\", \"Min EIRP\", \"eirp_dbw\", \"&gt;=\", 40.0, severity=\"must\"),\n    Requirement(\"REQ-002\", \"Max Cost\", \"cost_usd\", \"&lt;=\", 50000.0, severity=\"must\"),\n])\n</code></pre>"},{"location":"user-guide/#single-case-evaluation","title":"Single Case Evaluation","text":"<pre><code>from phased_array_systems.evaluate import evaluate_case\n\nmetrics = evaluate_case(arch, scenario)\nreport = requirements.verify(metrics)\n</code></pre>"},{"location":"user-guide/#trade-study","title":"Trade Study","text":"<pre><code>from phased_array_systems.trades import (\n    DesignSpace,\n    generate_doe,\n    BatchRunner,\n    filter_feasible,\n    extract_pareto,\n)\n\n# Define design space\nspace = DesignSpace().add_variable(\"array.nx\", \"int\", low=4, high=16)\n\n# Generate DOE\ndoe = generate_doe(space, method=\"lhs\", n_samples=100, seed=42)\n\n# Run batch\nrunner = BatchRunner(scenario, requirements)\nresults = runner.run(doe)\n\n# Analyze\nfeasible = filter_feasible(results, requirements)\npareto = extract_pareto(feasible, [(\"cost_usd\", \"minimize\"), (\"eirp_dbw\", \"maximize\")])\n</code></pre>"},{"location":"user-guide/#visualization","title":"Visualization","text":"<pre><code>from phased_array_systems.viz import pareto_plot, scatter_matrix\n\nfig = pareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\", pareto_front=pareto)\nfig = scatter_matrix(feasible, columns=[\"cost_usd\", \"eirp_dbw\", \"link_margin_db\"])\n</code></pre>"},{"location":"user-guide/#related-documentation","title":"Related Documentation","text":"<ul> <li>Tutorials - Step-by-step guides</li> <li>API Reference - Complete API documentation</li> <li>Theory - Background equations and theory</li> </ul>"},{"location":"user-guide/architecture/","title":"Architecture Configuration","text":"<p>The <code>Architecture</code> class is the central configuration object in phased-array-systems. It defines all parameters of a phased array system design.</p>"},{"location":"user-guide/architecture/#overview","title":"Overview","text":"<p>An <code>Architecture</code> consists of three main components:</p> Component Class Description Array <code>ArrayConfig</code> Antenna array geometry and parameters RF Chain <code>RFChainConfig</code> Transmit/receive chain parameters Cost <code>CostConfig</code> Cost model parameters <pre><code>from phased_array_systems.architecture import (\n    Architecture,\n    ArrayConfig,\n    RFChainConfig,\n    CostConfig,\n)\n\narch = Architecture(\n    array=ArrayConfig(nx=8, ny=8),\n    rf=RFChainConfig(tx_power_w_per_elem=1.0),\n    cost=CostConfig(cost_per_elem_usd=100.0),\n    name=\"My Design\",\n)\n</code></pre>"},{"location":"user-guide/architecture/#arrayconfig","title":"ArrayConfig","text":"<p>The <code>ArrayConfig</code> class defines the antenna array geometry.</p>"},{"location":"user-guide/architecture/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>geometry</code> str <code>\"rectangular\"</code> Array geometry type <code>nx</code> int Required Elements in x-direction <code>ny</code> int Required Elements in y-direction <code>dx_lambda</code> float <code>0.5</code> X spacing (wavelengths) <code>dy_lambda</code> float <code>0.5</code> Y spacing (wavelengths) <code>scan_limit_deg</code> float <code>60.0</code> Maximum scan angle (degrees) <code>max_subarray_nx</code> int <code>8</code> Max elements per sub-array (x) <code>max_subarray_ny</code> int <code>8</code> Max elements per sub-array (y) <code>enforce_subarray_constraint</code> bool <code>True</code> Enforce power-of-2 sub-arrays"},{"location":"user-guide/architecture/#geometry-types","title":"Geometry Types","text":"<p>Currently supported:</p> <ul> <li><code>\"rectangular\"</code> - Standard rectangular grid</li> <li><code>\"circular\"</code> - Circular aperture</li> <li><code>\"triangular\"</code> - Triangular lattice</li> </ul>"},{"location":"user-guide/architecture/#example","title":"Example","text":"<pre><code>array = ArrayConfig(\n    geometry=\"rectangular\",\n    nx=16,\n    ny=16,\n    dx_lambda=0.5,           # Half-wavelength spacing\n    dy_lambda=0.5,\n    scan_limit_deg=60.0,     # \u00b160\u00b0 scan range\n    max_subarray_nx=8,       # 8x8 sub-arrays\n    max_subarray_ny=8,\n    enforce_subarray_constraint=True,\n)\n\nprint(f\"Total elements: {array.n_elements}\")  # 256\nprint(f\"Sub-arrays: {array.n_subarrays}\")     # 4\n</code></pre>"},{"location":"user-guide/architecture/#sub-array-constraints","title":"Sub-Array Constraints","text":"<p>For practical RF component design, array dimensions must be compatible with sub-array tiling. When <code>enforce_subarray_constraint=True</code>:</p> <ul> <li>Array dimensions (<code>nx</code>, <code>ny</code>) must be powers of 2 if smaller than <code>max_subarray_*</code></li> <li>Array dimensions must be divisible by <code>max_subarray_*</code> if larger</li> </ul> <p>Valid configurations: <pre><code># Small arrays: nx and ny must be powers of 2\nArrayConfig(nx=4, ny=4)   # OK\nArrayConfig(nx=8, ny=8)   # OK\n\n# Large arrays: must be divisible by max_subarray\nArrayConfig(nx=16, ny=16, max_subarray_nx=8)  # OK (16/8 = 2)\nArrayConfig(nx=24, ny=24, max_subarray_nx=8)  # OK (24/8 = 3)\n\n# Invalid (not power of 2 or not divisible)\nArrayConfig(nx=6, ny=6)   # Error\nArrayConfig(nx=12, ny=12, max_subarray_nx=8)  # Error (12/8 \u2260 integer)\n</code></pre></p> <p>To disable this constraint: <pre><code>ArrayConfig(nx=10, ny=10, enforce_subarray_constraint=False)  # OK\n</code></pre></p>"},{"location":"user-guide/architecture/#properties","title":"Properties","text":"Property Returns Description <code>n_elements</code> int Total element count (nx \u00d7 ny) <code>subarray_nx</code> int Elements per sub-array (x) <code>subarray_ny</code> int Elements per sub-array (y) <code>n_subarrays_x</code> int Number of sub-arrays (x) <code>n_subarrays_y</code> int Number of sub-arrays (y) <code>n_subarrays</code> int Total sub-array count <code>elements_per_subarray</code> int Elements in each sub-array"},{"location":"user-guide/architecture/#rfchainconfig","title":"RFChainConfig","text":"<p>The <code>RFChainConfig</code> class defines transmit and receive chain parameters.</p>"},{"location":"user-guide/architecture/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>tx_power_w_per_elem</code> float Required TX power per element (W) <code>pa_efficiency</code> float <code>0.3</code> Power amplifier efficiency (0-1) <code>noise_figure_db</code> float <code>3.0</code> Receiver noise figure (dB) <code>n_tx_beams</code> int <code>1</code> Number of TX beams <code>feed_loss_db</code> float <code>1.0</code> Feed network loss (dB) <code>system_loss_db</code> float <code>0.0</code> Additional system losses (dB)"},{"location":"user-guide/architecture/#example_1","title":"Example","text":"<pre><code>rf = RFChainConfig(\n    tx_power_w_per_elem=2.0,   # 2 Watts per element\n    pa_efficiency=0.35,        # 35% efficient\n    noise_figure_db=4.0,       # 4 dB NF\n    n_tx_beams=1,              # Single beam\n    feed_loss_db=1.5,          # 1.5 dB feed loss\n    system_loss_db=0.5,        # 0.5 dB other losses\n)\n</code></pre>"},{"location":"user-guide/architecture/#power-calculations","title":"Power Calculations","text":"<p>Total transmit power:</p> \\[ P_{tx,total} = P_{tx,elem} \\times N_{elements} \\] <p>DC power consumption:</p> \\[ P_{DC} = \\frac{P_{tx,total}}{\\eta_{PA}} \\] <p>Where \\(\\eta_{PA}\\) is the PA efficiency.</p>"},{"location":"user-guide/architecture/#costconfig","title":"CostConfig","text":"<p>The <code>CostConfig</code> class defines cost model parameters.</p>"},{"location":"user-guide/architecture/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>cost_per_elem_usd</code> float <code>100.0</code> Recurring cost per element ($) <code>nre_usd</code> float <code>0.0</code> Non-recurring engineering cost ($) <code>integration_cost_usd</code> float <code>0.0</code> System integration cost ($)"},{"location":"user-guide/architecture/#example_2","title":"Example","text":"<pre><code>cost = CostConfig(\n    cost_per_elem_usd=150.0,     # $150 per element\n    nre_usd=50000.0,             # $50k NRE\n    integration_cost_usd=10000.0, # $10k integration\n)\n</code></pre>"},{"location":"user-guide/architecture/#cost-calculations","title":"Cost Calculations","text":"<p>Total recurring cost:</p> \\[ C_{recurring} = C_{elem} \\times N_{elements} \\] <p>Total cost:</p> \\[ C_{total} = C_{recurring} + C_{NRE} + C_{integration} \\]"},{"location":"user-guide/architecture/#architecture-class","title":"Architecture Class","text":"<p>The <code>Architecture</code> class combines all components.</p>"},{"location":"user-guide/architecture/#parameters_3","title":"Parameters","text":"Parameter Type Default Description <code>array</code> ArrayConfig Required Array configuration <code>rf</code> RFChainConfig Required RF chain configuration <code>cost</code> CostConfig <code>CostConfig()</code> Cost configuration <code>name</code> str <code>None</code> Optional name"},{"location":"user-guide/architecture/#example_3","title":"Example","text":"<pre><code>arch = Architecture(\n    array=ArrayConfig(nx=8, ny=8, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(tx_power_w_per_elem=1.0, pa_efficiency=0.3),\n    cost=CostConfig(cost_per_elem_usd=100.0, nre_usd=10000.0),\n    name=\"8x8 Baseline Design\",\n)\n\nprint(f\"Name: {arch.name}\")\nprint(f\"Elements: {arch.n_elements}\")\n</code></pre>"},{"location":"user-guide/architecture/#flattening-and-reconstruction","title":"Flattening and Reconstruction","text":"<p>For DOE and serialization, architectures can be flattened to/from dictionaries:</p> <pre><code># Flatten to dict\nflat = arch.model_dump_flat()\n# {\n#     \"array.nx\": 8,\n#     \"array.ny\": 8,\n#     \"array.dx_lambda\": 0.5,\n#     \"rf.tx_power_w_per_elem\": 1.0,\n#     ...\n# }\n\n# Reconstruct from dict\narch2 = Architecture.from_flat(flat)\n</code></pre> <p>This is used internally by the DOE system to vary parameters.</p>"},{"location":"user-guide/architecture/#validation","title":"Validation","text":"<p>All configurations use Pydantic for validation:</p> <pre><code># This raises ValidationError\ntry:\n    ArrayConfig(nx=-1, ny=8)  # nx must be &gt;= 1\nexcept ValueError as e:\n    print(e)\n\ntry:\n    RFChainConfig(tx_power_w_per_elem=1.0, pa_efficiency=1.5)  # efficiency &gt; 1\nexcept ValueError as e:\n    print(e)\n</code></pre>"},{"location":"user-guide/architecture/#yaml-configuration","title":"YAML Configuration","text":"<p>Architectures can be defined in YAML:</p> <pre><code># architecture.yaml\narray:\n  geometry: rectangular\n  nx: 8\n  ny: 8\n  dx_lambda: 0.5\n  dy_lambda: 0.5\n  scan_limit_deg: 60.0\n\nrf:\n  tx_power_w_per_elem: 1.0\n  pa_efficiency: 0.3\n  noise_figure_db: 3.0\n  feed_loss_db: 1.0\n\ncost:\n  cost_per_elem_usd: 100.0\n  nre_usd: 10000.0\n  integration_cost_usd: 5000.0\n</code></pre> <p>Load with:</p> <pre><code>from phased_array_systems.io import load_config\n\nconfig = load_config(\"architecture.yaml\")\narch = config.get_architecture()\n</code></pre>"},{"location":"user-guide/architecture/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/architecture/#1-use-realistic-spacing","title":"1. Use Realistic Spacing","text":"<p>Half-wavelength spacing (\\(d = 0.5\\lambda\\)) is typical:</p> <pre><code>ArrayConfig(dx_lambda=0.5, dy_lambda=0.5)  # Standard\nArrayConfig(dx_lambda=0.6, dy_lambda=0.6)  # Wider (grating lobes possible)\n</code></pre>"},{"location":"user-guide/architecture/#2-consider-sub-array-constraints-early","title":"2. Consider Sub-Array Constraints Early","text":"<p>Design array dimensions to be compatible with sub-array tiling from the start.</p>"},{"location":"user-guide/architecture/#3-document-designs-with-names","title":"3. Document Designs with Names","text":"<pre><code>arch = Architecture(\n    ...,\n    name=\"Design_A_16x16_2W\",  # Descriptive name\n)\n</code></pre>"},{"location":"user-guide/architecture/#4-use-type-hints-for-ide-support","title":"4. Use Type Hints for IDE Support","text":"<pre><code>from phased_array_systems.architecture import Architecture\n\ndef analyze_design(arch: Architecture) -&gt; dict:\n    \"\"\"IDE will provide autocomplete for arch.\"\"\"\n    return {\"elements\": arch.n_elements}\n</code></pre>"},{"location":"user-guide/architecture/#see-also","title":"See Also","text":"<ul> <li>Scenarios - Define operating conditions</li> <li>Requirements - Define design requirements</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"user-guide/link-budget/","title":"Link Budget Modeling","text":"<p>phased-array-systems provides comprehensive communications link budget analysis for point-to-point and satellite links.</p>"},{"location":"user-guide/link-budget/#overview","title":"Overview","text":"<p>The link budget model calculates:</p> <ul> <li>EIRP: Effective Isotropic Radiated Power</li> <li>Path Loss: Free space and additional losses</li> <li>Received Power: Signal power at receiver</li> <li>SNR: Signal-to-noise ratio</li> <li>Link Margin: Margin above required SNR</li> </ul>"},{"location":"user-guide/link-budget/#link-budget-equation","title":"Link Budget Equation","text":"<p>The fundamental link budget equation:</p> \\[ P_{rx} = EIRP - L_{path} + G_{rx} \\] <p>Where:</p> <ul> <li>\\(P_{rx}\\) = Received power (dBW)</li> <li>\\(EIRP\\) = Effective Isotropic Radiated Power (dBW)</li> <li>\\(L_{path}\\) = Total path loss (dB)</li> <li>\\(G_{rx}\\) = Receive antenna gain (dBi)</li> </ul>"},{"location":"user-guide/link-budget/#eirp-calculation","title":"EIRP Calculation","text":"\\[ EIRP = P_{tx} + G_{tx} - L_{tx} \\] <p>Where:</p> <ul> <li>\\(P_{tx}\\) = Total transmit power (dBW)</li> <li>\\(G_{tx}\\) = Transmit antenna gain (dBi)</li> <li>\\(L_{tx}\\) = Transmit losses (feed + system)</li> </ul>"},{"location":"user-guide/link-budget/#snr-calculation","title":"SNR Calculation","text":"\\[ SNR = P_{rx} - N \\] \\[ N = 10 \\log_{10}(kTB) + NF \\] <p>Where:</p> <ul> <li>\\(k\\) = Boltzmann constant (1.38\u00d710\u207b\u00b2\u00b3 J/K)</li> <li>\\(T\\) = Noise temperature (K)</li> <li>\\(B\\) = Bandwidth (Hz)</li> <li>\\(NF\\) = Noise figure (dB)</li> </ul>"},{"location":"user-guide/link-budget/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/link-budget/#single-evaluation","title":"Single Evaluation","text":"<pre><code>from phased_array_systems.architecture import Architecture, ArrayConfig, RFChainConfig\nfrom phased_array_systems.scenarios import CommsLinkScenario\nfrom phased_array_systems.evaluate import evaluate_case\n\n# Define architecture\narch = Architecture(\n    array=ArrayConfig(nx=8, ny=8, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(\n        tx_power_w_per_elem=1.0,\n        pa_efficiency=0.3,\n        noise_figure_db=3.0,\n        feed_loss_db=1.0,\n    ),\n)\n\n# Define scenario\nscenario = CommsLinkScenario(\n    freq_hz=10e9,\n    bandwidth_hz=10e6,\n    range_m=100e3,\n    required_snr_db=10.0,\n    rx_antenna_gain_db=0.0,  # Isotropic receiver\n    rx_noise_temp_k=290.0,\n)\n\n# Evaluate\nmetrics = evaluate_case(arch, scenario)\n\n# Results\nprint(f\"TX Power Total: {metrics['tx_power_total_dbw']:.1f} dBW\")\nprint(f\"TX Antenna Gain: {metrics['g_tx_db']:.1f} dB\")\nprint(f\"EIRP: {metrics['eirp_dbw']:.1f} dBW\")\nprint(f\"Path Loss: {metrics['path_loss_db']:.1f} dB\")\nprint(f\"RX Power: {metrics['rx_power_dbw']:.1f} dBW\")\nprint(f\"Noise Power: {metrics['noise_power_dbw']:.1f} dBW\")\nprint(f\"SNR: {metrics['snr_rx_db']:.1f} dB\")\nprint(f\"Link Margin: {metrics['link_margin_db']:.1f} dB\")\n</code></pre>"},{"location":"user-guide/link-budget/#output-metrics","title":"Output Metrics","text":"Metric Units Description <code>tx_power_total_dbw</code> dBW Total TX power <code>tx_power_per_elem_dbw</code> dBW TX power per element <code>g_tx_db</code> dB Transmit antenna gain <code>eirp_dbw</code> dBW Effective isotropic radiated power <code>path_loss_db</code> dB Total path loss <code>fspl_db</code> dB Free space path loss only <code>g_rx_db</code> dB Receive antenna gain <code>rx_power_dbw</code> dBW Received signal power <code>noise_power_dbw</code> dBW Receiver noise power <code>snr_rx_db</code> dB Received SNR <code>link_margin_db</code> dB Margin above required SNR <code>required_snr_db</code> dB Required SNR (from scenario)"},{"location":"user-guide/link-budget/#direct-link-budget-function","title":"Direct Link Budget Function","text":"<p>For quick calculations without full architecture/scenario objects:</p> <pre><code>from phased_array_systems.models.comms.link_budget import compute_link_margin\n\nresult = compute_link_margin(\n    eirp_dbw=50.0,\n    path_loss_db=160.0,\n    g_rx_db=30.0,\n    noise_temp_k=290.0,\n    bandwidth_hz=10e6,\n    noise_figure_db=3.0,\n    required_snr_db=10.0,\n)\n\nprint(f\"RX Power: {result['rx_power_dbw']:.1f} dBW\")\nprint(f\"Noise Power: {result['noise_power_dbw']:.1f} dBW\")\nprint(f\"SNR: {result['snr_db']:.1f} dB\")\nprint(f\"Margin: {result['margin_db']:.1f} dB\")\n</code></pre>"},{"location":"user-guide/link-budget/#path-loss-models","title":"Path Loss Models","text":""},{"location":"user-guide/link-budget/#free-space-path-loss-fspl","title":"Free Space Path Loss (FSPL)","text":"<p>The default model:</p> \\[ L_{FSPL} = 20 \\log_{10}\\left(\\frac{4\\pi d f}{c}\\right) \\] <pre><code>from phased_array_systems.models.comms.propagation import compute_fspl\n\n# Calculate FSPL\nloss_db = compute_fspl(freq_hz=10e9, range_m=100e3)\nprint(f\"FSPL: {loss_db:.1f} dB\")  # ~152.4 dB\n</code></pre>"},{"location":"user-guide/link-budget/#additional-losses","title":"Additional Losses","text":"<p>The scenario can include extra losses:</p> <pre><code>scenario = CommsLinkScenario(\n    ...,\n    atmospheric_loss_db=0.5,   # Atmospheric absorption\n    rain_loss_db=3.0,          # Rain fade\n    polarization_loss_db=0.3,  # Polarization mismatch\n)\n\n# Total path loss = FSPL + atmospheric + rain + polarization\n</code></pre>"},{"location":"user-guide/link-budget/#antenna-gain","title":"Antenna Gain","text":""},{"location":"user-guide/link-budget/#from-context","title":"From Context","text":"<p>If antenna metrics are pre-computed, they're used from context:</p> <pre><code># With pre-computed antenna gain\ncontext = {\n    \"g_peak_db\": 28.0,\n    \"scan_loss_db\": 2.5,\n}\n\n# Link model uses these instead of approximation\n</code></pre>"},{"location":"user-guide/link-budget/#approximation","title":"Approximation","text":"<p>Without pre-computed values, gain is approximated:</p> \\[ G \\approx 4\\pi \\cdot n_x d_x \\cdot n_y d_y \\] <p>Where \\(d_x, d_y\\) are spacings in wavelengths.</p>"},{"location":"user-guide/link-budget/#scan-loss","title":"Scan Loss","text":"<p>When the beam is scanned off boresight, gain is reduced:</p> <pre><code>scenario = CommsLinkScenario(\n    ...,\n    scan_angle_deg=30.0,  # 30\u00b0 off boresight\n)\n</code></pre> <p>Scan loss is approximated or taken from antenna model context.</p>"},{"location":"user-guide/link-budget/#example-satellite-link","title":"Example: Satellite Link","text":"<pre><code># GEO satellite downlink\narch = Architecture(\n    array=ArrayConfig(nx=32, ny=32, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(\n        tx_power_w_per_elem=5.0,\n        pa_efficiency=0.25,\n        feed_loss_db=2.0,\n    ),\n)\n\nscenario = CommsLinkScenario(\n    freq_hz=12e9,              # Ku-band\n    bandwidth_hz=36e6,         # Transponder BW\n    range_m=36000e3,           # GEO distance\n    required_snr_db=8.0,       # QPSK\n    rx_antenna_gain_db=45.0,   # Large ground station\n    rx_noise_temp_k=80.0,      # Cooled LNA\n    atmospheric_loss_db=0.3,\n    rain_loss_db=5.0,          # Heavy rain margin\n)\n\nmetrics = evaluate_case(arch, scenario)\nprint(f\"Link Margin: {metrics['link_margin_db']:.1f} dB\")\n</code></pre>"},{"location":"user-guide/link-budget/#example-point-to-point-link","title":"Example: Point-to-Point Link","text":"<pre><code># Terrestrial backhaul\narch = Architecture(\n    array=ArrayConfig(nx=8, ny=8, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(tx_power_w_per_elem=0.5),\n)\n\nscenario = CommsLinkScenario(\n    freq_hz=26e9,              # 26 GHz\n    bandwidth_hz=100e6,        # 100 MHz\n    range_m=5e3,               # 5 km\n    required_snr_db=18.0,      # 64-QAM\n    rx_antenna_gain_db=35.0,   # Matching antenna\n    rx_noise_temp_k=500.0,\n    atmospheric_loss_db=1.0,   # Higher at 26 GHz\n    rain_loss_db=10.0,         # Significant at 26 GHz\n)\n\nmetrics = evaluate_case(arch, scenario)\n</code></pre>"},{"location":"user-guide/link-budget/#using-commslinkmodel-directly","title":"Using CommsLinkModel Directly","text":"<p>For advanced use, access the model directly:</p> <pre><code>from phased_array_systems.models.comms.link_budget import CommsLinkModel\n\nmodel = CommsLinkModel()\n\n# Evaluate with context (e.g., pre-computed antenna metrics)\ncontext = {\n    \"g_peak_db\": 30.0,\n    \"scan_loss_db\": 1.5,\n}\n\nmetrics = model.evaluate(arch, scenario, context)\n</code></pre>"},{"location":"user-guide/link-budget/#link-budget-trade-studies","title":"Link Budget Trade Studies","text":"<p>Combine with DOE for systematic analysis:</p> <pre><code>from phased_array_systems.trades import DesignSpace, generate_doe, BatchRunner\n\n# Vary array size and power\nspace = (\n    DesignSpace()\n    .add_variable(\"array.nx\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"array.ny\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"rf.tx_power_w_per_elem\", type=\"float\", low=0.5, high=3.0)\n    # Fixed parameters...\n)\n\ndoe = generate_doe(space, method=\"lhs\", n_samples=100, seed=42)\nrunner = BatchRunner(scenario)\nresults = runner.run(doe)\n\n# Analyze link margin vs cost trade-off\nprint(f\"Margin range: {results['link_margin_db'].min():.1f} to {results['link_margin_db'].max():.1f} dB\")\n</code></pre>"},{"location":"user-guide/link-budget/#validation-tips","title":"Validation Tips","text":""},{"location":"user-guide/link-budget/#check-intermediate-values","title":"Check Intermediate Values","text":"<pre><code># Validate each stage of link budget\nprint(f\"1. TX Power: {metrics['tx_power_total_dbw']:.2f} dBW\")\nprint(f\"2. + Gain: {metrics['g_tx_db']:.2f} dB\")\nprint(f\"3. - Feed Loss: {arch.rf.feed_loss_db:.2f} dB\")\nprint(f\"4. = EIRP: {metrics['eirp_dbw']:.2f} dBW\")\nprint(f\"5. - Path Loss: {metrics['path_loss_db']:.2f} dB\")\nprint(f\"6. + RX Gain: {metrics['g_rx_db']:.2f} dB\")\nprint(f\"7. = RX Power: {metrics['rx_power_dbw']:.2f} dBW\")\n</code></pre>"},{"location":"user-guide/link-budget/#sanity-checks","title":"Sanity Checks","text":"<pre><code># EIRP should be reasonable\nassert 20 &lt; metrics['eirp_dbw'] &lt; 80, \"EIRP out of typical range\"\n\n# Path loss increases with range and frequency\n# At 10 GHz, 100 km: ~152 dB\nassert 100 &lt; metrics['path_loss_db'] &lt; 200, \"Path loss unusual\"\n\n# Margin should match expectations\nexpected_margin = metrics['snr_rx_db'] - scenario.required_snr_db\nassert abs(metrics['link_margin_db'] - expected_margin) &lt; 0.01\n</code></pre>"},{"location":"user-guide/link-budget/#see-also","title":"See Also","text":"<ul> <li>Theory: Link Budget Equations - Detailed derivations</li> <li>Scenarios - Configure link scenarios</li> <li>Trade Studies - Systematic link analysis</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"user-guide/pareto-analysis/","title":"Pareto Analysis","text":"<p>Pareto analysis identifies optimal trade-offs when multiple objectives conflict. A design is Pareto-optimal if no other design is better in all objectives.</p>"},{"location":"user-guide/pareto-analysis/#pareto-optimality","title":"Pareto Optimality","text":""},{"location":"user-guide/pareto-analysis/#concept","title":"Concept","text":"<p>In multi-objective optimization, there's rarely a single \"best\" design. Instead, we find the Pareto frontier - the set of designs where improving one objective requires sacrificing another.</p> <pre><code>graph LR\n    subgraph \"Trade Space\"\n        A((Design A)) --- B((Design B))\n        B --- C((Design C))\n        style A fill:#f9f,stroke:#333\n        style B fill:#f9f,stroke:#333\n        style C fill:#f9f,stroke:#333\n    end</code></pre> <p>Design A is Pareto-optimal if there exists no other design that is:</p> <ul> <li>Better in at least one objective</li> <li>At least as good in all other objectives</li> </ul>"},{"location":"user-guide/pareto-analysis/#example","title":"Example","text":"<p>Consider cost vs. performance:</p> Design Cost ($) EIRP (dBW) Pareto? A 20,000 42 Yes B 30,000 48 Yes C 25,000 44 Yes D 35,000 46 No (dominated by B) E 28,000 43 No (dominated by C) <p>Design D is dominated because B has better EIRP at similar cost.</p>"},{"location":"user-guide/pareto-analysis/#extracting-pareto-frontier","title":"Extracting Pareto Frontier","text":""},{"location":"user-guide/pareto-analysis/#basic-usage","title":"Basic Usage","text":"<pre><code>from phased_array_systems.trades import extract_pareto\n\n# Define objectives: (metric_name, direction)\nobjectives = [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n]\n\n# Extract Pareto-optimal designs\npareto = extract_pareto(results, objectives)\n\nprint(f\"Pareto-optimal: {len(pareto)} out of {len(results)}\")\n</code></pre>"},{"location":"user-guide/pareto-analysis/#objective-directions","title":"Objective Directions","text":"Direction Meaning <code>\"minimize\"</code> Lower is better <code>\"maximize\"</code> Higher is better"},{"location":"user-guide/pareto-analysis/#multiple-objectives","title":"Multiple Objectives","text":"<pre><code># Three objectives\nobjectives = [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n    (\"prime_power_w\", \"minimize\"),\n]\n\npareto = extract_pareto(feasible, objectives)\n</code></pre>"},{"location":"user-guide/pareto-analysis/#including-dominated-points","title":"Including Dominated Points","text":"<p>To mark all points with Pareto status:</p> <pre><code>all_results = extract_pareto(results, objectives, include_dominated=True)\n\n# Results include 'pareto_optimal' column\npareto_mask = all_results[\"pareto_optimal\"]\nprint(f\"Pareto points: {pareto_mask.sum()}\")\n</code></pre>"},{"location":"user-guide/pareto-analysis/#ranking-pareto-designs","title":"Ranking Pareto Designs","text":"<p>Since all Pareto designs are optimal, ranking requires additional preferences.</p>"},{"location":"user-guide/pareto-analysis/#weighted-sum","title":"Weighted Sum","text":"<pre><code>from phased_array_systems.trades import rank_pareto\n\nranked = rank_pareto(\n    pareto,\n    objectives,\n    weights=[0.5, 0.5],  # Equal weight\n    method=\"weighted_sum\",\n)\n\n# Results sorted by rank\nprint(ranked[[\"case_id\", \"cost_usd\", \"eirp_dbw\", \"pareto_rank\"]].head())\n</code></pre> <p>Weight interpretation:</p> <ul> <li>Higher weight = more important</li> <li>Weights are normalized internally</li> </ul>"},{"location":"user-guide/pareto-analysis/#topsis-method","title":"TOPSIS Method","text":"<p>Technique for Order of Preference by Similarity to Ideal Solution:</p> <pre><code>ranked = rank_pareto(\n    pareto,\n    objectives,\n    weights=[0.6, 0.4],\n    method=\"topsis\",\n)\n</code></pre> <p>TOPSIS ranks based on distance to ideal and anti-ideal points.</p>"},{"location":"user-guide/pareto-analysis/#custom-weights","title":"Custom Weights","text":"<p>Encode stakeholder preferences:</p> <pre><code># Cost-conscious: prioritize cost\nranked = rank_pareto(pareto, objectives, weights=[0.8, 0.2])\n\n# Performance-focused: prioritize EIRP\nranked = rank_pareto(pareto, objectives, weights=[0.2, 0.8])\n</code></pre>"},{"location":"user-guide/pareto-analysis/#filtering-before-pareto","title":"Filtering Before Pareto","text":"<p>Always filter to feasible designs first:</p> <pre><code>from phased_array_systems.trades import filter_feasible\n\n# Filter feasible\nfeasible = filter_feasible(results, requirements)\n\n# Then extract Pareto\npareto = extract_pareto(feasible, objectives)\n</code></pre> <p>If you include infeasible designs, they might appear Pareto-optimal (low cost but also low performance because requirements aren't met).</p>"},{"location":"user-guide/pareto-analysis/#hypervolume-indicator","title":"Hypervolume Indicator","text":"<p>The hypervolume measures the quality of a Pareto front - larger is better.</p> <pre><code>from phased_array_systems.trades import compute_hypervolume\n\nhv = compute_hypervolume(pareto, objectives)\nprint(f\"Hypervolume: {hv:.2e}\")\n</code></pre> <p>Uses:</p> <ul> <li>Compare different DOE runs</li> <li>Track optimization progress</li> <li>Evaluate Pareto front quality</li> </ul>"},{"location":"user-guide/pareto-analysis/#reference-point","title":"Reference Point","text":"<p>The hypervolume is computed relative to a reference point:</p> <pre><code># Custom reference (worst acceptable values)\nhv = compute_hypervolume(\n    pareto,\n    objectives,\n    reference_point=[200000, -30],  # [max_cost, min_eirp]\n)\n</code></pre> <p>Default: worst observed + 10%.</p>"},{"location":"user-guide/pareto-analysis/#visualization","title":"Visualization","text":""},{"location":"user-guide/pareto-analysis/#pareto-plot","title":"Pareto Plot","text":"<pre><code>from phased_array_systems.viz import pareto_plot\n\nfig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    pareto_front=pareto,\n    feasible_mask=results[\"verification.passes\"] == 1.0,\n    color_by=\"link_margin_db\",\n    title=\"Cost vs EIRP Trade Space\",\n)\nfig.savefig(\"pareto.png\", dpi=150)\n</code></pre>"},{"location":"user-guide/pareto-analysis/#3d-trade-space","title":"3D Trade Space","text":"<p>For three objectives:</p> <pre><code>from phased_array_systems.viz import trade_space_plot\n\nfig = trade_space_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    z=\"prime_power_w\",\n    pareto_front=pareto,\n)\n</code></pre>"},{"location":"user-guide/pareto-analysis/#complete-workflow","title":"Complete Workflow","text":"<pre><code>\"\"\"Complete Pareto analysis workflow.\"\"\"\n\nfrom phased_array_systems.trades import (\n    filter_feasible, extract_pareto, rank_pareto, compute_hypervolume\n)\nfrom phased_array_systems.viz import pareto_plot\n\n# 1. Filter to feasible designs\nfeasible = filter_feasible(results, requirements)\nprint(f\"Feasible: {len(feasible)}/{len(results)}\")\n\n# 2. Define objectives\nobjectives = [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n]\n\n# 3. Extract Pareto frontier\npareto = extract_pareto(feasible, objectives)\nprint(f\"Pareto-optimal: {len(pareto)}\")\n\n# 4. Compute hypervolume\nhv = compute_hypervolume(pareto, objectives)\nprint(f\"Hypervolume: {hv:.2e}\")\n\n# 5. Rank with different preference scenarios\nscenarios = [\n    (\"Cost-focused\", [0.8, 0.2]),\n    (\"Balanced\", [0.5, 0.5]),\n    (\"Performance-focused\", [0.2, 0.8]),\n]\n\nfor name, weights in scenarios:\n    ranked = rank_pareto(pareto, objectives, weights=weights)\n    best = ranked.iloc[0]\n    print(f\"\\n{name}: {best['case_id']}\")\n    print(f\"  Cost: ${best['cost_usd']:,.0f}\")\n    print(f\"  EIRP: {best['eirp_dbw']:.1f} dBW\")\n\n# 6. Visualize\nfig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    pareto_front=pareto,\n    feasible_mask=results[\"verification.passes\"] == 1.0,\n)\n</code></pre>"},{"location":"user-guide/pareto-analysis/#advanced-topics","title":"Advanced Topics","text":""},{"location":"user-guide/pareto-analysis/#knee-point-detection","title":"Knee Point Detection","text":"<p>Find the \"knee\" of the Pareto front - the design with best trade-off:</p> <pre><code>import numpy as np\n\n# Normalize objectives\ncost_norm = (pareto[\"cost_usd\"] - pareto[\"cost_usd\"].min()) / (\n    pareto[\"cost_usd\"].max() - pareto[\"cost_usd\"].min()\n)\neirp_norm = (pareto[\"eirp_dbw\"].max() - pareto[\"eirp_dbw\"]) / (\n    pareto[\"eirp_dbw\"].max() - pareto[\"eirp_dbw\"].min()\n)\n\n# Distance from ideal (0,0)\ndistance = np.sqrt(cost_norm**2 + eirp_norm**2)\nknee_idx = distance.argmin()\nknee_design = pareto.iloc[knee_idx]\nprint(f\"Knee point: {knee_design['case_id']}\")\n</code></pre>"},{"location":"user-guide/pareto-analysis/#epsilon-dominance","title":"Epsilon-Dominance","text":"<p>Relaxed dominance for diverse Pareto front:</p> <pre><code>def epsilon_dominates(a, b, objectives, epsilon=0.01):\n    \"\"\"Check if design a epsilon-dominates design b.\"\"\"\n    for metric, direction in objectives:\n        a_val, b_val = a[metric], b[metric]\n        if direction == \"minimize\":\n            if a_val &gt; b_val * (1 + epsilon):\n                return False\n        else:\n            if a_val &lt; b_val * (1 - epsilon):\n                return False\n    return True\n</code></pre>"},{"location":"user-guide/pareto-analysis/#progressive-pareto","title":"Progressive Pareto","text":"<p>Track Pareto front evolution during adaptive sampling:</p> <pre><code>fronts = []\nfor n_samples in [20, 50, 100, 200]:\n    doe = generate_doe(space, n_samples=n_samples, seed=42)\n    results = runner.run(doe)\n    feasible = filter_feasible(results, requirements)\n    pareto = extract_pareto(feasible, objectives)\n    hv = compute_hypervolume(pareto, objectives)\n    fronts.append({\"n_samples\": n_samples, \"n_pareto\": len(pareto), \"hv\": hv})\n\nprint(pd.DataFrame(fronts))\n</code></pre>"},{"location":"user-guide/pareto-analysis/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/pareto-analysis/#1-always-filter-first","title":"1. Always Filter First","text":"<pre><code># Good: filter then Pareto\nfeasible = filter_feasible(results, requirements)\npareto = extract_pareto(feasible, objectives)\n\n# Bad: Pareto on raw results (includes infeasible)\npareto = extract_pareto(results, objectives)  # Don't do this!\n</code></pre>"},{"location":"user-guide/pareto-analysis/#2-choose-objectives-carefully","title":"2. Choose Objectives Carefully","text":"<ul> <li>Include objectives that conflict</li> <li>Avoid redundant objectives</li> <li>Consider 2-3 key objectives</li> </ul>"},{"location":"user-guide/pareto-analysis/#3-document-weights","title":"3. Document Weights","text":"<pre><code># Document decision rationale\nweights = {\n    \"cost_usd\": 0.4,      # Budget-constrained\n    \"eirp_dbw\": 0.4,      # Performance critical\n    \"prime_power_w\": 0.2,  # Power is secondary\n}\n</code></pre>"},{"location":"user-guide/pareto-analysis/#4-present-multiple-scenarios","title":"4. Present Multiple Scenarios","text":"<p>Show how rankings change with different preferences:</p> <pre><code>for scenario_name, scenario_weights in preference_scenarios.items():\n    ranked = rank_pareto(pareto, objectives, weights=list(scenario_weights.values()))\n    print(f\"\\n{scenario_name}: Top 3\")\n    for _, row in ranked.head(3).iterrows():\n        print(f\"  {row['case_id']}\")\n</code></pre>"},{"location":"user-guide/pareto-analysis/#see-also","title":"See Also","text":"<ul> <li>Trade Studies - DOE and batch evaluation</li> <li>Visualization - Plotting functions</li> <li>Theory: Pareto Optimization - Mathematical background</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"user-guide/radar-detection/","title":"Radar Detection Modeling","text":"<p>phased-array-systems provides radar detection performance analysis based on the radar range equation and detection theory.</p>"},{"location":"user-guide/radar-detection/#overview","title":"Overview","text":"<p>The radar detection model calculates:</p> <ul> <li>Single-pulse SNR: Signal-to-noise ratio for one pulse</li> <li>Integrated SNR: SNR after pulse integration</li> <li>Required SNR: SNR needed for detection</li> <li>Detection range: Maximum range for given Pd/Pfa</li> <li>SNR margin: Margin above detection threshold</li> </ul>"},{"location":"user-guide/radar-detection/#radar-range-equation","title":"Radar Range Equation","text":"<p>The fundamental radar equation:</p> \\[ SNR = \\frac{P_t G^2 \\lambda^2 \\sigma}{(4\\pi)^3 R^4 k T_s B_n L_s} \\] <p>Where:</p> <ul> <li>\\(P_t\\) = Peak transmit power (W)</li> <li>\\(G\\) = Antenna gain (linear)</li> <li>\\(\\lambda\\) = Wavelength (m)</li> <li>\\(\\sigma\\) = Target radar cross section (m\u00b2)</li> <li>\\(R\\) = Target range (m)</li> <li>\\(k\\) = Boltzmann constant</li> <li>\\(T_s\\) = System noise temperature (K)</li> <li>\\(B_n\\) = Noise bandwidth (Hz)</li> <li>\\(L_s\\) = System losses (linear)</li> </ul>"},{"location":"user-guide/radar-detection/#basic-usage","title":"Basic Usage","text":"<pre><code>from phased_array_systems.architecture import Architecture, ArrayConfig, RFChainConfig\nfrom phased_array_systems.scenarios import RadarDetectionScenario\nfrom phased_array_systems.evaluate import evaluate_case\n\n# Define architecture\narch = Architecture(\n    array=ArrayConfig(nx=16, ny=16, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(\n        tx_power_w_per_elem=10.0,\n        pa_efficiency=0.25,\n        noise_figure_db=4.0,\n    ),\n)\n\n# Define scenario\nscenario = RadarDetectionScenario(\n    freq_hz=10e9,              # X-band\n    target_rcs_m2=1.0,         # 1 m\u00b2 target\n    range_m=100e3,             # 100 km\n    required_pd=0.9,           # 90% detection probability\n    pfa=1e-6,                  # 10\u207b\u2076 false alarm rate\n    pulse_width_s=10e-6,       # 10 \u03bcs pulse\n    prf_hz=1000,               # 1 kHz PRF\n    n_pulses=10,               # Integrate 10 pulses\n    integration_type=\"coherent\",\n    swerling_model=1,\n)\n\n# Evaluate\nmetrics = evaluate_case(arch, scenario)\n\nprint(f\"Single-Pulse SNR: {metrics['snr_single_pulse_db']:.1f} dB\")\nprint(f\"Integrated SNR: {metrics['snr_integrated_db']:.1f} dB\")\nprint(f\"Required SNR: {metrics['snr_required_db']:.1f} dB\")\nprint(f\"SNR Margin: {metrics['snr_margin_db']:.1f} dB\")\n</code></pre>"},{"location":"user-guide/radar-detection/#output-metrics","title":"Output Metrics","text":"Metric Units Description <code>snr_single_pulse_db</code> dB SNR for one pulse <code>snr_integrated_db</code> dB SNR after integration <code>snr_required_db</code> dB Required SNR for Pd/Pfa <code>snr_margin_db</code> dB Margin above required <code>detection_range_m</code> m Max range for requirements"},{"location":"user-guide/radar-detection/#detection-probability","title":"Detection Probability","text":""},{"location":"user-guide/radar-detection/#required-snr-calculation","title":"Required SNR Calculation","text":"<p>The required SNR depends on:</p> <ul> <li>Desired detection probability (Pd)</li> <li>False alarm probability (Pfa)</li> <li>Target fluctuation model (Swerling)</li> </ul> <p>For Swerling 0 (non-fluctuating):</p> \\[ SNR_{req} = \\frac{[\\text{erfc}^{-1}(2P_{fa}) - \\text{erfc}^{-1}(2P_d)]^2}{2} \\]"},{"location":"user-guide/radar-detection/#swerling-target-models","title":"Swerling Target Models","text":"Model Description Typical Targets 0 Non-fluctuating Sphere, corner reflector 1 Slow fluctuation, Rayleigh Aircraft (scan-to-scan) 2 Fast fluctuation, Rayleigh Aircraft (pulse-to-pulse) 3 Slow, one dominant + many Ship, complex target 4 Fast, one dominant + many Propeller aircraft <pre><code># Different Swerling models\nscenario_sw0 = RadarDetectionScenario(..., swerling_model=0)  # Steady target\nscenario_sw1 = RadarDetectionScenario(..., swerling_model=1)  # Typical aircraft\nscenario_sw3 = RadarDetectionScenario(..., swerling_model=3)  # Ship\n</code></pre>"},{"location":"user-guide/radar-detection/#pulse-integration","title":"Pulse Integration","text":""},{"location":"user-guide/radar-detection/#coherent-integration","title":"Coherent Integration","text":"<p>Maintains phase information; provides linear SNR improvement:</p> \\[ SNR_{integrated} = N \\cdot SNR_{single} \\] <pre><code>scenario = RadarDetectionScenario(\n    ...,\n    n_pulses=16,\n    integration_type=\"coherent\",\n)\n# SNR improves by 10*log10(16) = 12 dB\n</code></pre>"},{"location":"user-guide/radar-detection/#non-coherent-integration","title":"Non-Coherent Integration","text":"<p>Magnitude-only; provides approximately \u221aN improvement:</p> \\[ SNR_{integrated} \\approx \\sqrt{N} \\cdot SNR_{single} \\] <pre><code>scenario = RadarDetectionScenario(\n    ...,\n    n_pulses=16,\n    integration_type=\"noncoherent\",\n)\n# SNR improves by approximately 10*log10(\u221a16) = 6 dB\n</code></pre>"},{"location":"user-guide/radar-detection/#using-the-radar-model-directly","title":"Using the Radar Model Directly","text":"<p>For advanced use cases:</p> <pre><code>from phased_array_systems.models.radar.equation import RadarEquationModel\nfrom phased_array_systems.models.radar.detection import compute_required_snr\n\n# Calculate required SNR\nsnr_req = compute_required_snr(\n    pd=0.9,\n    pfa=1e-6,\n    swerling_model=1,\n    n_pulses=10,\n)\nprint(f\"Required SNR: {snr_req:.1f} dB\")\n\n# Use radar equation model directly\nmodel = RadarEquationModel()\nmetrics = model.evaluate(arch, scenario, context={})\n</code></pre>"},{"location":"user-guide/radar-detection/#detection-range-calculation","title":"Detection Range Calculation","text":"<p>Solve for range at which SNR equals required SNR:</p> <pre><code>from phased_array_systems.models.radar.detection import compute_detection_range\n\nmax_range = compute_detection_range(\n    snr_single_db=15.0,\n    snr_required_db=13.0,\n    current_range_m=100e3,\n)\nprint(f\"Detection range: {max_range/1000:.1f} km\")\n</code></pre>"},{"location":"user-guide/radar-detection/#example-search-radar","title":"Example: Search Radar","text":"<pre><code># Long-range search radar\narch = Architecture(\n    array=ArrayConfig(nx=32, ny=32, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(\n        tx_power_w_per_elem=20.0,  # High power\n        pa_efficiency=0.20,\n        noise_figure_db=3.5,\n    ),\n)\n\nscenario = RadarDetectionScenario(\n    freq_hz=3e9,               # S-band (longer range)\n    target_rcs_m2=2.0,         # Medium aircraft\n    range_m=200e3,             # 200 km search\n    required_pd=0.8,           # 80% Pd\n    pfa=1e-6,\n    pulse_width_s=50e-6,       # Long pulse\n    prf_hz=300,\n    n_pulses=20,               # Long integration\n    integration_type=\"noncoherent\",\n    swerling_model=1,\n)\n\nmetrics = evaluate_case(arch, scenario)\nprint(f\"SNR Margin at 200 km: {metrics['snr_margin_db']:.1f} dB\")\n</code></pre>"},{"location":"user-guide/radar-detection/#example-tracking-radar","title":"Example: Tracking Radar","text":"<pre><code># Precision tracking radar\narch = Architecture(\n    array=ArrayConfig(nx=16, ny=16, dx_lambda=0.5, dy_lambda=0.5),\n    rf=RFChainConfig(\n        tx_power_w_per_elem=5.0,\n        pa_efficiency=0.30,\n        noise_figure_db=3.0,\n    ),\n)\n\nscenario = RadarDetectionScenario(\n    freq_hz=10e9,              # X-band (precision)\n    target_rcs_m2=0.5,         # Smaller target\n    range_m=50e3,              # 50 km track\n    required_pd=0.99,          # High Pd for tracking\n    pfa=1e-4,                  # Relaxed Pfa (verified target)\n    pulse_width_s=5e-6,        # Short pulse (range resolution)\n    prf_hz=5000,               # High PRF\n    n_pulses=100,              # Many pulses\n    integration_type=\"coherent\",\n    swerling_model=0,          # Stabilized target\n)\n\nmetrics = evaluate_case(arch, scenario)\n</code></pre>"},{"location":"user-guide/radar-detection/#radar-trade-studies","title":"Radar Trade Studies","text":"<p>Combine with DOE for systematic analysis:</p> <pre><code>from phased_array_systems.trades import DesignSpace, generate_doe, BatchRunner\nfrom phased_array_systems.requirements import Requirement, RequirementSet\n\n# Define requirements\nrequirements = RequirementSet(requirements=[\n    Requirement(\"DET-001\", \"Positive SNR Margin\", \"snr_margin_db\", \"&gt;=\", 0.0, severity=\"must\"),\n    Requirement(\"COST-001\", \"Max Cost\", \"cost_usd\", \"&lt;=\", 1000000.0, severity=\"must\"),\n])\n\n# Define design space\nspace = (\n    DesignSpace()\n    .add_variable(\"array.nx\", type=\"categorical\", values=[8, 16, 32])\n    .add_variable(\"array.ny\", type=\"categorical\", values=[8, 16, 32])\n    .add_variable(\"rf.tx_power_w_per_elem\", type=\"float\", low=5.0, high=20.0)\n    # ... other parameters\n)\n\n# Run trade study\ndoe = generate_doe(space, method=\"lhs\", n_samples=100, seed=42)\nrunner = BatchRunner(scenario, requirements)\nresults = runner.run(doe)\n\n# Find Pareto-optimal designs\nfrom phased_array_systems.trades import filter_feasible, extract_pareto\n\nfeasible = filter_feasible(results, requirements)\npareto = extract_pareto(feasible, [\n    (\"cost_usd\", \"minimize\"),\n    (\"snr_margin_db\", \"maximize\"),\n])\n</code></pre>"},{"location":"user-guide/radar-detection/#sensitivity-analysis","title":"Sensitivity Analysis","text":"<p>Analyze how parameters affect detection:</p> <pre><code>import numpy as np\nimport pandas as pd\n\n# Vary range\nranges = np.linspace(50e3, 200e3, 20)\nresults = []\n\nfor range_m in ranges:\n    scenario.range_m = range_m\n    metrics = evaluate_case(arch, scenario)\n    results.append({\n        \"range_km\": range_m / 1000,\n        \"snr_margin_db\": metrics[\"snr_margin_db\"],\n    })\n\ndf = pd.DataFrame(results)\nprint(df)\n</code></pre>"},{"location":"user-guide/radar-detection/#key-considerations","title":"Key Considerations","text":""},{"location":"user-guide/radar-detection/#power-aperture-product","title":"Power-Aperture Product","text":"<p>Radar performance scales with power \u00d7 aperture:</p> \\[ PA = P_t \\cdot A_{eff} = P_t \\cdot \\frac{G \\lambda^2}{4\\pi} \\] <p>Trade off between:</p> <ul> <li>More power (higher cost, heat)</li> <li>Larger aperture (more elements, higher cost)</li> </ul>"},{"location":"user-guide/radar-detection/#frequency-selection","title":"Frequency Selection","text":"Lower Frequency Higher Frequency Longer range Better resolution Larger aperture for same gain Smaller components Better rain penetration More atmospheric loss"},{"location":"user-guide/radar-detection/#integration-time","title":"Integration Time","text":"<p>More pulses = better SNR, but:</p> <ul> <li>Longer dwell time per beam position</li> <li>Target motion limits coherent integration</li> <li>Faster scan requires fewer pulses</li> </ul>"},{"location":"user-guide/radar-detection/#see-also","title":"See Also","text":"<ul> <li>Theory: Radar Equation - Detailed derivations</li> <li>Scenarios - Configure radar scenarios</li> <li>Trade Studies - Systematic radar analysis</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"user-guide/reports/","title":"Report Generation","text":"<p>phased-array-systems can generate HTML and Markdown reports summarizing trade study results.</p>"},{"location":"user-guide/reports/#overview","title":"Overview","text":"<p>Reports include:</p> <ul> <li>Executive summary with key statistics</li> <li>Requirements verification summary</li> <li>Pareto frontier analysis</li> <li>Design space exploration metrics</li> <li>Top design recommendations</li> </ul>"},{"location":"user-guide/reports/#report-types","title":"Report Types","text":"Type Class Output HTML <code>HTMLReport</code> Standalone HTML file Markdown <code>MarkdownReport</code> Markdown text file"},{"location":"user-guide/reports/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/reports/#html-report","title":"HTML Report","text":"<pre><code>from phased_array_systems.reports import HTMLReport, ReportConfig\nimport pandas as pd\n\n# Load results\nresults = pd.read_parquet(\"results.parquet\")\n\n# Configure report\nconfig = ReportConfig(\n    title=\"Communications Array Trade Study\",\n)\n\n# Generate HTML\nreport = HTMLReport(config)\ncontent = report.generate(results)\n\n# Save\nreport.save(content, \"report.html\")\n</code></pre>"},{"location":"user-guide/reports/#markdown-report","title":"Markdown Report","text":"<pre><code>from phased_array_systems.reports import MarkdownReport, ReportConfig\n\nconfig = ReportConfig(title=\"Trade Study Summary\")\nreport = MarkdownReport(config)\ncontent = report.generate(results)\nreport.save(content, \"report.md\")\n</code></pre>"},{"location":"user-guide/reports/#reportconfig","title":"ReportConfig","text":"<p>Configure report generation:</p> <pre><code>from phased_array_systems.reports import ReportConfig\n\nconfig = ReportConfig(\n    title=\"My Trade Study\",\n    description=\"Analysis of array configurations for X-band communications\",\n    author=\"Engineering Team\",\n    version=\"1.0\",\n)\n</code></pre>"},{"location":"user-guide/reports/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>title</code> str \"Trade Study Report\" Report title <code>description</code> str None Optional description <code>author</code> str None Author name <code>version</code> str None Report version"},{"location":"user-guide/reports/#cli-usage","title":"CLI Usage","text":"<p>Generate reports from the command line:</p> <pre><code># HTML report (default)\npasys report results.parquet -o report.html\n\n# Markdown report\npasys report results.parquet --format markdown -o report.md\n\n# Custom title\npasys report results.parquet --title \"Q4 Trade Study\"\n</code></pre>"},{"location":"user-guide/reports/#report-contents","title":"Report Contents","text":""},{"location":"user-guide/reports/#executive-summary","title":"Executive Summary","text":"<ul> <li>Total cases evaluated</li> <li>Feasible designs count and percentage</li> <li>Pareto-optimal design count</li> <li>Key metric ranges (min, max, mean)</li> </ul>"},{"location":"user-guide/reports/#requirements-verification","title":"Requirements Verification","text":"<ul> <li>Pass/fail summary</li> <li>Requirement-by-requirement status</li> <li>Margin statistics</li> </ul>"},{"location":"user-guide/reports/#pareto-analysis","title":"Pareto Analysis","text":"<ul> <li>Number of Pareto-optimal designs</li> <li>Objective trade-offs</li> <li>Top recommended designs</li> </ul>"},{"location":"user-guide/reports/#design-statistics","title":"Design Statistics","text":"<ul> <li>Design variable distributions</li> <li>Output metric statistics</li> <li>Correlation highlights</li> </ul>"},{"location":"user-guide/reports/#customizing-reports","title":"Customizing Reports","text":""},{"location":"user-guide/reports/#adding-figures","title":"Adding Figures","text":"<p>Generate and embed figures in reports:</p> <pre><code>from phased_array_systems.viz import pareto_plot\nfrom phased_array_systems.trades import extract_pareto\nimport base64\nfrom io import BytesIO\n\n# Generate figure\npareto = extract_pareto(results, [(\"cost_usd\", \"minimize\"), (\"eirp_dbw\", \"maximize\")])\nfig = pareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\", pareto_front=pareto)\n\n# Convert to base64 for HTML embedding\nbuffer = BytesIO()\nfig.savefig(buffer, format='png', dpi=150, bbox_inches='tight')\nbuffer.seek(0)\nimg_data = base64.b64encode(buffer.getvalue()).decode()\n\n# Use in custom HTML\nhtml_img = f'&lt;img src=\"data:image/png;base64,{img_data}\" alt=\"Pareto Plot\"&gt;'\n</code></pre>"},{"location":"user-guide/reports/#custom-sections","title":"Custom Sections","text":"<p>Extend the base report classes:</p> <pre><code>from phased_array_systems.reports import HTMLReport, ReportConfig\n\nclass CustomHTMLReport(HTMLReport):\n    def generate(self, results):\n        # Call parent\n        html = super().generate(results)\n\n        # Add custom section before closing body\n        custom_section = \"\"\"\n        &lt;section&gt;\n            &lt;h2&gt;Custom Analysis&lt;/h2&gt;\n            &lt;p&gt;Additional project-specific content...&lt;/p&gt;\n        &lt;/section&gt;\n        \"\"\"\n        html = html.replace(\"&lt;/body&gt;\", f\"{custom_section}&lt;/body&gt;\")\n\n        return html\n</code></pre>"},{"location":"user-guide/reports/#complete-example","title":"Complete Example","text":"<pre><code>\"\"\"Generate comprehensive trade study report.\"\"\"\n\nimport pandas as pd\nfrom pathlib import Path\n\nfrom phased_array_systems.reports import HTMLReport, MarkdownReport, ReportConfig\nfrom phased_array_systems.trades import filter_feasible, extract_pareto, rank_pareto\nfrom phased_array_systems.viz import pareto_plot, scatter_matrix\n\n# Load results\nresults = pd.read_parquet(\"results.parquet\")\nprint(f\"Loaded {len(results)} cases\")\n\n# Analysis\nfeasible = filter_feasible(results)\nobjectives = [(\"cost_usd\", \"minimize\"), (\"eirp_dbw\", \"maximize\")]\npareto = extract_pareto(feasible, objectives)\nranked = rank_pareto(pareto, objectives)\n\nprint(f\"Feasible: {len(feasible)} ({len(feasible)/len(results)*100:.1f}%)\")\nprint(f\"Pareto-optimal: {len(pareto)}\")\n\n# Create output directory\noutput_dir = Path(\"./report\")\noutput_dir.mkdir(exist_ok=True)\n\n# Generate figures\nfig1 = pareto_plot(\n    results, x=\"cost_usd\", y=\"eirp_dbw\",\n    pareto_front=pareto,\n    feasible_mask=results[\"verification.passes\"] == 1.0,\n    title=\"Cost vs EIRP Trade Space\",\n)\nfig1.savefig(output_dir / \"pareto.png\", dpi=150, bbox_inches=\"tight\")\n\nfig2 = scatter_matrix(\n    feasible,\n    columns=[\"cost_usd\", \"eirp_dbw\", \"link_margin_db\"],\n    title=\"Key Metrics Correlation\",\n)\nfig2.savefig(output_dir / \"scatter.png\", dpi=150, bbox_inches=\"tight\")\n\n# Generate HTML report\nconfig = ReportConfig(\n    title=\"Communications Array Trade Study\",\n    description=\"Systematic exploration of array configurations for X-band link\",\n    author=\"Engineering Team\",\n    version=\"1.0\",\n)\n\nhtml_report = HTMLReport(config)\nhtml_content = html_report.generate(results)\nhtml_report.save(html_content, output_dir / \"report.html\")\nprint(f\"HTML report: {output_dir / 'report.html'}\")\n\n# Generate Markdown report\nmd_report = MarkdownReport(config)\nmd_content = md_report.generate(results)\nmd_report.save(md_content, output_dir / \"report.md\")\nprint(f\"Markdown report: {output_dir / 'report.md'}\")\n\n# Export supporting data\nfrom phased_array_systems.io import export_results\nexport_results(ranked, output_dir / \"pareto_ranked.csv\", format=\"csv\")\nprint(f\"Pareto data: {output_dir / 'pareto_ranked.csv'}\")\n</code></pre>"},{"location":"user-guide/reports/#report-template-structure","title":"Report Template Structure","text":""},{"location":"user-guide/reports/#html-report-structure","title":"HTML Report Structure","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{title}&lt;/title&gt;\n    &lt;style&gt;/* Embedded CSS */&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;header&gt;\n        &lt;h1&gt;{title}&lt;/h1&gt;\n        &lt;p&gt;{description}&lt;/p&gt;\n        &lt;p&gt;Generated: {timestamp}&lt;/p&gt;\n    &lt;/header&gt;\n\n    &lt;section id=\"summary\"&gt;\n        &lt;h2&gt;Executive Summary&lt;/h2&gt;\n        &lt;!-- Statistics --&gt;\n    &lt;/section&gt;\n\n    &lt;section id=\"requirements\"&gt;\n        &lt;h2&gt;Requirements Verification&lt;/h2&gt;\n        &lt;!-- Pass/fail table --&gt;\n    &lt;/section&gt;\n\n    &lt;section id=\"pareto\"&gt;\n        &lt;h2&gt;Pareto Analysis&lt;/h2&gt;\n        &lt;!-- Top designs --&gt;\n    &lt;/section&gt;\n\n    &lt;section id=\"statistics\"&gt;\n        &lt;h2&gt;Design Statistics&lt;/h2&gt;\n        &lt;!-- Metric tables --&gt;\n    &lt;/section&gt;\n\n    &lt;footer&gt;\n        &lt;p&gt;Generated by phased-array-systems v{version}&lt;/p&gt;\n    &lt;/footer&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"user-guide/reports/#markdown-report-structure","title":"Markdown Report Structure","text":"<pre><code># {title}\n\n{description}\n\nGenerated: {timestamp}\n\n## Executive Summary\n\n- Total cases: X\n- Feasible: Y (Z%)\n- Pareto-optimal: W\n\n## Requirements Verification\n\n| ID | Name | Pass Rate |\n|----|------|-----------|\n| ... | ... | ... |\n\n## Top Designs\n\n| Rank | Case ID | Cost | EIRP | Margin |\n|------|---------|------|------|--------|\n| ... | ... | ... | ... | ... |\n\n## Statistics\n\n...\n\n---\n*Generated by phased-array-systems*\n</code></pre>"},{"location":"user-guide/reports/#integration-with-notebooks","title":"Integration with Notebooks","text":"<p>Generate reports within Jupyter notebooks:</p> <pre><code>from IPython.display import HTML, Markdown\n\n# Display HTML inline\nhtml_content = html_report.generate(results)\nHTML(html_content)\n\n# Display Markdown inline\nmd_content = md_report.generate(results)\nMarkdown(md_content)\n</code></pre>"},{"location":"user-guide/reports/#tips","title":"Tips","text":""},{"location":"user-guide/reports/#1-include-context","title":"1. Include Context","text":"<p>Add description explaining the study:</p> <pre><code>config = ReportConfig(\n    title=\"Phase 2 Array Trade Study\",\n    description=\"\"\"\n    Analysis of 8x8 to 32x32 array configurations for 100 km X-band link.\n    Objectives: Minimize cost while meeting 35 dBW EIRP requirement.\n    \"\"\",\n)\n</code></pre>"},{"location":"user-guide/reports/#2-version-reports","title":"2. Version Reports","text":"<p>Track report versions:</p> <pre><code>config = ReportConfig(\n    title=\"Trade Study\",\n    version=\"1.2\",  # Update when study changes\n)\n</code></pre>"},{"location":"user-guide/reports/#3-archive-with-data","title":"3. Archive with Data","text":"<p>Keep reports with their source data:</p> <pre><code>results/\n\u251c\u2500\u2500 study_001/\n\u2502   \u251c\u2500\u2500 results.parquet\n\u2502   \u251c\u2500\u2500 pareto.csv\n\u2502   \u251c\u2500\u2500 report.html\n\u2502   \u2514\u2500\u2500 figures/\n\u2502       \u251c\u2500\u2500 pareto.png\n\u2502       \u2514\u2500\u2500 scatter.png\n</code></pre>"},{"location":"user-guide/reports/#see-also","title":"See Also","text":"<ul> <li>Trade Studies - Generate results</li> <li>Visualization - Create figures</li> <li>CLI Reference - Command-line usage</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"user-guide/requirements/","title":"Requirements","text":"<p>Requirements are first-class objects in phased-array-systems, enabling systematic tracking of design compliance with automatic verification and margin calculation.</p>"},{"location":"user-guide/requirements/#overview","title":"Overview","text":"<p>The requirements system provides:</p> <ul> <li>Definition: Specify requirements with thresholds and operators</li> <li>Verification: Automatic pass/fail checking against metrics</li> <li>Margins: Quantify how much margin exists (positive or negative)</li> <li>Traceability: Link results back to requirement IDs</li> </ul>"},{"location":"user-guide/requirements/#defining-requirements","title":"Defining Requirements","text":""},{"location":"user-guide/requirements/#single-requirement","title":"Single Requirement","text":"<pre><code>from phased_array_systems.requirements import Requirement\n\nreq = Requirement(\n    id=\"REQ-001\",           # Unique identifier\n    name=\"Minimum EIRP\",     # Human-readable name\n    metric_key=\"eirp_dbw\",   # Key in metrics dictionary\n    op=\"&gt;=\",                 # Comparison operator\n    value=40.0,              # Threshold value\n    units=\"dBW\",             # Optional units (documentation)\n    severity=\"must\",         # Importance level\n)\n</code></pre>"},{"location":"user-guide/requirements/#parameters","title":"Parameters","text":"Parameter Type Required Description <code>id</code> str Yes Unique identifier (e.g., \"REQ-001\") <code>name</code> str Yes Human-readable description <code>metric_key</code> str Yes Key to check in metrics dict <code>op</code> str Yes Comparison operator <code>value</code> float Yes Threshold value <code>units</code> str No Units for documentation <code>severity</code> str No \"must\", \"should\", or \"nice\""},{"location":"user-guide/requirements/#operators","title":"Operators","text":"Operator Meaning Passes When <code>&gt;=</code> Greater or equal metric &gt;= value <code>&lt;=</code> Less or equal metric &lt;= value <code>&gt;</code> Greater than metric &gt; value <code>&lt;</code> Less than metric &lt; value <code>==</code> Equal to metric == value"},{"location":"user-guide/requirements/#severity-levels","title":"Severity Levels","text":"Level Meaning Verification Impact <code>\"must\"</code> Mandatory Fails overall if not met <code>\"should\"</code> Desired Tracked but doesn't fail <code>\"nice\"</code> Optional Tracked but doesn't fail"},{"location":"user-guide/requirements/#requirementset","title":"RequirementSet","text":"<p>Group requirements together for verification:</p> <pre><code>from phased_array_systems.requirements import RequirementSet\n\nrequirements = RequirementSet(\n    requirements=[\n        Requirement(\"REQ-001\", \"Min EIRP\", \"eirp_dbw\", \"&gt;=\", 40.0, severity=\"must\"),\n        Requirement(\"REQ-002\", \"Positive Margin\", \"link_margin_db\", \"&gt;=\", 0.0, severity=\"must\"),\n        Requirement(\"REQ-003\", \"Max Cost\", \"cost_usd\", \"&lt;=\", 50000.0, severity=\"must\"),\n        Requirement(\"REQ-004\", \"Target EIRP\", \"eirp_dbw\", \"&gt;=\", 45.0, severity=\"should\"),\n    ],\n    name=\"Communications Requirements\",\n)\n</code></pre>"},{"location":"user-guide/requirements/#verification","title":"Verification","text":""},{"location":"user-guide/requirements/#basic-verification","title":"Basic Verification","text":"<pre><code>from phased_array_systems.evaluate import evaluate_case\n\n# Evaluate design\nmetrics = evaluate_case(arch, scenario)\n\n# Verify requirements\nreport = requirements.verify(metrics)\n\n# Check overall status\nprint(f\"Overall: {'PASS' if report.passes else 'FAIL'}\")\n</code></pre>"},{"location":"user-guide/requirements/#verificationreport","title":"VerificationReport","text":"<p>The <code>verify()</code> method returns a <code>VerificationReport</code>:</p> <pre><code>report = requirements.verify(metrics)\n\n# Summary counts\nprint(f\"Must: {report.must_pass_count}/{report.must_total_count}\")\nprint(f\"Should: {report.should_pass_count}/{report.should_total_count}\")\n\n# Failed requirement IDs\nif report.failed_ids:\n    print(f\"Failed: {report.failed_ids}\")\n\n# Individual results\nfor result in report.results:\n    status = \"PASS\" if result.passes else \"FAIL\"\n    print(f\"{result.requirement.id}: {status}\")\n    print(f\"  Actual: {result.actual_value:.2f}\")\n    print(f\"  Threshold: {result.requirement.value:.2f}\")\n    print(f\"  Margin: {result.margin:.2f}\")\n</code></pre>"},{"location":"user-guide/requirements/#margin-calculation","title":"Margin Calculation","text":"<p>Margins indicate how much room exists:</p> <ul> <li>Positive margin: Requirement is satisfied with room to spare</li> <li>Zero margin: Exactly at threshold</li> <li>Negative margin: Requirement is not met</li> </ul> <p>For different operators:</p> Operator Margin Formula <code>&gt;=</code>, <code>&gt;</code> actual - threshold <code>&lt;=</code>, <code>&lt;</code> threshold - actual <code>==</code> -abs(actual - threshold) <pre><code># Example: EIRP &gt;= 40 dBW with actual = 45 dBW\n# Margin = 45 - 40 = 5 dB (passes with 5 dB margin)\n\n# Example: Cost &lt;= 50000 with actual = 45000\n# Margin = 50000 - 45000 = 5000 (passes with $5k margin)\n</code></pre>"},{"location":"user-guide/requirements/#integration-with-batch-evaluation","title":"Integration with Batch Evaluation","text":"<p>Requirements integrate with the trade study workflow:</p> <pre><code>from phased_array_systems.trades import BatchRunner, filter_feasible\n\n# Create runner with requirements\nrunner = BatchRunner(scenario, requirements)\n\n# Run batch - results include verification columns\nresults = runner.run(doe)\n\n# Results DataFrame includes:\n# - verification.passes (1.0 or 0.0)\n# - verification.must_pass_count\n# - verification.must_total_count\n# - verification.margin_* for each requirement\n\n# Filter to feasible only\nfeasible = filter_feasible(results, requirements)\n</code></pre>"},{"location":"user-guide/requirements/#verification-columns","title":"Verification Columns","text":"<p>After batch evaluation, the results DataFrame includes:</p> Column Description <code>verification.passes</code> 1.0 if all must requirements pass <code>verification.must_pass_count</code> Number of must requirements passed <code>verification.must_total_count</code> Total must requirements <code>verification.should_pass_count</code> Should requirements passed <code>verification.should_total_count</code> Total should requirements"},{"location":"user-guide/requirements/#common-requirement-patterns","title":"Common Requirement Patterns","text":""},{"location":"user-guide/requirements/#communications-link","title":"Communications Link","text":"<pre><code>comms_requirements = RequirementSet(requirements=[\n    # Performance\n    Requirement(\"LINK-001\", \"Min EIRP\", \"eirp_dbw\", \"&gt;=\", 40.0, severity=\"must\"),\n    Requirement(\"LINK-002\", \"Positive Margin\", \"link_margin_db\", \"&gt;=\", 0.0, severity=\"must\"),\n    Requirement(\"LINK-003\", \"3dB Margin\", \"link_margin_db\", \"&gt;=\", 3.0, severity=\"should\"),\n\n    # SWaP-C\n    Requirement(\"SWAP-001\", \"Max Cost\", \"cost_usd\", \"&lt;=\", 100000.0, severity=\"must\"),\n    Requirement(\"SWAP-002\", \"Max Power\", \"prime_power_w\", \"&lt;=\", 1000.0, severity=\"must\"),\n\n    # Antenna\n    Requirement(\"ANT-001\", \"Min Gain\", \"g_peak_db\", \"&gt;=\", 25.0, severity=\"should\"),\n])\n</code></pre>"},{"location":"user-guide/requirements/#radar-detection","title":"Radar Detection","text":"<pre><code>radar_requirements = RequirementSet(requirements=[\n    # Detection\n    Requirement(\"DET-001\", \"Positive SNR Margin\", \"snr_margin_db\", \"&gt;=\", 0.0, severity=\"must\"),\n    Requirement(\"DET-002\", \"5dB SNR Margin\", \"snr_margin_db\", \"&gt;=\", 5.0, severity=\"should\"),\n\n    # Range\n    Requirement(\"RNG-001\", \"Min Range\", \"detection_range_m\", \"&gt;=\", 100e3, severity=\"must\"),\n\n    # SWaP-C\n    Requirement(\"SWAP-001\", \"Max Cost\", \"cost_usd\", \"&lt;=\", 500000.0, severity=\"must\"),\n])\n</code></pre>"},{"location":"user-guide/requirements/#yaml-configuration","title":"YAML Configuration","text":"<p>Requirements can be defined in YAML:</p> <pre><code>requirements:\n  - id: REQ-001\n    name: Minimum EIRP\n    metric_key: eirp_dbw\n    op: \"&gt;=\"\n    value: 40.0\n    units: dBW\n    severity: must\n\n  - id: REQ-002\n    name: Positive Link Margin\n    metric_key: link_margin_db\n    op: \"&gt;=\"\n    value: 0.0\n    units: dB\n    severity: must\n\n  - id: REQ-003\n    name: Maximum Cost\n    metric_key: cost_usd\n    op: \"&lt;=\"\n    value: 50000.0\n    units: USD\n    severity: must\n</code></pre> <p>Load with:</p> <pre><code>from phased_array_systems.io import load_config\n\nconfig = load_config(\"config.yaml\")\nrequirements = config.get_requirement_set()\n</code></pre>"},{"location":"user-guide/requirements/#serialization","title":"Serialization","text":""},{"location":"user-guide/requirements/#to-dictionary","title":"To Dictionary","text":"<pre><code>report = requirements.verify(metrics)\nreport_dict = report.to_dict()\n\n# Contains:\n# {\n#     \"passes\": True,\n#     \"failed_ids\": [],\n#     \"must_pass_count\": 3,\n#     \"must_total_count\": 3,\n#     \"results\": [\n#         {\n#             \"id\": \"REQ-001\",\n#             \"name\": \"Minimum EIRP\",\n#             \"metric_key\": \"eirp_dbw\",\n#             \"threshold\": 40.0,\n#             \"operator\": \"&gt;=\",\n#             \"actual_value\": 45.0,\n#             \"passes\": True,\n#             \"margin\": 5.0,\n#             \"severity\": \"must\",\n#         },\n#         ...\n#     ]\n# }\n</code></pre>"},{"location":"user-guide/requirements/#export-to-report","title":"Export to Report","text":"<p>The report generators include requirement verification:</p> <pre><code>from phased_array_systems.reports import HTMLReport, ReportConfig\n\nreport_gen = HTMLReport(ReportConfig(title=\"Trade Study\"))\nhtml = report_gen.generate(results)\n# Includes requirement pass/fail summary and margins\n</code></pre>"},{"location":"user-guide/requirements/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/requirements/#1-use-meaningful-ids","title":"1. Use Meaningful IDs","text":"<p>Organize IDs by category:</p> <pre><code>Requirement(\"PERF-001\", ...)  # Performance\nRequirement(\"SWAP-001\", ...)  # Size, Weight, Power, Cost\nRequirement(\"ANT-001\", ...)   # Antenna\nRequirement(\"LINK-001\", ...)  # Link budget\n</code></pre>"},{"location":"user-guide/requirements/#2-define-both-minimum-and-target","title":"2. Define Both Minimum and Target","text":"<pre><code>RequirementSet(requirements=[\n    Requirement(\"EIRP-MIN\", \"Min EIRP\", \"eirp_dbw\", \"&gt;=\", 40.0, severity=\"must\"),\n    Requirement(\"EIRP-TGT\", \"Target EIRP\", \"eirp_dbw\", \"&gt;=\", 45.0, severity=\"should\"),\n])\n</code></pre>"},{"location":"user-guide/requirements/#3-include-units-for-documentation","title":"3. Include Units for Documentation","text":"<pre><code>Requirement(\n    ...,\n    units=\"dBW\",  # Helps with report clarity\n)\n</code></pre>"},{"location":"user-guide/requirements/#4-use-severity-appropriately","title":"4. Use Severity Appropriately","text":"<ul> <li><code>\"must\"</code>: Hard constraints that must be met</li> <li><code>\"should\"</code>: Important goals but not showstoppers</li> <li><code>\"nice\"</code>: Stretch goals for optimization</li> </ul>"},{"location":"user-guide/requirements/#see-also","title":"See Also","text":"<ul> <li>Architecture Configuration - Define system parameters</li> <li>Trade Studies - Batch evaluation with requirements</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"user-guide/scenarios/","title":"Scenarios","text":"<p>Scenarios define the operating conditions for analysis. Different scenario types support different applications.</p>"},{"location":"user-guide/scenarios/#overview","title":"Overview","text":"<p>phased-array-systems supports two main scenario types:</p> Scenario Class Application Communications <code>CommsLinkScenario</code> Link budget analysis Radar <code>RadarDetectionScenario</code> Detection performance <p>All scenarios inherit from <code>ScenarioBase</code> and share common parameters.</p>"},{"location":"user-guide/scenarios/#commslinkscenario","title":"CommsLinkScenario","text":"<p>For communications link budget analysis.</p>"},{"location":"user-guide/scenarios/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>freq_hz</code> float Required Operating frequency (Hz) <code>bandwidth_hz</code> float Required Signal bandwidth (Hz) <code>range_m</code> float Required Link range (m) <code>required_snr_db</code> float Required Required SNR for demod (dB) <code>scan_angle_deg</code> float <code>0.0</code> Beam scan angle (degrees) <code>rx_antenna_gain_db</code> float <code>None</code> RX antenna gain (dB) <code>rx_noise_temp_k</code> float <code>290.0</code> RX noise temperature (K) <code>path_loss_model</code> str <code>\"fspl\"</code> Propagation model <code>atmospheric_loss_db</code> float <code>0.0</code> Atmospheric loss (dB) <code>rain_loss_db</code> float <code>0.0</code> Rain fade margin (dB) <code>polarization_loss_db</code> float <code>0.0</code> Polarization loss (dB)"},{"location":"user-guide/scenarios/#example","title":"Example","text":"<pre><code>from phased_array_systems.scenarios import CommsLinkScenario\n\n# Point-to-point terrestrial link\nscenario = CommsLinkScenario(\n    freq_hz=10e9,              # 10 GHz (X-band)\n    bandwidth_hz=10e6,         # 10 MHz\n    range_m=50e3,              # 50 km\n    required_snr_db=12.0,      # 12 dB for 16-QAM\n    scan_angle_deg=15.0,       # 15\u00b0 off boresight\n    rx_antenna_gain_db=30.0,   # 30 dBi receive antenna\n    rx_noise_temp_k=300.0,     # System noise temperature\n    atmospheric_loss_db=0.5,   # Atmospheric absorption\n    rain_loss_db=3.0,          # Rain fade margin\n)\n</code></pre>"},{"location":"user-guide/scenarios/#satellite-link-example","title":"Satellite Link Example","text":"<pre><code># Geostationary satellite downlink\ngeo_scenario = CommsLinkScenario(\n    freq_hz=12e9,              # Ku-band\n    bandwidth_hz=36e6,         # 36 MHz transponder\n    range_m=36000e3,           # GEO distance\n    required_snr_db=8.0,       # QPSK\n    scan_angle_deg=0.0,        # Boresight\n    rx_antenna_gain_db=40.0,   # Large ground station\n    rx_noise_temp_k=100.0,     # Cooled LNA\n    atmospheric_loss_db=0.3,\n    rain_loss_db=5.0,          # High rain margin\n)\n</code></pre>"},{"location":"user-guide/scenarios/#path-loss-models","title":"Path Loss Models","text":"<p>Currently supported:</p> Model Description <code>\"fspl\"</code> Free Space Path Loss <p>Free space path loss:</p> \\[ L_{FSPL} = 20 \\log_{10}(4\\pi d f / c) \\]"},{"location":"user-guide/scenarios/#extra-losses","title":"Extra Losses","text":"<p>Total extra loss is computed automatically:</p> <pre><code># Available as property\ntotal_loss = scenario.total_extra_loss_db\n# = atmospheric_loss_db + rain_loss_db + polarization_loss_db\n</code></pre>"},{"location":"user-guide/scenarios/#radardetectionscenario","title":"RadarDetectionScenario","text":"<p>For radar detection performance analysis.</p>"},{"location":"user-guide/scenarios/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>freq_hz</code> float Required Operating frequency (Hz) <code>target_rcs_m2</code> float Required Target RCS (m\u00b2) <code>range_m</code> float Required Target range (m) <code>required_pd</code> float <code>0.9</code> Required detection probability <code>pfa</code> float <code>1e-6</code> False alarm probability <code>pulse_width_s</code> float Required Pulse width (s) <code>prf_hz</code> float Required Pulse repetition frequency (Hz) <code>n_pulses</code> int <code>1</code> Pulses to integrate <code>integration_type</code> str <code>\"coherent\"</code> Integration type <code>swerling_model</code> int <code>1</code> Target fluctuation model <code>scan_angle_deg</code> float <code>0.0</code> Beam scan angle (degrees) <code>system_loss_db</code> float <code>0.0</code> System losses (dB)"},{"location":"user-guide/scenarios/#example_1","title":"Example","text":"<pre><code>from phased_array_systems.scenarios import RadarDetectionScenario\n\nscenario = RadarDetectionScenario(\n    freq_hz=10e9,              # X-band\n    target_rcs_m2=1.0,         # 1 m\u00b2 target\n    range_m=100e3,             # 100 km\n    required_pd=0.9,           # 90% detection probability\n    pfa=1e-6,                  # 10\u207b\u2076 false alarm rate\n    pulse_width_s=10e-6,       # 10 \u03bcs pulse\n    prf_hz=1000,               # 1 kHz PRF\n    n_pulses=10,               # Integrate 10 pulses\n    integration_type=\"coherent\",\n    swerling_model=1,          # Swerling 1 target\n)\n</code></pre>"},{"location":"user-guide/scenarios/#swerling-models","title":"Swerling Models","text":"Model Description Target Type 0 Non-fluctuating Steady target 1 Scan-to-scan decorrelation Many scatterers, slow 2 Pulse-to-pulse decorrelation Many scatterers, fast 3 Scan-to-scan, dominant scatterer Large + small, slow 4 Pulse-to-pulse, dominant scatterer Large + small, fast"},{"location":"user-guide/scenarios/#integration-types","title":"Integration Types","text":"Type Description Gain <code>\"coherent\"</code> Phase-coherent integration \\(N\\) (linear) <code>\"noncoherent\"</code> Magnitude-only integration \\(\\sqrt{N}\\) (approx)"},{"location":"user-guide/scenarios/#scenariobase","title":"ScenarioBase","text":"<p>Both scenario types inherit common parameters:</p>"},{"location":"user-guide/scenarios/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>freq_hz</code> float Required Operating frequency (Hz) <code>name</code> str <code>None</code> Optional scenario name"},{"location":"user-guide/scenarios/#properties","title":"Properties","text":"Property Returns Description <code>wavelength_m</code> float Wavelength (c/f) <pre><code>scenario = CommsLinkScenario(freq_hz=10e9, ...)\nprint(f\"Wavelength: {scenario.wavelength_m * 100:.2f} cm\")  # 3.00 cm\n</code></pre>"},{"location":"user-guide/scenarios/#typical-parameter-values","title":"Typical Parameter Values","text":""},{"location":"user-guide/scenarios/#frequency-bands","title":"Frequency Bands","text":"Band Frequency Typical Use L 1-2 GHz Long-range radar, satcom S 2-4 GHz Weather radar, ATC C 4-8 GHz Satcom, weather X 8-12 GHz Military radar, satcom Ku 12-18 GHz DBS, satcom Ka 26-40 GHz High-throughput satcom"},{"location":"user-guide/scenarios/#required-snr-by-modulation","title":"Required SNR by Modulation","text":"Modulation Typical SNR BPSK 6-10 dB QPSK 8-12 dB 8PSK 12-15 dB 16-QAM 14-18 dB 64-QAM 20-24 dB"},{"location":"user-guide/scenarios/#typical-detection-requirements","title":"Typical Detection Requirements","text":"Application Pd Pfa Air traffic control 0.95 10\u207b\u2077 Weather radar 0.9 10\u207b\u2076 Military search 0.8-0.9 10\u207b\u2076 Tracking 0.99 10\u207b\u2074"},{"location":"user-guide/scenarios/#yaml-configuration","title":"YAML Configuration","text":"<p>Scenarios can be defined in YAML:</p> <pre><code># Communications scenario\nscenario:\n  type: comms\n  freq_hz: 10.0e9\n  bandwidth_hz: 10.0e6\n  range_m: 100.0e3\n  required_snr_db: 10.0\n  scan_angle_deg: 0.0\n  rx_noise_temp_k: 290.0\n  atmospheric_loss_db: 0.5\n</code></pre> <pre><code># Radar scenario\nscenario:\n  type: radar\n  freq_hz: 10.0e9\n  target_rcs_m2: 1.0\n  range_m: 100.0e3\n  required_pd: 0.9\n  pfa: 1.0e-6\n  pulse_width_s: 10.0e-6\n  prf_hz: 1000\n  n_pulses: 10\n  swerling_model: 1\n</code></pre> <p>Load with:</p> <pre><code>from phased_array_systems.io import load_config\n\nconfig = load_config(\"config.yaml\")\nscenario = config.get_scenario()\n</code></pre>"},{"location":"user-guide/scenarios/#scenario-selection-guide","title":"Scenario Selection Guide","text":"<pre><code>graph TD\n    A[Application?] --&gt; B{Type}\n    B --&gt;|Communications| C[CommsLinkScenario]\n    B --&gt;|Radar| D[RadarDetectionScenario]\n    C --&gt; E[Point-to-Point?]\n    E --&gt;|Yes| F[Set range_m, rx_antenna_gain_db]\n    E --&gt;|No| G[Satellite?]\n    G --&gt;|Yes| H[Large range_m, set atmospheric/rain losses]\n    D --&gt; I[Set target_rcs_m2]\n    I --&gt; J[Set detection requirements]\n    J --&gt; K[Choose Swerling model]</code></pre>"},{"location":"user-guide/scenarios/#see-also","title":"See Also","text":"<ul> <li>Link Budget Modeling - Communications link analysis</li> <li>Radar Detection - Radar performance analysis</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"user-guide/trade-studies/","title":"Trade Studies","text":"<p>Trade studies enable systematic exploration of design alternatives using Design of Experiments (DOE) and batch evaluation.</p>"},{"location":"user-guide/trade-studies/#overview","title":"Overview","text":"<p>The trade study workflow:</p> <pre><code>graph LR\n    A[Define DesignSpace] --&gt; B[Generate DOE]\n    B --&gt; C[BatchRunner.run]\n    C --&gt; D[filter_feasible]\n    D --&gt; E[extract_pareto]\n    E --&gt; F[rank_pareto]\n    F --&gt; G[Visualize]</code></pre>"},{"location":"user-guide/trade-studies/#design-space","title":"Design Space","text":"<p>A <code>DesignSpace</code> defines which parameters can vary and their bounds.</p>"},{"location":"user-guide/trade-studies/#creating-a-design-space","title":"Creating a Design Space","text":"<pre><code>from phased_array_systems.trades import DesignSpace\n\nspace = DesignSpace(name=\"My Trade Study\")\n\n# Add variables using fluent interface\nspace = (\n    DesignSpace(name=\"Array Trade Study\")\n    .add_variable(\"array.nx\", type=\"int\", low=4, high=16)\n    .add_variable(\"array.ny\", type=\"int\", low=4, high=16)\n    .add_variable(\"rf.tx_power_w_per_elem\", type=\"float\", low=0.5, high=3.0)\n    .add_variable(\"array.geometry\", type=\"categorical\", values=[\"rectangular\"])\n)\n</code></pre>"},{"location":"user-guide/trade-studies/#variable-types","title":"Variable Types","text":"Type Parameters Description <code>int</code> <code>low</code>, <code>high</code> Discrete integers <code>float</code> <code>low</code>, <code>high</code> Continuous values <code>categorical</code> <code>values</code> Enumerated options"},{"location":"user-guide/trade-studies/#fixed-parameters","title":"Fixed Parameters","text":"<p>Set <code>low=high</code> to fix a parameter:</p> <pre><code>space.add_variable(\"array.dx_lambda\", type=\"float\", low=0.5, high=0.5)  # Fixed at 0.5\n</code></pre> <p>Or use categorical with single value:</p> <pre><code>space.add_variable(\"array.geometry\", type=\"categorical\", values=[\"rectangular\"])\n</code></pre>"},{"location":"user-guide/trade-studies/#complete-design-space-example","title":"Complete Design Space Example","text":"<pre><code>space = (\n    DesignSpace(name=\"Comms Array Trade\")\n    # Variable parameters\n    .add_variable(\"array.nx\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"array.ny\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"rf.tx_power_w_per_elem\", type=\"float\", low=0.5, high=3.0)\n    .add_variable(\"rf.pa_efficiency\", type=\"float\", low=0.2, high=0.5)\n    .add_variable(\"cost.cost_per_elem_usd\", type=\"float\", low=75.0, high=150.0)\n    # Fixed parameters\n    .add_variable(\"array.geometry\", type=\"categorical\", values=[\"rectangular\"])\n    .add_variable(\"array.dx_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.dy_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.enforce_subarray_constraint\", type=\"categorical\", values=[True])\n    .add_variable(\"rf.noise_figure_db\", type=\"float\", low=3.0, high=3.0)\n    .add_variable(\"rf.feed_loss_db\", type=\"float\", low=1.0, high=1.0)\n    .add_variable(\"cost.nre_usd\", type=\"float\", low=10000.0, high=10000.0)\n)\n\nprint(f\"Design space: {space.n_dims} dimensions\")\n</code></pre>"},{"location":"user-guide/trade-studies/#doe-generation","title":"DOE Generation","text":"<p>Generate cases using various sampling methods.</p>"},{"location":"user-guide/trade-studies/#sampling-methods","title":"Sampling Methods","text":"Method Description Best For <code>lhs</code> Latin Hypercube Sampling General exploration, space-filling <code>random</code> Uniform random Quick exploration <code>grid</code> Full factorial Small design spaces, complete coverage"},{"location":"user-guide/trade-studies/#latin-hypercube-sampling-lhs","title":"Latin Hypercube Sampling (LHS)","text":"<p>Default and recommended for most studies:</p> <pre><code>from phased_array_systems.trades import generate_doe\n\ndoe = generate_doe(\n    space,\n    method=\"lhs\",\n    n_samples=100,\n    seed=42,  # For reproducibility\n)\n\nprint(f\"Generated {len(doe)} cases\")\nprint(doe.head())\n</code></pre> <p>LHS properties:</p> <ul> <li>Space-filling: samples spread across all dimensions</li> <li>Efficient: good coverage with fewer samples than grid</li> <li>Reproducible with seed</li> </ul>"},{"location":"user-guide/trade-studies/#random-sampling","title":"Random Sampling","text":"<pre><code>doe = generate_doe(space, method=\"random\", n_samples=100, seed=42)\n</code></pre>"},{"location":"user-guide/trade-studies/#grid-sampling","title":"Grid Sampling","text":"<p>Full factorial grid (use with small design spaces):</p> <pre><code># Grid with default levels\ndoe = generate_doe(space, method=\"grid\")\n\n# Grid with custom levels\ndoe = generate_doe(space, method=\"grid\", grid_levels=5)\n</code></pre> <p>Grid Size</p> <p>Grid size grows exponentially: 5 variables \u00d7 5 levels = 3,125 cases.</p>"},{"location":"user-guide/trade-studies/#quick-doe-from-dictionary","title":"Quick DOE from Dictionary","text":"<p>For simple cases:</p> <pre><code>from phased_array_systems.trades import generate_doe_from_dict\n\ndoe = generate_doe_from_dict(\n    {\n        \"array.nx\": (4, 16, \"int\"),\n        \"array.ny\": (4, 16, \"int\"),\n        \"rf.tx_power_w_per_elem\": (0.5, 3.0),  # float implied\n        \"array.geometry\": [\"rectangular\", \"triangular\"],  # categorical\n    },\n    n_samples=50,\n    seed=42,\n)\n</code></pre>"},{"location":"user-guide/trade-studies/#batch-evaluation","title":"Batch Evaluation","text":"<p>Run all DOE cases with <code>BatchRunner</code>.</p>"},{"location":"user-guide/trade-studies/#basic-usage","title":"Basic Usage","text":"<pre><code>from phased_array_systems.trades import BatchRunner\n\nrunner = BatchRunner(scenario)\nresults = runner.run(doe)\n\nprint(f\"Completed {len(results)} cases\")\nprint(f\"Columns: {list(results.columns)}\")\n</code></pre>"},{"location":"user-guide/trade-studies/#with-requirements","title":"With Requirements","text":"<pre><code>from phased_array_systems.requirements import RequirementSet\n\nrunner = BatchRunner(scenario, requirements)\nresults = runner.run(doe)\n\n# Results include verification columns\nprint(f\"Feasible: {(results['verification.passes'] == 1.0).sum()}\")\n</code></pre>"},{"location":"user-guide/trade-studies/#progress-callback","title":"Progress Callback","text":"<pre><code>def progress(completed, total):\n    pct = completed / total * 100\n    if completed % 10 == 0:\n        print(f\"Progress: {completed}/{total} ({pct:.0f}%)\")\n\nresults = runner.run(doe, progress_callback=progress)\n</code></pre>"},{"location":"user-guide/trade-studies/#parallel-evaluation","title":"Parallel Evaluation","text":"<pre><code># Use multiple workers\nresults = runner.run(doe, n_workers=4)\n</code></pre> <p>Worker Count</p> <p>Set <code>n_workers</code> based on CPU cores. Default is 1 (sequential).</p>"},{"location":"user-guide/trade-studies/#results-dataframe","title":"Results DataFrame","text":"<p>The results DataFrame includes:</p> Category Example Columns Case ID <code>case_id</code> Architecture <code>array.nx</code>, <code>array.ny</code>, <code>rf.tx_power_w_per_elem</code> Performance <code>eirp_dbw</code>, <code>link_margin_db</code>, <code>cost_usd</code> Verification <code>verification.passes</code>, <code>verification.must_pass_count</code> Metadata <code>meta.runtime_s</code>, <code>meta.error</code>"},{"location":"user-guide/trade-studies/#filtering-results","title":"Filtering Results","text":""},{"location":"user-guide/trade-studies/#filter-feasible","title":"Filter Feasible","text":"<pre><code>from phased_array_systems.trades import filter_feasible\n\n# Using requirements\nfeasible = filter_feasible(results, requirements)\n\n# Using verification column\nfeasible = filter_feasible(results)  # Uses verification.passes column\n</code></pre>"},{"location":"user-guide/trade-studies/#manual-filtering","title":"Manual Filtering","text":"<pre><code># Filter by specific criteria\ngood_designs = results[\n    (results[\"link_margin_db\"] &gt; 3.0) &amp;\n    (results[\"cost_usd\"] &lt; 50000)\n]\n</code></pre>"},{"location":"user-guide/trade-studies/#augmenting-doe","title":"Augmenting DOE","text":"<p>Add more samples to an existing study:</p> <pre><code>from phased_array_systems.trades import augment_doe\n\n# Add 50 more samples\nexpanded_doe = augment_doe(\n    existing_doe=doe,\n    design_space=space,\n    n_additional=50,\n    method=\"lhs\",\n    seed=43,  # Different seed\n)\n\n# Run new cases only\nnew_cases = expanded_doe[~expanded_doe[\"case_id\"].isin(doe[\"case_id\"])]\nnew_results = runner.run(new_cases)\n\n# Combine results\nall_results = pd.concat([results, new_results], ignore_index=True)\n</code></pre>"},{"location":"user-guide/trade-studies/#case-ids","title":"Case IDs","text":"<p>Each case gets a unique ID for tracking:</p> <pre><code>print(doe[\"case_id\"].head())\n# case_00000\n# case_00001\n# case_00002\n# ...\n</code></pre> <p>IDs are stable with the same seed, enabling reproducibility.</p>"},{"location":"user-guide/trade-studies/#error-handling","title":"Error Handling","text":"<p>Batch evaluation handles errors gracefully:</p> <pre><code># Check for errors\nerrors = results[results[\"meta.error\"].notna()]\nprint(f\"Cases with errors: {len(errors)}\")\n\n# View error messages\nfor _, row in errors.iterrows():\n    print(f\"{row['case_id']}: {row['meta.error']}\")\n</code></pre> <p>Errors don't stop the batch - other cases continue.</p>"},{"location":"user-guide/trade-studies/#exporting-results","title":"Exporting Results","text":"<pre><code>from phased_array_systems.io import export_results\n\n# Parquet (recommended for large datasets)\nexport_results(results, \"results.parquet\")\n\n# CSV\nexport_results(results, \"results.csv\", format=\"csv\")\n</code></pre>"},{"location":"user-guide/trade-studies/#complete-example","title":"Complete Example","text":"<pre><code>\"\"\"Complete trade study workflow.\"\"\"\n\nfrom phased_array_systems.scenarios import CommsLinkScenario\nfrom phased_array_systems.requirements import Requirement, RequirementSet\nfrom phased_array_systems.trades import (\n    DesignSpace, generate_doe, BatchRunner,\n    filter_feasible, extract_pareto, rank_pareto,\n)\nfrom phased_array_systems.viz import pareto_plot\nfrom phased_array_systems.io import export_results\n\n# 1. Define scenario\nscenario = CommsLinkScenario(\n    freq_hz=10e9,\n    bandwidth_hz=10e6,\n    range_m=100e3,\n    required_snr_db=10.0,\n)\n\n# 2. Define requirements\nrequirements = RequirementSet(requirements=[\n    Requirement(\"REQ-001\", \"Min EIRP\", \"eirp_dbw\", \"&gt;=\", 35.0, severity=\"must\"),\n    Requirement(\"REQ-002\", \"Positive Margin\", \"link_margin_db\", \"&gt;=\", 0.0, severity=\"must\"),\n    Requirement(\"REQ-003\", \"Max Cost\", \"cost_usd\", \"&lt;=\", 100000.0, severity=\"must\"),\n])\n\n# 3. Define design space\nspace = (\n    DesignSpace(name=\"Comms Trade\")\n    .add_variable(\"array.nx\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"array.ny\", type=\"categorical\", values=[4, 8, 16])\n    .add_variable(\"rf.tx_power_w_per_elem\", type=\"float\", low=0.5, high=3.0)\n    .add_variable(\"cost.cost_per_elem_usd\", type=\"float\", low=75.0, high=150.0)\n    # Fixed parameters...\n    .add_variable(\"array.geometry\", type=\"categorical\", values=[\"rectangular\"])\n    .add_variable(\"array.dx_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.dy_lambda\", type=\"float\", low=0.5, high=0.5)\n    .add_variable(\"array.enforce_subarray_constraint\", type=\"categorical\", values=[True])\n    .add_variable(\"rf.pa_efficiency\", type=\"float\", low=0.3, high=0.3)\n    .add_variable(\"rf.noise_figure_db\", type=\"float\", low=3.0, high=3.0)\n    .add_variable(\"cost.nre_usd\", type=\"float\", low=10000.0, high=10000.0)\n)\n\n# 4. Generate DOE\ndoe = generate_doe(space, method=\"lhs\", n_samples=100, seed=42)\nprint(f\"Generated {len(doe)} cases\")\n\n# 5. Run batch evaluation\nrunner = BatchRunner(scenario, requirements)\nresults = runner.run(doe, n_workers=1)\nprint(f\"Completed {len(results)} cases\")\n\n# 6. Filter feasible\nfeasible = filter_feasible(results, requirements)\nprint(f\"Feasible: {len(feasible)} ({len(feasible)/len(results)*100:.1f}%)\")\n\n# 7. Extract Pareto frontier\npareto = extract_pareto(feasible, [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n])\nprint(f\"Pareto-optimal: {len(pareto)}\")\n\n# 8. Rank Pareto designs\nranked = rank_pareto(pareto, [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n], weights=[0.5, 0.5])\n\n# 9. Show top designs\nprint(\"\\nTop 5 designs:\")\nfor _, row in ranked.head(5).iterrows():\n    print(f\"  {row['case_id']}: ${row['cost_usd']:,.0f}, {row['eirp_dbw']:.1f} dBW\")\n\n# 10. Visualize\nfig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    pareto_front=pareto,\n    feasible_mask=results[\"verification.passes\"] == 1.0,\n)\nfig.savefig(\"pareto.png\", dpi=150)\n\n# 11. Export\nexport_results(results, \"results.parquet\")\nexport_results(ranked, \"pareto.csv\", format=\"csv\")\n</code></pre>"},{"location":"user-guide/trade-studies/#see-also","title":"See Also","text":"<ul> <li>Pareto Analysis - Multi-objective optimization</li> <li>Visualization - Plotting trade-offs</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"user-guide/visualization/","title":"Visualization","text":"<p>phased-array-systems provides plotting functions for trade study visualization using matplotlib.</p>"},{"location":"user-guide/visualization/#overview","title":"Overview","text":"<p>Available plot types:</p> Function Description <code>pareto_plot</code> 2D trade-off with Pareto frontier <code>scatter_matrix</code> Pairwise relationships <code>trade_space_plot</code> 3D trade space <code>save_figure</code> Export to file"},{"location":"user-guide/visualization/#pareto-plot","title":"Pareto Plot","text":"<p>Visualize trade-offs between two objectives with Pareto frontier highlighted.</p>"},{"location":"user-guide/visualization/#basic-usage","title":"Basic Usage","text":"<pre><code>from phased_array_systems.viz import pareto_plot\n\nfig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n)\nfig.savefig(\"pareto.png\", dpi=150)\n</code></pre>"},{"location":"user-guide/visualization/#with-pareto-frontier","title":"With Pareto Frontier","text":"<pre><code>from phased_array_systems.trades import extract_pareto\n\npareto = extract_pareto(results, [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n])\n\nfig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    pareto_front=pareto,\n)\n</code></pre>"},{"location":"user-guide/visualization/#with-feasibility","title":"With Feasibility","text":"<pre><code># Create feasibility mask\nfeasible_mask = results[\"verification.passes\"] == 1.0\n\nfig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    pareto_front=pareto,\n    feasible_mask=feasible_mask,  # Infeasible shown as gray X\n)\n</code></pre>"},{"location":"user-guide/visualization/#with-color-mapping","title":"With Color Mapping","text":"<pre><code>fig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    pareto_front=pareto,\n    color_by=\"link_margin_db\",  # Color by a third metric\n)\n</code></pre>"},{"location":"user-guide/visualization/#with-size-mapping","title":"With Size Mapping","text":"<pre><code>fig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    size_by=\"n_elements\",  # Size by element count\n)\n</code></pre>"},{"location":"user-guide/visualization/#full-options","title":"Full Options","text":"<pre><code>fig = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    pareto_front=pareto,\n    feasible_mask=feasible_mask,\n    color_by=\"link_margin_db\",\n    size_by=\"n_elements\",\n    ax=None,                     # Use existing axes\n    title=\"Cost vs EIRP Trade Space\",\n    x_label=\"Total Cost (USD)\",\n    y_label=\"EIRP (dBW)\",\n    show_pareto_line=True,       # Connect Pareto points\n    figsize=(10, 8),\n)\n</code></pre>"},{"location":"user-guide/visualization/#parameters","title":"Parameters","text":"Parameter Type Description <code>results</code> DataFrame Evaluation results <code>x</code> str Column for x-axis <code>y</code> str Column for y-axis <code>pareto_front</code> DataFrame Pareto-optimal points <code>feasible_mask</code> Series Boolean mask for feasibility <code>color_by</code> str Column for color mapping <code>size_by</code> str Column for size mapping <code>ax</code> Axes Existing axes to use <code>title</code> str Plot title <code>x_label</code> str X-axis label <code>y_label</code> str Y-axis label <code>show_pareto_line</code> bool Draw line through Pareto points <code>figsize</code> tuple Figure size (width, height)"},{"location":"user-guide/visualization/#scatter-matrix","title":"Scatter Matrix","text":"<p>Visualize pairwise relationships between multiple metrics.</p>"},{"location":"user-guide/visualization/#basic-usage_1","title":"Basic Usage","text":"<pre><code>from phased_array_systems.viz import scatter_matrix\n\nfig = scatter_matrix(\n    results,\n    columns=[\"cost_usd\", \"eirp_dbw\", \"link_margin_db\", \"prime_power_w\"],\n)\nfig.savefig(\"scatter_matrix.png\", dpi=150)\n</code></pre>"},{"location":"user-guide/visualization/#with-color-mapping_1","title":"With Color Mapping","text":"<pre><code>fig = scatter_matrix(\n    results,\n    columns=[\"cost_usd\", \"eirp_dbw\", \"link_margin_db\"],\n    color_by=\"n_elements\",\n)\n</code></pre>"},{"location":"user-guide/visualization/#diagonal-options","title":"Diagonal Options","text":"<pre><code># Histogram on diagonal (default)\nfig = scatter_matrix(results, columns=columns, diagonal=\"hist\")\n\n# Kernel density estimate on diagonal\nfig = scatter_matrix(results, columns=columns, diagonal=\"kde\")\n</code></pre>"},{"location":"user-guide/visualization/#full-options_1","title":"Full Options","text":"<pre><code>fig = scatter_matrix(\n    feasible,                    # Use feasible designs only\n    columns=[\"cost_usd\", \"eirp_dbw\", \"link_margin_db\", \"prime_power_w\"],\n    color_by=\"n_elements\",\n    diagonal=\"hist\",             # \"hist\" or \"kde\"\n    figsize=(12, 12),\n    title=\"Trade Space Scatter Matrix\",\n)\n</code></pre>"},{"location":"user-guide/visualization/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>results</code> DataFrame Evaluation results <code>columns</code> list[str] Columns to include <code>color_by</code> str Column for color mapping <code>diagonal</code> str \"hist\" or \"kde\" <code>figsize</code> tuple Figure size <code>title</code> str Overall title"},{"location":"user-guide/visualization/#3d-trade-space-plot","title":"3D Trade Space Plot","text":"<p>Visualize three objectives simultaneously.</p>"},{"location":"user-guide/visualization/#basic-usage_2","title":"Basic Usage","text":"<pre><code>from phased_array_systems.viz import trade_space_plot\n\nfig = trade_space_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    z=\"prime_power_w\",\n)\n</code></pre>"},{"location":"user-guide/visualization/#with-pareto-frontier_1","title":"With Pareto Frontier","text":"<pre><code># 3-objective Pareto\npareto = extract_pareto(feasible, [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n    (\"prime_power_w\", \"minimize\"),\n])\n\nfig = trade_space_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    z=\"prime_power_w\",\n    pareto_front=pareto,\n)\n</code></pre>"},{"location":"user-guide/visualization/#full-options_2","title":"Full Options","text":"<pre><code>fig = trade_space_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    z=\"prime_power_w\",\n    feasible_mask=feasible_mask,\n    pareto_front=pareto,\n    ax=None,                     # Use existing 3D axes\n    figsize=(10, 8),\n    title=\"3D Trade Space\",\n)\n</code></pre>"},{"location":"user-guide/visualization/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>results</code> DataFrame Evaluation results <code>x</code> str Column for x-axis <code>y</code> str Column for y-axis <code>z</code> str Column for z-axis (also color) <code>feasible_mask</code> Series Boolean mask <code>pareto_front</code> DataFrame Pareto-optimal points <code>ax</code> Axes3D Existing 3D axes <code>figsize</code> tuple Figure size <code>title</code> str Plot title"},{"location":"user-guide/visualization/#saving-figures","title":"Saving Figures","text":""},{"location":"user-guide/visualization/#using-save_figure","title":"Using save_figure","text":"<pre><code>from phased_array_systems.viz import save_figure\n\nfig = pareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\")\n\n# PNG (default)\nsave_figure(fig, \"plot.png\", dpi=150)\n\n# PDF (vector)\nsave_figure(fig, \"plot.pdf\")\n\n# SVG\nsave_figure(fig, \"plot.svg\")\n\n# Transparent background\nsave_figure(fig, \"plot.png\", transparent=True)\n</code></pre>"},{"location":"user-guide/visualization/#using-matplotlib-directly","title":"Using matplotlib directly","text":"<pre><code>fig.savefig(\"plot.png\", dpi=150, bbox_inches=\"tight\")\n</code></pre>"},{"location":"user-guide/visualization/#custom-styling","title":"Custom Styling","text":""},{"location":"user-guide/visualization/#using-existing-axes","title":"Using Existing Axes","text":"<pre><code>import matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(1, 2, figsize=(14, 6))\n\n# Plot on specific axes\npareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\", ax=axes[0])\npareto_plot(results, x=\"cost_usd\", y=\"link_margin_db\", ax=axes[1])\n\nfig.tight_layout()\nfig.savefig(\"combined.png\", dpi=150)\n</code></pre>"},{"location":"user-guide/visualization/#post-processing","title":"Post-Processing","text":"<pre><code>fig = pareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\")\nax = fig.axes[0]\n\n# Add annotations\nax.annotate(\n    \"Best Design\",\n    xy=(best_cost, best_eirp),\n    xytext=(best_cost + 5000, best_eirp + 2),\n    arrowprops=dict(arrowstyle=\"-&gt;\"),\n)\n\n# Add reference lines\nax.axhline(y=40, color='r', linestyle='--', label='Min EIRP Req')\nax.axvline(x=50000, color='g', linestyle='--', label='Budget Limit')\n\nax.legend()\nfig.savefig(\"annotated.png\", dpi=150)\n</code></pre>"},{"location":"user-guide/visualization/#complete-example","title":"Complete Example","text":"<pre><code>\"\"\"Comprehensive visualization example.\"\"\"\n\nimport matplotlib.pyplot as plt\nfrom phased_array_systems.viz import pareto_plot, scatter_matrix, trade_space_plot, save_figure\nfrom phased_array_systems.trades import filter_feasible, extract_pareto\n\n# Filter and extract Pareto\nfeasible = filter_feasible(results, requirements)\nfeasible_mask = results[\"verification.passes\"] == 1.0\n\npareto_2d = extract_pareto(feasible, [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n])\n\npareto_3d = extract_pareto(feasible, [\n    (\"cost_usd\", \"minimize\"),\n    (\"eirp_dbw\", \"maximize\"),\n    (\"prime_power_w\", \"minimize\"),\n])\n\n# Create output directory\nfrom pathlib import Path\noutput_dir = Path(\"./figures\")\noutput_dir.mkdir(exist_ok=True)\n\n# 1. Main Pareto plot\nfig1 = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    pareto_front=pareto_2d,\n    feasible_mask=feasible_mask,\n    color_by=\"link_margin_db\",\n    title=\"Cost vs EIRP Trade Space\",\n    x_label=\"Total Cost (USD)\",\n    y_label=\"EIRP (dBW)\",\n)\nsave_figure(fig1, output_dir / \"pareto_cost_eirp.png\", dpi=150)\n\n# 2. Alternative Pareto view\nfig2 = pareto_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"link_margin_db\",\n    pareto_front=extract_pareto(feasible, [\n        (\"cost_usd\", \"minimize\"),\n        (\"link_margin_db\", \"maximize\"),\n    ]),\n    feasible_mask=feasible_mask,\n    title=\"Cost vs Link Margin\",\n)\nsave_figure(fig2, output_dir / \"pareto_cost_margin.png\", dpi=150)\n\n# 3. Scatter matrix\nfig3 = scatter_matrix(\n    feasible,\n    columns=[\"cost_usd\", \"eirp_dbw\", \"link_margin_db\", \"prime_power_w\", \"n_elements\"],\n    color_by=\"array.nx\",\n    diagonal=\"hist\",\n    title=\"Trade Space Correlations (Feasible Designs)\",\n    figsize=(14, 14),\n)\nsave_figure(fig3, output_dir / \"scatter_matrix.png\", dpi=150)\n\n# 4. 3D trade space\nfig4 = trade_space_plot(\n    results,\n    x=\"cost_usd\",\n    y=\"eirp_dbw\",\n    z=\"prime_power_w\",\n    feasible_mask=feasible_mask,\n    pareto_front=pareto_3d,\n    title=\"3D Trade Space (Cost, EIRP, Power)\",\n)\nsave_figure(fig4, output_dir / \"trade_space_3d.png\", dpi=150)\n\n# 5. Multi-panel figure\nfig5, axes = plt.subplots(2, 2, figsize=(14, 12))\n\npareto_plot(results, x=\"cost_usd\", y=\"eirp_dbw\",\n            pareto_front=pareto_2d, feasible_mask=feasible_mask, ax=axes[0, 0],\n            title=\"Cost vs EIRP\")\n\npareto_plot(results, x=\"cost_usd\", y=\"link_margin_db\",\n            feasible_mask=feasible_mask, ax=axes[0, 1],\n            title=\"Cost vs Margin\")\n\npareto_plot(results, x=\"n_elements\", y=\"eirp_dbw\",\n            feasible_mask=feasible_mask, ax=axes[1, 0],\n            title=\"Array Size vs EIRP\")\n\npareto_plot(results, x=\"prime_power_w\", y=\"eirp_dbw\",\n            feasible_mask=feasible_mask, ax=axes[1, 1],\n            title=\"Power vs EIRP\")\n\nfig5.tight_layout()\nsave_figure(fig5, output_dir / \"multi_panel.png\", dpi=150)\n\nplt.close(\"all\")\nprint(f\"Figures saved to {output_dir}\")\n</code></pre>"},{"location":"user-guide/visualization/#tips","title":"Tips","text":""},{"location":"user-guide/visualization/#1-use-consistent-coloring","title":"1. Use Consistent Coloring","text":"<pre><code># Same color_by across plots for consistency\nfor x_metric in [\"cost_usd\", \"prime_power_w\", \"n_elements\"]:\n    fig = pareto_plot(\n        results, x=x_metric, y=\"eirp_dbw\",\n        color_by=\"link_margin_db\",  # Consistent coloring\n    )\n</code></pre>"},{"location":"user-guide/visualization/#2-close-figures","title":"2. Close Figures","text":"<pre><code>plt.close(\"all\")  # Prevent memory issues with many plots\n</code></pre>"},{"location":"user-guide/visualization/#3-non-interactive-backend","title":"3. Non-Interactive Backend","text":"<p>For scripts without display:</p> <pre><code>import matplotlib\nmatplotlib.use(\"Agg\")  # Before importing pyplot\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"user-guide/visualization/#4-high-quality-export","title":"4. High-Quality Export","text":"<pre><code># For publications\nfig.savefig(\"plot.pdf\", dpi=300, bbox_inches=\"tight\")\n\n# For presentations\nfig.savefig(\"plot.png\", dpi=150, transparent=True)\n</code></pre>"},{"location":"user-guide/visualization/#see-also","title":"See Also","text":"<ul> <li>Trade Studies - Generate results to visualize</li> <li>Pareto Analysis - Extract Pareto frontiers</li> <li>Reports - Generate HTML reports with embedded figures</li> <li>API Reference - Full API documentation</li> </ul>"}]}